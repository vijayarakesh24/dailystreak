import { createRequire as __createRequire } from 'node:module';
import { fileURLToPath as __fileURLToPath } from 'node:url';
import { dirname as __dirname_ } from 'node:path';
const require = __createRequire(import.meta.url);
const __filename = __fileURLToPath(import.meta.url);
const __dirname = __dirname_(__filename);
import {
  box,
  did_you_mean_default,
  executeUpgrade
} from "./chunks/chunk-E3EE3UT7.js";
import {
  getUpdateCommand,
  isGlobal
} from "./chunks/chunk-7B47BCEP.js";
import {
  Now,
  collectContactInformation,
  createCertForCns,
  displayBuildLogs,
  displayRuntimeLogs,
  extractDomain,
  getDomain,
  getDomainByName,
  getDomainPrice,
  getDomainStatus,
  isDeploying,
  isWildcardAlias,
  pollForOrder,
  printDeploymentStatus,
  purchaseDomain,
  require_cjs,
  require_date_fns,
  require_format,
  setupDomain
} from "./chunks/chunk-JFI4KZ6I.js";
import {
  login,
  processRevocationResponse,
  require_open,
  revocationRequest,
  sleep,
  ua_default,
  writeToAuthConfigFile,
  writeToConfigFile
} from "./chunks/chunk-NHDFW4ZT.js";
import "./chunks/chunk-2XDWQZS5.js";
import {
  formatTable,
  getCustomEnvironments,
  getInvalidSubcommand,
  pickCustomEnvironment,
  readStandardInput
} from "./chunks/chunk-UTND2HYB.js";
import "./chunks/chunk-NSDOFVJX.js";
import {
  getCommandFlags,
  isValidName
} from "./chunks/chunk-I63FYLJU.js";
import {
  getDeployment,
  mapCertError,
  toHost
} from "./chunks/chunk-KPWGRSMM.js";
import {
  getScope
} from "./chunks/chunk-G5PIH4IE.js";
import {
  formatEnvironment,
  validateJsonOutput,
  validateLsArgs
} from "./chunks/chunk-U4HS72BS.js";
import {
  getSubcommand as getSubcommand2
} from "./chunks/chunk-YPQSDAEW.js";
import {
  abortSubcommand,
  addStoreSubcommand,
  addSubcommand,
  addSubcommand2,
  addSubcommand3,
  addSubcommand4,
  addSubcommand5,
  addSubcommand7 as addSubcommand6,
  addSubcommand8 as addSubcommand7,
  addSubcommand9 as addSubcommand8,
  aliasCommand,
  apiCommand,
  approveSubcommand,
  archiveSubcommand,
  balanceSubcommand,
  bisectCommand,
  blobCommand,
  buySubcommand,
  cacheCommand,
  certsCommand,
  completeSubcommand,
  configureSubcommand,
  connectSubcommand,
  copySubcommand,
  createSubcommand,
  createThresholdSubcommand,
  curlCommand,
  dangerouslyDeleteSubcommand,
  delSubcommand,
  disableSubcommand,
  disableSubcommand2,
  disableSubcommand3,
  disconnectSubcommand,
  disconnectSubcommand2,
  discoverSubcommand,
  dnsCommand,
  domainsCommand,
  enableSubcommand,
  enableSubcommand2,
  enableSubcommand3,
  fetchSubcommand,
  flagsCommand,
  flushSubcommand,
  getCommandAliases,
  getStoreSubcommand,
  getSubcommand,
  gitCommand,
  guidanceCommand,
  httpstatCommand,
  importSubcommand,
  initCommand,
  inspectCommand,
  inspectSubcommand,
  inspectSubcommand2,
  inspectSubcommand3,
  installCommand,
  integrationCommand,
  integrationResourceCommand,
  invalidateSubcommand,
  inviteSubcommand,
  issueSubcommand,
  listSubcommand,
  listSubcommand10,
  listSubcommand11,
  listSubcommand12,
  listSubcommand13,
  listSubcommand2,
  listSubcommand3,
  listSubcommand4,
  listSubcommand5,
  listSubcommand6,
  listSubcommand7,
  listSubcommand8,
  listSubcommand9,
  listVersionsSubcommand,
  logoutCommand,
  mcpCommand,
  microfrontendsCommand,
  moveSubcommand,
  openCommand,
  openSubcommand,
  projectCommand,
  promoteCommand,
  promoteSubcommand,
  pullSubcommand,
  purgeSubcommand,
  putSubcommand,
  redeployCommand,
  redirectsCommand,
  removeCommand,
  removeStoreSubcommand,
  removeSubcommand,
  removeSubcommand10,
  removeSubcommand2,
  removeSubcommand3,
  removeSubcommand4,
  removeSubcommand5,
  removeSubcommand6,
  removeSubcommand7,
  removeSubcommand8,
  removeSubcommand9,
  restoreSubcommand,
  rollbackCommand,
  rollingReleaseCommand,
  sdkKeysAddSubcommand,
  sdkKeysListSubcommand,
  sdkKeysRemoveSubcommand,
  sdkKeysSubcommand,
  setSubcommand,
  startSubcommand,
  statusSubcommand,
  statusSubcommand2,
  statusSubcommand3,
  statusSubcommand4,
  storeSubcommand,
  switchSubcommand,
  targetCommand,
  teamsCommand,
  telemetryCommand,
  transferInSubcommand,
  upgradeCommand,
  uploadSubcommand,
  webhooksCommand,
  whoamiCommand
} from "./chunks/chunk-PWJAMIXL.js";
import "./chunks/chunk-CFBB5OKL.js";
import {
  logsCommand
} from "./chunks/chunk-S367OLQP.js";
import "./chunks/chunk-UB2YPYLD.js";
import {
  main
} from "./chunks/chunk-X3FFQHYP.js";
import "./chunks/chunk-4LIW5I5B.js";
import {
  require_dist as require_dist2,
  require_tar_fs
} from "./chunks/chunk-PFKNXAIG.js";
import {
  require_lib as require_lib3
} from "./chunks/chunk-7OCX2CUX.js";
import {
  require_execa
} from "./chunks/chunk-B2VOZEQL.js";
import "./chunks/chunk-HEYUAUQE.js";
import "./chunks/chunk-M5TNZBCT.js";
import {
  ensureLink
} from "./chunks/chunk-I3CS55DR.js";
import "./chunks/chunk-RPXSHEGV.js";
import "./chunks/chunk-7AN5BKPP.js";
import "./chunks/chunk-I4USAAOX.js";
import {
  help,
  table
} from "./chunks/chunk-YO3WHMKT.js";
import {
  APIError,
  AliasInUse,
  CertConfigurationError,
  CertError,
  CertMissing,
  CertNotFound,
  CertOrderNotFound,
  CertsPermissionDenied,
  DNSConflictingRecord,
  DNSInvalidPort,
  DNSInvalidType,
  DNSPermissionDenied,
  DeploymentFailedAliasImpossible,
  DeploymentNotFound,
  DeploymentNotReady,
  DeploymentPermissionDenied,
  DomainAlreadyExists,
  DomainExternal,
  DomainMoveConflict,
  DomainNotAvailable,
  DomainNotFound,
  DomainNotVerified,
  DomainPaymentError,
  DomainPermissionDenied,
  DomainPurchasePending,
  DomainRemovalConflict,
  InvalidAlias,
  InvalidAliasInConfig,
  InvalidDeploymentId,
  InvalidDomain,
  InvalidMoveDestination,
  NoAliasInConfig,
  NowError,
  ProjectNotFound,
  SourceNotFound,
  TLDNotSupportedViaCLI,
  TelemetryClient,
  TooManyRequests,
  UnexpectedDomainPurchaseError,
  UnexpectedDomainTransferError,
  UnsupportedTLD,
  UserAborted,
  checkExistsAndConnect,
  cmd,
  code,
  createEnvObject,
  createGitMeta,
  createProject,
  disconnectGitProvider,
  elapsed,
  formatProject,
  getCommandName,
  getFlagsSpecification,
  getLinkedProject,
  getProjectByNameOrId,
  getTeamById,
  getTeams,
  getUser,
  global_path_default,
  humanizePath,
  isAPIError,
  list,
  packageName,
  param,
  parseArguments,
  parseGitConfig,
  parseRepoUrl,
  pluckRemoteUrls,
  printError,
  printRemoteUrls,
  pull,
  require_bytes,
  require_frameworks,
  require_lib,
  require_lib2,
  require_ms,
  require_pluralize,
  selectAndParseRemoteUrl,
  stamp_default
} from "./chunks/chunk-62EDLXXJ.js";
import {
  emoji,
  eraseLines,
  init_pkg,
  link_default,
  output_manager_default,
  pkg_default,
  prependEmoji,
  require_dist
} from "./chunks/chunk-6TPHDHH6.js";
import {
  require_source
} from "./chunks/chunk-6H7E5JAU.js";
import {
  __require,
  __toESM
} from "./chunks/chunk-LCYENQ63.js";

// src/commands/alias/ls.ts
var import_chalk = __toESM(require_source(), 1);
var import_ms = __toESM(require_ms(), 1);

// src/util/alias/get-aliases.ts
async function getAliases(client, deploymentId, next, limit = 20) {
  let aliasUrl = `/v3/now/aliases?limit=${limit}`;
  if (next) {
    aliasUrl += `&until=${next}`;
  }
  const to = deploymentId ? `/now/deployments/${deploymentId}/aliases` : aliasUrl;
  try {
    const payload = await client.fetch(to);
    return payload;
  } catch (err) {
    if (isAPIError(err)) {
      const contextName = await getScope(client).then(
        (scope) => scope.contextName
      );
      if (err.status === 404) {
        throw new DeploymentNotFound({
          id: deploymentId,
          context: contextName
        });
      }
      if (err.status === 403 && deploymentId) {
        throw new DeploymentPermissionDenied(deploymentId, contextName);
      }
      if (err.status === 400 && err.message.includes("`id`") && deploymentId) {
        throw new InvalidDeploymentId(deploymentId);
      }
    }
    throw err;
  }
}

// src/util/get-pagination-opts.ts
function getPaginationOpts(opts) {
  const { "--next": nextTimestamp, "--limit": limit } = opts;
  if (typeof nextTimestamp !== void 0 && Number.isNaN(nextTimestamp)) {
    throw new Error("Please provide a number for option --next");
  }
  if (typeof limit === "number" && (!Number.isInteger(limit) || limit > 100 || limit < 1)) {
    throw new Error(
      "Please provide an integer from 1 to 100 for option --limit"
    );
  }
  return [nextTimestamp, limit];
}

// src/util/telemetry/commands/alias/list.ts
var AliasListTelemetryClient = class extends TelemetryClient {
  trackCliOptionLimit(limit) {
    if (limit) {
      this.trackCliOption({
        option: "limit",
        value: String(limit)
      });
    }
  }
  trackCliOptionNext(next) {
    if (next) {
      this.trackCliOption({
        option: "next",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/alias/ls.ts
async function ls(client, argv) {
  let parsedArguments;
  const flagsSpecification = getFlagsSpecification(listSubcommand.options);
  try {
    parsedArguments = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags: opts } = parsedArguments;
  const validationResult = validateLsArgs({
    commandName: "alias ls",
    args
  });
  if (validationResult !== 0) {
    return validationResult;
  }
  const { contextName } = await getScope(client);
  const telemetryClient = new AliasListTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let paginationOptions;
  const formatResult = validateJsonOutput(opts);
  if (!formatResult.valid) {
    output_manager_default.error(formatResult.error);
    return 1;
  }
  const asJson = formatResult.jsonOutput;
  try {
    paginationOptions = getPaginationOpts(opts);
    const [next, limit] = paginationOptions;
    telemetryClient.trackCliOptionNext(next);
    telemetryClient.trackCliOptionLimit(limit);
    telemetryClient.trackCliOptionFormat(opts["--format"]);
  } catch (err) {
    output_manager_default.prettyError(err);
    return 1;
  }
  const lsStamp = stamp_default();
  output_manager_default.spinner(`Fetching aliases under ${import_chalk.default.bold(contextName)}`);
  const { aliases, pagination } = await getAliases(
    client,
    void 0,
    ...paginationOptions
  );
  if (asJson) {
    output_manager_default.stopSpinner();
    const jsonOutput = {
      aliases: aliases.map((a) => ({
        alias: a.alias,
        deploymentId: a.deploymentId,
        url: a.deployment?.url ?? null,
        createdAt: a.createdAt
      })),
      pagination
    };
    client.stdout.write(`${JSON.stringify(jsonOutput, null, 2)}
`);
  } else {
    output_manager_default.log(`aliases found under ${import_chalk.default.bold(contextName)} ${lsStamp()}`);
    client.stdout.write(printAliasTable(aliases));
    if (pagination.count === 20) {
      const flags = getCommandFlags(opts, ["_", "--next", "--format"]);
      output_manager_default.log(
        `To display the next page run ${getCommandName(
          `alias ls${flags} --next ${pagination.next}`
        )}`
      );
    }
  }
  return 0;
}
function printAliasTable(aliases) {
  return `${table(
    [
      ["source", "url", "age"].map((header) => import_chalk.default.gray(header)),
      ...aliases.map((a) => [
        // for legacy reasons, we might have situations
        // where the deployment was deleted and the alias
        // not collected appropriately, and we need to handle it
        a.deployment?.url ? a.deployment.url : import_chalk.default.gray("\u2013"),
        a.alias,
        (0, import_ms.default)(Date.now() - a.createdAt)
      ])
    ],
    { align: ["l", "l", "r"], hsep: 4 }
  ).replace(/^/gm, "  ")}

`;
}

// src/commands/alias/rm.ts
var import_chalk2 = __toESM(require_source(), 1);
var import_ms2 = __toESM(require_ms(), 1);

// src/util/alias/remove-alias-by-id.ts
async function removeAliasById(client, id) {
  return client.fetch(`/now/aliases/${id}`, {
    method: "DELETE"
  });
}

// src/util/alias/find-alias-by-alias-or-id.ts
async function findAliasByAliasOrId(client, aliasOrId) {
  return client.fetch(
    `/now/aliases/${encodeURIComponent(getSafeAlias(aliasOrId))}`
  );
}
function getSafeAlias(alias2) {
  return alias2.replace(/^https:\/\//i, "").replace(/^\.+/, "").replace(/\.+$/, "").toLowerCase();
}

// src/util/telemetry/commands/alias/remove.ts
var AliasRemoveTelemetryClient = class extends TelemetryClient {
  trackCliArgumentAlias(alias2) {
    if (alias2) {
      this.trackCliArgument({
        arg: "alias",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
};

// src/commands/alias/rm.ts
async function rm(client, argv) {
  let parsedArguments;
  const flagsSpecification = getFlagsSpecification(removeSubcommand.options);
  try {
    parsedArguments = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags: opts } = parsedArguments;
  const { contextName } = await getScope(client);
  const telemetryClient = new AliasRemoveTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  telemetryClient.trackCliFlagYes(opts["--yes"]);
  const [aliasOrId] = args;
  telemetryClient.trackCliArgumentAlias(aliasOrId);
  if (args.length !== 1) {
    output_manager_default.error(
      `Invalid number of arguments. Usage: ${import_chalk2.default.cyan(
        `${getCommandName("alias rm <alias>")}`
      )}`
    );
    return 1;
  }
  if (!aliasOrId) {
    output_manager_default.error(`${getCommandName("alias rm <alias>")} expects one argument`);
    return 1;
  }
  if (!isValidName(aliasOrId)) {
    output_manager_default.error(`The provided argument "${aliasOrId}" is not a valid alias`);
    return 1;
  }
  const alias2 = await findAliasByAliasOrId(client, aliasOrId);
  if (!alias2) {
    output_manager_default.error(
      `Alias not found by "${aliasOrId}" under ${import_chalk2.default.bold(contextName)}`
    );
    output_manager_default.log(`Run ${getCommandName("alias ls")} to see your aliases.`);
    return 1;
  }
  const removeStamp = stamp_default();
  if (!opts["--yes"] && !await confirmAliasRemove(client, alias2)) {
    output_manager_default.log("Canceled");
    return 0;
  }
  await removeAliasById(client, alias2.uid);
  output_manager_default.success(`Alias ${import_chalk2.default.bold(alias2.alias)} removed ${removeStamp()}`);
  return 0;
}
async function confirmAliasRemove(client, alias2) {
  const srcUrl = alias2.deployment ? import_chalk2.default.underline(alias2.deployment.url) : null;
  const tbl = table(
    [
      [
        ...srcUrl ? [srcUrl] : [],
        import_chalk2.default.underline(alias2.alias),
        import_chalk2.default.gray(`${(0, import_ms2.default)(Date.now() - alias2.createdAt)} ago`)
      ]
    ],
    { hsep: 4 }
  );
  output_manager_default.log("The following alias will be removed permanently");
  output_manager_default.print(`  ${tbl}
`);
  return client.input.confirm(import_chalk2.default.red("Are you sure?"), false);
}

// src/commands/alias/set.ts
var import_chalk6 = __toESM(require_source(), 1);

// src/util/certs/get-wildcard-cns-for-alias.ts
var import_tldts = __toESM(require_cjs(), 1);
function getWildcardCNSForAlias(alias2) {
  if (isWildcardAlias(alias2)) {
    return [extractDomain(alias2), alias2];
  }
  const parsedDomain = (0, import_tldts.parse)(alias2);
  const { domain, subdomain } = parsedDomain;
  if (!domain) {
    throw new InvalidDomain(alias2);
  }
  const secondLevel = subdomain && subdomain.includes(".") ? subdomain.split(".").slice(1).join(".") : null;
  const root = secondLevel ? `${secondLevel}.${domain}` : domain;
  return [root, `*.${root}`];
}

// src/util/output/join-words.ts
function joinWords(words = []) {
  if (words.length === 0) {
    return "";
  }
  if (words.length === 1) {
    return words[0];
  }
  const last = words[words.length - 1];
  const rest = words.slice(0, words.length - 1);
  return `${rest.join(", ")} and ${last}`;
}

// src/util/certs/create-cert-for-alias.ts
async function createCertificateForAlias(client, context, alias2, shouldBeWildcard) {
  output_manager_default.spinner(`Generating a certificate\u2026`);
  const cns = shouldBeWildcard ? getWildcardCNSForAlias(alias2) : [alias2];
  const certStamp = stamp_default();
  const cert = await createCertForCns(client, cns, context);
  if (cert instanceof NowError) {
    output_manager_default.stopSpinner();
    return cert;
  }
  output_manager_default.log(
    `Certificate for ${joinWords(cert.cns)} (${cert.uid}) created ${certStamp()}`
  );
  return cert;
}

// src/util/alias/create-alias.ts
async function createAlias(client, contextName, deployment, alias2, externalDomain) {
  output_manager_default.spinner(`Creating alias`);
  const result = await performCreateAlias(
    client,
    contextName,
    deployment,
    alias2
  );
  output_manager_default.stopSpinner();
  if (result instanceof CertMissing) {
    const cert = await createCertificateForAlias(
      client,
      contextName,
      alias2,
      !externalDomain
    );
    if (cert instanceof Error) {
      return cert;
    }
    output_manager_default.spinner(`Creating alias`);
    const secondTry = await performCreateAlias(
      client,
      contextName,
      deployment,
      alias2
    );
    output_manager_default.stopSpinner();
    return secondTry;
  }
  return result;
}
async function performCreateAlias(client, contextName, deployment, alias2) {
  try {
    return await client.fetch(
      `/now/deployments/${deployment.id}/aliases`,
      {
        method: "POST",
        body: { alias: alias2 }
      }
    );
  } catch (err) {
    if (isAPIError(err)) {
      if (err.code === "cert_missing" || err.code === "cert_expired") {
        return new CertMissing(alias2);
      }
      if (err.status === 409) {
        return { uid: err.uid, alias: err.alias };
      }
      if (err.code === "deployment_not_found" || err.code === "not_found") {
        return new DeploymentNotFound({
          context: contextName,
          id: deployment.id
        });
      }
      if (err.code === "gone") {
        return new DeploymentFailedAliasImpossible();
      }
      if (err.code === "invalid_alias") {
        return new InvalidAlias(alias2);
      }
      if (err.code === "deployment_not_ready") {
        return new DeploymentNotReady({ url: deployment.url });
      }
      if (err.status === 403) {
        if (err.code === "alias_in_use") {
          return new AliasInUse(alias2);
        }
        if (err.code === "forbidden") {
          return new DomainPermissionDenied(alias2, contextName);
        }
      }
    }
    throw err;
  }
}

// src/util/domains/is-domain-external.ts
function isDomainExternal(domain) {
  return domain.serviceType !== "zeit.world";
}

// src/util/alias/assign-alias.ts
async function assignAlias(client, deployment, alias2, contextName) {
  let externalDomain = false;
  if (alias2.indexOf(".") !== -1 && !alias2.endsWith(".now.sh") && !alias2.endsWith(".vercel.app")) {
    const result = await setupDomain(client, alias2, contextName);
    if (result instanceof Error) {
      return result;
    }
    externalDomain = isDomainExternal(result);
  }
  const record = await createAlias(
    client,
    contextName,
    deployment,
    alias2,
    externalDomain
  );
  return record;
}

// src/util/alias/get-deployment-by-alias.ts
var import_chalk3 = __toESM(require_source(), 1);
import path from "path";

// src/util/deploy/get-deployments-by-appname.ts
async function fetchDeploymentsByAppName(client, appName) {
  const { deployments } = await client.fetch(
    `/v3/now/deployments?app=${encodeURIComponent(appName)}`
  );
  return deployments;
}

// src/util/alias/get-deployment-by-alias.ts
async function getAppLastDeployment(client, appName, user, contextName) {
  output_manager_default.debug(`Looking for deployments matching app ${appName}`);
  const deployments = await fetchDeploymentsByAppName(client, appName);
  const deploymentItem = deployments.sort((a, b) => b.created - a.created).filter((dep) => dep.state === "READY" && dep.creator.uid === user.id)[0];
  if (deploymentItem) {
    return await getDeployment(client, contextName, deploymentItem.uid);
  }
  return null;
}
async function getDeploymentForAlias(client, args, localConfigPath, user, contextName, localConfig) {
  output_manager_default.spinner(`Fetching deployment to alias in ${import_chalk3.default.bold(contextName)}`);
  if (args.length === 2) {
    const [deploymentId] = args;
    try {
      return await getDeployment(client, contextName, deploymentId);
    } finally {
      output_manager_default.stopSpinner();
    }
  }
  const appName = localConfig?.name || path.basename(path.resolve(process.cwd(), localConfigPath || ""));
  if (!appName) {
    return null;
  }
  try {
    return await getAppLastDeployment(client, appName, user, contextName);
  } finally {
    output_manager_default.stopSpinner();
  }
}

// src/util/certs/handle-cert-error.ts
var import_ms3 = __toESM(require_ms(), 1);
var import_tldts2 = __toESM(require_cjs(), 1);
var import_chalk5 = __toESM(require_source(), 1);

// src/util/format-dns-table.ts
var import_chalk4 = __toESM(require_source(), 1);
var HEADER = ["name", "type", "value"].map((v) => (0, import_chalk4.gray)(v));
function formatDNSTable(rows) {
  return table([HEADER, ...rows], { hsep: 8 });
}

// src/util/certs/handle-cert-error.ts
function handleCertError(error) {
  if (error instanceof TooManyRequests) {
    output_manager_default.error(
      `Too many requests detected for ${error.meta.api} API. Try again in ${(0, import_ms3.default)(
        error.meta.retryAfterMs,
        {
          long: true
        }
      )}.`
    );
    return 1;
  }
  if (error instanceof CertError) {
    output_manager_default.error(error.message);
    if (error.meta.helpUrl) {
      output_manager_default.print(`  Read more: ${error.meta.helpUrl}
`);
    }
    return 1;
  }
  if (error instanceof DomainNotFound) {
    output_manager_default.error(error.message);
    return 1;
  }
  if (error instanceof CertConfigurationError) {
    const { external, cns } = error.meta;
    output_manager_default.error(
      `We couldn't verify the propagation of the DNS settings for ${error.meta.cns.map((cn) => import_chalk5.default.underline(cn)).join(", ")}`
    );
    if (external) {
      output_manager_default.print(
        `  The propagation may take a few minutes, but please verify your settings:

`
      );
      output_manager_default.print(
        `${formatDNSTable(
          cns.map((cn) => {
            const parsed = (0, import_tldts2.parse)(cn);
            return parsed.subdomain ? [parsed.subdomain, "ALIAS", "alias.vercel.com"] : ["", "ALIAS", "alias.vercel.com"];
          })
        )}

`
      );
      output_manager_default.log(
        `Alternatively, you can issue a certificate solving DNS challenges manually after running:`
      );
      output_manager_default.print(
        `  ${getCommandName(`certs issue --challenge-only <cns>`)}
`
      );
      output_manager_default.print(
        "  Read more: https://err.sh/vercel/dns-configuration-error\n"
      );
    } else {
      output_manager_default.print(
        `  We configured them for you, but the propagation may take a few minutes. Please try again later.
`
      );
      output_manager_default.print(
        "  Read more: https://err.sh/vercel/dns-configuration-error\n\n"
      );
    }
    return 1;
  }
  return error;
}

// src/util/telemetry/commands/alias/set.ts
var AliasSetTelemetryClient = class extends TelemetryClient {
  trackCliFlagDebug(flag) {
    if (flag) {
      this.trackCliFlag("debug");
    }
  }
  trackCliOptionLocalConfig(localConfig) {
    if (localConfig) {
      this.trackCliOption({
        option: "local-config",
        value: this.redactedValue
      });
    }
  }
  trackCliArgumentDeployment(deploymentUrl) {
    if (deploymentUrl) {
      this.trackCliArgument({
        arg: "deployment-url",
        value: this.redactedValue
      });
    }
  }
  trackCliArgumentAlias(customDomain) {
    if (customDomain) {
      this.trackCliArgument({
        arg: "custom-domain",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/alias/set.ts
async function set(client, argv) {
  let parsedArguments;
  const flagsSpecification = getFlagsSpecification(listSubcommand.options);
  try {
    parsedArguments = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags: opts } = parsedArguments;
  const setStamp = stamp_default();
  const { localConfig } = client;
  const telemetryClient = new AliasSetTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  telemetryClient.trackCliFlagDebug(opts["--debug"]);
  telemetryClient.trackCliOptionLocalConfig(opts["--local-config"]);
  const { contextName, user } = await getScope(client);
  if (args.length > 2) {
    output_manager_default.error(
      `${getCommandName(
        "alias <deployment> <target>"
      )} accepts at most two arguments`
    );
    return 1;
  }
  if (args.length >= 1 && !isValidName(args[0])) {
    output_manager_default.error(
      `The provided argument "${args[0]}" is not a valid deployment`
    );
    return 1;
  }
  if (args.length >= 2 && !isValidName(args[1])) {
    output_manager_default.error(`The provided argument "${args[1]}" is not a valid domain`);
    return 1;
  }
  if (args.length === 0) {
    output_manager_default.error(
      `To ship to production, optionally configure your domains (${link_default(
        "https://vercel.link/domain-configuration"
      )}) and run ${getCommandName("--prod")}.`
    );
    return 1;
  }
  if (args.length === 1) {
    const [aliasTarget2] = args;
    telemetryClient.trackCliArgumentAlias(aliasTarget2);
    const deployment2 = handleCertError(
      await getDeploymentForAlias(
        client,
        args,
        opts["--local-config"],
        user,
        contextName,
        localConfig
      )
    );
    if (deployment2 === 1) {
      return deployment2;
    }
    if (deployment2 instanceof Error) {
      output_manager_default.error(deployment2.message);
      return 1;
    }
    if (!deployment2) {
      output_manager_default.error(
        `Couldn't find a deployment to alias. Please provide one as an argument.`
      );
      return 1;
    }
    const targets = getTargetsForAlias(args, localConfig);
    if (targets instanceof Error) {
      output_manager_default.prettyError(targets);
      return 1;
    }
    for (const target of targets) {
      output_manager_default.log(`Assigning alias ${target} to deployment ${deployment2.url}`);
      const record2 = await assignAlias(client, deployment2, target, contextName);
      const handleResult2 = handleSetupDomainError(
        handleCreateAliasError(record2)
      );
      if (handleResult2 === 1) {
        return 1;
      }
      output_manager_default.success(
        `${import_chalk6.default.bold(
          `${isWildcardAlias(target) ? "" : "https://"}${handleResult2.alias}`
        )} now points to https://${deployment2.url} ${setStamp()}`
      );
    }
    return 0;
  }
  const [deploymentIdOrHost, aliasTarget] = args;
  telemetryClient.trackCliArgumentDeployment(deploymentIdOrHost);
  telemetryClient.trackCliArgumentAlias(aliasTarget);
  const deployment = handleCertError(
    await getDeployment(client, contextName, deploymentIdOrHost)
  );
  if (deployment === 1) {
    return deployment;
  }
  if (deployment === null) {
    output_manager_default.error(
      `Couldn't find a deployment to alias. Please provide one as an argument.`
    );
    return 1;
  }
  output_manager_default.log(`Assigning alias ${aliasTarget} to deployment ${deployment.url}`);
  const isWildcard = isWildcardAlias(aliasTarget);
  const record = await assignAlias(
    client,
    deployment,
    aliasTarget,
    contextName
  );
  const handleResult = handleSetupDomainError(handleCreateAliasError(record));
  if (handleResult === 1) {
    return 1;
  }
  const prefix = isWildcard ? "" : "https://";
  output_manager_default.success(
    `${import_chalk6.default.bold(`${prefix}${handleResult.alias}`)} now points to https://${deployment.url} ${setStamp()}`
  );
  return 0;
}
function handleSetupDomainError(error) {
  if (error instanceof DomainPermissionDenied) {
    output_manager_default.error(
      `You don't have permissions over domain ${import_chalk6.default.underline(
        error.meta.domain
      )} under ${import_chalk6.default.bold(error.meta.context)}.`
    );
    return 1;
  }
  if (error instanceof UserAborted) {
    output_manager_default.error("User canceled.");
    return 1;
  }
  if (error instanceof DomainNotFound) {
    output_manager_default.error("You should buy the domain before aliasing.");
    return 1;
  }
  if (error instanceof UnsupportedTLD) {
    output_manager_default.error(
      `The TLD for domain name ${error.meta.domain} is not supported.`
    );
    return 1;
  }
  if (error instanceof InvalidDomain) {
    output_manager_default.error(
      `The domain ${error.meta.domain} used for the alias is not valid.`
    );
    return 1;
  }
  if (error instanceof DomainNotAvailable) {
    output_manager_default.error(
      `The domain ${error.meta.domain} is not available to be purchased.`
    );
    return 1;
  }
  if (error instanceof UnexpectedDomainPurchaseError) {
    output_manager_default.error("There was an unexpected error while purchasing the domain.");
    return 1;
  }
  if (error instanceof DomainAlreadyExists) {
    output_manager_default.error(
      `The domain  ${error.meta.domain} exists for a different account.`
    );
    return 1;
  }
  if (error instanceof DomainPurchasePending) {
    output_manager_default.error(
      `The domain ${error.meta.domain} is processing and will be available once the order is completed.`
    );
    output_manager_default.print(
      "  An email will be sent upon completion so you can alias to your new domain.\n"
    );
    return 1;
  }
  if (error instanceof SourceNotFound) {
    output_manager_default.error(
      `You can't purchase the domain you're aliasing to since you have no valid payment method.`
    );
    output_manager_default.print("  Please add a valid payment method and retry.\n");
    return 1;
  }
  if (error instanceof DomainPaymentError) {
    output_manager_default.error(
      `You can't purchase the domain you're aliasing to since your card was declined.`
    );
    output_manager_default.print("  Please add a valid payment method and retry.\n");
    return 1;
  }
  if (error instanceof TLDNotSupportedViaCLI) {
    output_manager_default.error(
      `The TLD for domain name ${error.meta.domain} is not supported via the CLI. Use the REST API or the dashboard to purchase.`
    );
    return 1;
  }
  return error;
}
function handleCreateAliasError(errorOrResult) {
  const error = handleCertError(errorOrResult);
  if (error === 1) {
    return error;
  }
  if (error instanceof AliasInUse) {
    output_manager_default.error(
      `The alias ${import_chalk6.default.dim(
        error.meta.alias
      )} is a deployment URL or it's in use by a different team.`
    );
    return 1;
  }
  if (error instanceof DeploymentNotFound) {
    output_manager_default.error(
      `Failed to find deployment ${import_chalk6.default.dim(error.meta.id)} under ${import_chalk6.default.bold(
        error.meta.context
      )}`
    );
    return 1;
  }
  if (error instanceof InvalidAlias) {
    output_manager_default.error(
      "Invalid alias. Please confirm that the alias you provided is a valid hostname. Note: For `vercel.app`, only sub and sub-sub domains are supported."
    );
    return 1;
  }
  if (error instanceof DeploymentPermissionDenied) {
    output_manager_default.error(
      `No permission to access deployment ${import_chalk6.default.dim(
        error.meta.id
      )} under ${import_chalk6.default.bold(error.meta.context)}`
    );
    return 1;
  }
  if (error instanceof CertMissing) {
    output_manager_default.error(
      `There is no certificate for the domain ${error.meta.domain} and it could not be created.`
    );
    output_manager_default.log(
      `Please generate a new certificate manually with ${getCommandName(
        `certs issue ${error.meta.domain}`
      )}`
    );
    return 1;
  }
  if (error instanceof InvalidDomain) {
    output_manager_default.error(
      `The domain ${error.meta.domain} used for the alias is not valid.`
    );
    return 1;
  }
  if (error instanceof DomainPermissionDenied || error instanceof DeploymentFailedAliasImpossible || error instanceof InvalidDeploymentId) {
    output_manager_default.error(error.message);
    return 1;
  }
  if (error instanceof DeploymentNotReady) {
    output_manager_default.error(error.message);
    return 1;
  }
  return error;
}
function getTargetsForAlias(args, { alias: alias2 } = {}) {
  if (args.length) {
    return [args[args.length - 1]].map((target) => target.indexOf(".") !== -1 ? toHost(target) : target).filter((x) => !!x && typeof x === "string");
  }
  if (!alias2) {
    return new NoAliasInConfig();
  }
  if (typeof alias2 !== "string" && !Array.isArray(alias2)) {
    return new InvalidAliasInConfig(alias2);
  }
  return typeof alias2 === "string" ? [alias2] : alias2;
}

// src/util/telemetry/commands/alias/index.ts
var AliasTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandList(actual) {
    this.trackCliSubcommand({
      subcommand: "list",
      value: actual
    });
  }
  trackCliSubcommandSet(actual) {
    this.trackCliSubcommand({
      subcommand: "set",
      value: actual
    });
  }
  trackCliSubcommandRemove(actual) {
    this.trackCliSubcommand({
      subcommand: "rm",
      value: actual
    });
  }
};

// src/commands/alias/index.ts
var COMMAND_CONFIG = {
  ls: getCommandAliases(listSubcommand),
  rm: getCommandAliases(removeSubcommand),
  set: getCommandAliases(setSubcommand)
};
async function alias(client) {
  const telemetry2 = new AliasTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArguments;
  const flagsSpecification = getFlagsSpecification(aliasCommand.options);
  try {
    parsedArguments = parseArguments(client.argv.slice(2), flagsSpecification, {
      permissive: true
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  const { subcommand, args, subcommandOriginal } = getSubcommand2(
    parsedArguments.args.slice(1),
    COMMAND_CONFIG
  );
  const needHelp = parsedArguments.flags["--help"];
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp("alias");
    output_manager_default.print(help(aliasCommand, { columns: client.stderr.columns }));
    return 2;
  }
  function printHelp(command) {
    output_manager_default.print(
      help(command, { parent: aliasCommand, columns: client.stderr.columns })
    );
  }
  switch (subcommand) {
    case "ls":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("alias", subcommandOriginal);
        printHelp(listSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandList(subcommandOriginal);
      return ls(client, args);
    case "rm":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("alias", subcommandOriginal);
        printHelp(removeSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandRemove(subcommandOriginal);
      return rm(client, args);
    case "set":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("alias", subcommandOriginal);
        printHelp(setSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandSet(subcommandOriginal);
      return set(client, args);
    default:
      if (needHelp) {
        telemetry2.trackCliFlagHelp("alias", subcommandOriginal);
        printHelp(setSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandSet(subcommandOriginal);
      return set(client, args);
  }
}

// src/commands/api/index.ts
var import_chalk8 = __toESM(require_source(), 1);

// src/util/telemetry/commands/api/index.ts
var ApiTelemetryClient = class extends TelemetryClient {
  trackCliArgumentEndpoint(endpoint) {
    if (endpoint) {
      const normalized = this.normalizeEndpoint(endpoint);
      this.trackCliArgument({
        arg: "endpoint",
        value: normalized
      });
    }
  }
  trackCliOptionMethod(method) {
    if (method) {
      const validMethods = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD"];
      const upperMethod = method.toUpperCase();
      const value = validMethods.includes(upperMethod) ? upperMethod : this.redactedValue;
      this.trackCliOption({
        option: "method",
        value
      });
    }
  }
  trackCliOptionField(fields) {
    if (fields && fields.length > 0) {
      this.trackCliOption({
        option: "field",
        value: this.redactedArgumentsLength(fields)
      });
    }
  }
  trackCliOptionRawField(fields) {
    if (fields && fields.length > 0) {
      this.trackCliOption({
        option: "raw-field",
        value: this.redactedArgumentsLength(fields)
      });
    }
  }
  trackCliOptionHeader(headers) {
    if (headers && headers.length > 0) {
      this.trackCliOption({
        option: "header",
        value: this.redactedArgumentsLength(headers)
      });
    }
  }
  trackCliOptionInput(input) {
    if (input) {
      const value = input === "-" ? "stdin" : "file";
      this.trackCliOption({
        option: "input",
        value
      });
    }
  }
  trackCliFlagPaginate(value) {
    if (value) {
      this.trackCliFlag("paginate");
    }
  }
  trackCliFlagInclude(value) {
    if (value) {
      this.trackCliFlag("include");
    }
  }
  trackCliFlagSilent(value) {
    if (value) {
      this.trackCliFlag("silent");
    }
  }
  trackCliFlagVerbose(value) {
    if (value) {
      this.trackCliFlag("verbose");
    }
  }
  trackCliFlagRaw(value) {
    if (value) {
      this.trackCliFlag("raw");
    }
  }
  trackCliFlagRefresh(value) {
    if (value) {
      this.trackCliFlag("refresh");
    }
  }
  trackCliOptionGenerate(format4) {
    if (format4) {
      const validFormats = ["curl"];
      const value = validFormats.includes(format4) ? format4 : this.redactedValue;
      this.trackCliOption({
        option: "generate",
        value
      });
    }
  }
  trackCliFlagDangerouslySkipPermissions(value) {
    if (value) {
      this.trackCliFlag("dangerously-skip-permissions");
    }
  }
  trackCliSubcommandList() {
    this.trackCliSubcommand({ subcommand: "list", value: "list" });
  }
  trackCliOptionFormat(format4) {
    if (format4) {
      const validFormats = ["table", "json"];
      const value = validFormats.includes(format4) ? format4 : this.redactedValue;
      this.trackCliOption({
        option: "format",
        value
      });
    }
  }
  /**
   * Normalize endpoint by replacing IDs with placeholders for privacy
   */
  normalizeEndpoint(endpoint) {
    return endpoint.replace(/\/dpl_[a-zA-Z0-9]+/g, "/:deploymentId").replace(/\/prj_[a-zA-Z0-9]+/g, "/:projectId").replace(/\/team_[a-zA-Z0-9]+/g, "/:teamId").replace(/\/[a-f0-9]{24}/g, "/:id").replace(/\/[a-f0-9-]{36}/g, "/:uuid");
  }
};

// src/commands/api/request-builder.ts
import { readFile } from "fs/promises";
import { resolve } from "path";
async function buildRequest(endpoint, flags) {
  const headers = {};
  let body;
  const customHeaders = flags["--header"] || [];
  for (const header of customHeaders) {
    const colonIndex = header.indexOf(":");
    if (colonIndex > 0) {
      const key = header.substring(0, colonIndex).trim();
      const value = header.substring(colonIndex + 1).trim();
      headers[key] = value;
    }
  }
  const fields = flags["--field"] || [];
  const rawFields = flags["--raw-field"] || [];
  if (fields.length > 0 || rawFields.length > 0) {
    body = {};
    for (const field of fields) {
      const { key, value } = await parseField(field, true);
      body[key] = value;
    }
    for (const field of rawFields) {
      const { key, value } = await parseField(field, false);
      body[key] = value;
    }
  }
  if (flags["--input"]) {
    const inputPath = flags["--input"];
    if (inputPath === "-") {
      body = await readStdin();
    } else {
      body = await readFile(resolve(inputPath), "utf-8");
    }
    if (typeof body === "string") {
      try {
        body = JSON.parse(body);
      } catch {
      }
    }
  }
  let method = flags["--method"]?.toUpperCase() || "GET";
  if (!flags["--method"] && body) {
    method = "POST";
  }
  return {
    url: endpoint,
    method,
    headers,
    body
  };
}
async function parseField(field, typed) {
  const eqIndex = field.indexOf("=");
  if (eqIndex === -1) {
    throw new Error(`Invalid field format: ${field}. Expected key=value`);
  }
  const key = field.substring(0, eqIndex);
  let value = field.substring(eqIndex + 1);
  if (typed && typeof value === "string") {
    if (value.startsWith("@")) {
      const filePath = value.substring(1);
      if (filePath === "-") {
        value = await readStdin();
      } else {
        value = await readFile(resolve(filePath), "utf-8");
      }
      if (typeof value === "string") {
        try {
          value = JSON.parse(value);
        } catch {
        }
      }
    } else if (value === "true") {
      value = true;
    } else if (value === "false") {
      value = false;
    } else if (value === "null") {
      value = null;
    } else if (/^-?\d+$/.test(value)) {
      value = parseInt(value, 10);
    } else if (/^-?\d*\.\d+$/.test(value)) {
      value = parseFloat(value);
    } else if (value.startsWith("[") || value.startsWith("{")) {
      try {
        value = JSON.parse(value);
      } catch {
      }
    }
  }
  return { key, value };
}
async function readStdin() {
  const chunks = [];
  for await (const chunk of process.stdin) {
    chunks.push(chunk);
  }
  return Buffer.concat(chunks).toString("utf-8");
}
function formatOutput(data, options) {
  if (options.raw) {
    if (typeof data === "string") {
      return data;
    }
    return JSON.stringify(data);
  }
  return JSON.stringify(data, null, 2);
}
function generateCurlCommand(config, baseUrl) {
  const parts = ["curl"];
  if (config.method !== "GET") {
    parts.push(`-X ${config.method}`);
  }
  parts.push(`-H 'Authorization: Bearer <TOKEN>'`);
  for (const [key, value] of Object.entries(config.headers)) {
    parts.push(`-H '${key}: ${escapeShellArg(value)}'`);
  }
  if (config.body) {
    const bodyStr = typeof config.body === "string" ? config.body : JSON.stringify(config.body);
    parts.push(`-H 'Content-Type: application/json'`);
    parts.push(`-d '${escapeShellArg(bodyStr)}'`);
  }
  const fullUrl = `${baseUrl}${config.url}`;
  parts.push(`'${fullUrl}'`);
  return parts.join(" \\\n  ");
}
function escapeShellArg(str) {
  return str.replace(/'/g, "'\\''");
}

// src/util/openapi/openapi-cache.ts
import { join } from "path";
import { readFile as readFile2, writeFile, mkdir } from "fs/promises";

// src/util/openapi/constants.ts
var OPENAPI_URL = "https://openapi.vercel.sh/";
var CACHE_FILE = "openapi-spec.json";
var CACHE_TTL_MS = 24 * 60 * 60 * 1e3;
var FETCH_TIMEOUT_MS = 10 * 1e3;

// src/util/openapi/openapi-cache.ts
var OpenApiCache = class {
  constructor() {
    this.spec = null;
    this.cachePath = join(global_path_default(), CACHE_FILE);
  }
  /**
   * Check if the spec has been loaded
   */
  get isLoaded() {
    return this.spec !== null;
  }
  /**
   * Load the OpenAPI spec, using cache if available and fresh.
   * Returns true if successful, false otherwise.
   */
  async load(forceRefresh = false) {
    if (!forceRefresh) {
      const cached = await this.readCache();
      if (cached && !this.isExpired(cached.fetchedAt)) {
        output_manager_default.debug("Using cached OpenAPI spec");
        this.spec = cached.spec;
        return true;
      }
    }
    try {
      output_manager_default.debug("Fetching OpenAPI spec from " + OPENAPI_URL);
      this.spec = await this.fetchSpec();
      await this.saveCache(this.spec);
      return true;
    } catch (err) {
      output_manager_default.debug(`Failed to fetch OpenAPI spec: ${err}`);
      const stale = await this.readCache();
      if (stale) {
        output_manager_default.debug("Using stale cached OpenAPI spec");
        this.spec = stale.spec;
        return true;
      }
      return false;
    }
  }
  /**
   * Load the OpenAPI spec with spinner UI.
   * Returns true if successful, false otherwise.
   */
  async loadWithSpinner(forceRefresh = false) {
    output_manager_default.spinner(
      forceRefresh ? "Refreshing API endpoints..." : "Loading API endpoints..."
    );
    const success = await this.load(forceRefresh);
    output_manager_default.stopSpinner();
    return success;
  }
  /**
   * Get all available endpoints from the loaded spec, sorted by path then method.
   * Throws if spec hasn't been loaded yet.
   */
  getEndpoints() {
    this.ensureLoaded();
    const endpoints = this.extractEndpoints();
    return this.sortEndpoints(endpoints);
  }
  /**
   * Extract body fields from a requestBody schema.
   * Throws if spec hasn't been loaded yet.
   */
  getBodyFields(endpoint) {
    this.ensureLoaded();
    if (!endpoint.requestBody?.content)
      return [];
    const jsonContent = endpoint.requestBody.content["application/json"];
    if (!jsonContent?.schema)
      return [];
    const schema = this.resolveSchemaRef(jsonContent.schema);
    if (!schema?.properties)
      return [];
    const requiredFields = new Set(schema.required || []);
    const fields = [];
    for (const [name, propSchema] of Object.entries(schema.properties)) {
      const resolvedProp = this.resolveSchemaRef(propSchema);
      let enumValues = resolvedProp?.enum || propSchema.enum;
      if (!enumValues && (resolvedProp?.type === "array" || propSchema.type === "array")) {
        const items = resolvedProp?.items || propSchema.items;
        if (items) {
          const resolvedItems = this.resolveSchemaRef(items);
          enumValues = resolvedItems?.enum || items.enum;
        }
      }
      fields.push({
        name,
        required: requiredFields.has(name),
        description: resolvedProp?.description || propSchema.description,
        type: resolvedProp?.type || propSchema.type,
        enumValues
      });
    }
    fields.sort((a, b) => {
      if (a.required !== b.required) {
        return a.required ? -1 : 1;
      }
      return a.name.localeCompare(b.name);
    });
    return fields;
  }
  // ─────────────────────────────────────────────────────────────────────────────
  // Private methods
  // ─────────────────────────────────────────────────────────────────────────────
  /**
   * Ensure the spec is loaded before accessing it
   */
  ensureLoaded() {
    if (!this.spec) {
      throw new Error(
        "OpenAPI spec not loaded. Call load() or loadWithSpinner() first."
      );
    }
  }
  /**
   * Read cached spec from disk
   */
  async readCache() {
    try {
      const content = await readFile2(this.cachePath, "utf-8");
      return JSON.parse(content);
    } catch {
      return null;
    }
  }
  /**
   * Save spec to disk cache
   */
  async saveCache(spec) {
    const cached = {
      fetchedAt: Date.now(),
      spec
    };
    const dir = join(this.cachePath, "..");
    await mkdir(dir, { recursive: true });
    await writeFile(this.cachePath, JSON.stringify(cached));
    output_manager_default.debug("Saved OpenAPI spec to cache");
  }
  /**
   * Fetch OpenAPI spec from remote with timeout
   */
  async fetchSpec() {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), FETCH_TIMEOUT_MS);
    try {
      const response = await fetch(OPENAPI_URL, { signal: controller.signal });
      if (!response.ok) {
        throw new Error(`Failed to fetch OpenAPI spec: ${response.status}`);
      }
      return await response.json();
    } finally {
      clearTimeout(timeoutId);
    }
  }
  /**
   * Check if cached spec is expired
   */
  isExpired(fetchedAt) {
    return Date.now() - fetchedAt > CACHE_TTL_MS;
  }
  /**
   * Sort endpoints by path, then by method
   */
  sortEndpoints(endpoints) {
    return endpoints.sort((a, b) => {
      const pathCompare = a.path.localeCompare(b.path);
      if (pathCompare !== 0)
        return pathCompare;
      return a.method.localeCompare(b.method);
    });
  }
  /**
   * Extract all available endpoints from the spec
   */
  extractEndpoints() {
    const endpoints = [];
    for (const [path3, pathItem] of Object.entries(this.spec.paths)) {
      const methods = ["get", "post", "put", "patch", "delete"];
      for (const method of methods) {
        const operation = pathItem[method];
        if (operation) {
          const pathParams = pathItem.parameters || [];
          const opParams = operation.parameters || [];
          const allParams = [...pathParams, ...opParams];
          endpoints.push({
            path: path3,
            method: method.toUpperCase(),
            summary: operation.summary || pathItem.summary || "",
            description: operation.description || pathItem.description || "",
            operationId: operation.operationId || "",
            tags: operation.tags || [],
            parameters: allParams,
            requestBody: operation.requestBody
          });
        }
      }
    }
    return endpoints;
  }
  /**
   * Resolve a $ref to its actual schema
   */
  resolveSchemaRef(schema) {
    if (!schema)
      return void 0;
    if (schema.$ref) {
      const match = schema.$ref.match(/^#\/components\/schemas\/(.+)$/);
      if (match && this.spec.components?.schemas) {
        const resolved = this.spec.components.schemas[match[1]];
        return this.resolveSchemaRef(resolved);
      }
      return void 0;
    }
    if (schema.allOf && schema.allOf.length > 0) {
      const merged = { type: "object", properties: {}, required: [] };
      for (const subSchema of schema.allOf) {
        const resolved = this.resolveSchemaRef(subSchema);
        if (resolved) {
          if (resolved.properties) {
            merged.properties = {
              ...merged.properties,
              ...resolved.properties
            };
          }
          if (resolved.required) {
            merged.required = [
              ...merged.required || [],
              ...resolved.required
            ];
          }
        }
      }
      return merged;
    }
    return schema;
  }
};

// src/commands/api/constants.ts
var API_BASE_URL = "https://api.vercel.com";

// src/commands/api/format-utils.ts
var import_chalk7 = __toESM(require_source(), 1);
function colorizeMethod(method) {
  switch (method) {
    case "GET":
      return import_chalk7.default.cyan(method);
    case "POST":
      return import_chalk7.default.green(method);
    case "PUT":
      return import_chalk7.default.yellow(method);
    case "PATCH":
      return import_chalk7.default.blue(method);
    case "DELETE":
      return import_chalk7.default.red(method);
    default:
      return method;
  }
}
function colorizeMethodPadded(method, width = 7) {
  const colored = colorizeMethod(method);
  const padding2 = " ".repeat(Math.max(0, width - method.length));
  return colored + padding2;
}
function formatPathParam(paramName) {
  return import_chalk7.default.cyan(`{${paramName}}`);
}
function formatTypeHint(type) {
  return import_chalk7.default.dim(`[${type}]`);
}
function formatDescription(description) {
  if (!description)
    return "";
  return import_chalk7.default.gray(` (${description})`);
}

// src/commands/api/index.ts
async function api(client) {
  const telemetryClient = new ApiTelemetryClient({
    opts: { store: client.telemetryEventStore }
  });
  let parsedArgs;
  const flagsSpec = getFlagsSpecification(apiCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpec, {
      permissive: true
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags } = parsedArgs;
  const needHelp = flags["--help"];
  const firstArg = args[1];
  if (firstArg === "ls" || firstArg === "list") {
    const lsFlagsSpec = getFlagsSpecification(listSubcommand2.options);
    let lsParsedArgs;
    try {
      lsParsedArgs = parseArguments(client.argv.slice(2), lsFlagsSpec);
    } catch (err) {
      printError(err);
      return 1;
    }
    const lsFlags = lsParsedArgs.flags;
    if (lsFlags["--help"]) {
      telemetryClient.trackCliFlagHelp("api", firstArg);
      output_manager_default.print(
        help(listSubcommand2, {
          parent: apiCommand,
          columns: client.stderr.columns
        })
      );
      return 2;
    }
    telemetryClient.trackCliSubcommandList();
    if (lsFlags["--refresh"])
      telemetryClient.trackCliFlagRefresh(true);
    if (lsFlags["--format"])
      telemetryClient.trackCliOptionFormat(lsFlags["--format"]);
    return listEndpoints(
      client,
      lsFlags["--refresh"] ?? false,
      lsFlags["--format"] ?? "table"
    );
  }
  if (needHelp) {
    telemetryClient.trackCliFlagHelp("api");
    output_manager_default.print(help(apiCommand, { columns: client.stderr.columns }));
    return 2;
  }
  if (flags["--dangerously-skip-permissions"]) {
    client.dangerouslySkipPermissions = true;
  }
  let endpoint = firstArg;
  let selectedMethod;
  let selectedBodyFields = [];
  if (!endpoint) {
    if (client.stdin.isTTY) {
      const selected = await promptEndpointSelection(
        client,
        flags["--refresh"] ?? false
      );
      if (!selected) {
        return 1;
      }
      endpoint = selected.finalUrl;
      selectedMethod = selected.method;
      selectedBodyFields = selected.bodyFields;
    } else {
      output_manager_default.error("Endpoint is required. Usage: vercel api <endpoint>");
      return 1;
    }
  }
  if (!endpoint.startsWith("/")) {
    output_manager_default.error("Endpoint must start with /");
    return 1;
  }
  try {
    const resolvedUrl = new URL(endpoint, API_BASE_URL);
    if (resolvedUrl.origin !== API_BASE_URL) {
      output_manager_default.error(
        "Invalid endpoint: must be a Vercel API path, not an external URL"
      );
      return 1;
    }
  } catch {
    output_manager_default.error("Invalid endpoint URL format");
    return 1;
  }
  telemetryClient.trackCliArgumentEndpoint(endpoint);
  telemetryClient.trackCliOptionMethod(flags["--method"]);
  telemetryClient.trackCliOptionHeader(flags["--header"]);
  telemetryClient.trackCliOptionInput(flags["--input"]);
  if (flags["--paginate"])
    telemetryClient.trackCliFlagPaginate(true);
  if (flags["--include"])
    telemetryClient.trackCliFlagInclude(true);
  if (flags["--silent"])
    telemetryClient.trackCliFlagSilent(true);
  if (flags["--verbose"])
    telemetryClient.trackCliFlagVerbose(true);
  if (flags["--raw"])
    telemetryClient.trackCliFlagRaw(true);
  if (flags["--refresh"])
    telemetryClient.trackCliFlagRefresh(true);
  if (flags["--generate"])
    telemetryClient.trackCliOptionGenerate(flags["--generate"]);
  if (flags["--dangerously-skip-permissions"])
    telemetryClient.trackCliFlagDangerouslySkipPermissions(true);
  const finalFlags = { ...flags };
  if (selectedMethod && !flags["--method"]) {
    finalFlags["--method"] = selectedMethod;
  }
  if (selectedBodyFields.length > 0) {
    const existingFields = finalFlags["--field"] || [];
    finalFlags["--field"] = [...existingFields, ...selectedBodyFields];
  }
  if (flags["--generate"] === "curl") {
    try {
      const requestConfig = await buildRequest(endpoint, finalFlags);
      const curlCmd = generateCurlCommand(
        requestConfig,
        "https://api.vercel.com"
      );
      output_manager_default.log("");
      output_manager_default.log("Replace <TOKEN> with your auth token:");
      output_manager_default.log("");
      client.stdout.write(curlCmd + "\n");
      return 0;
    } catch (err) {
      printError(err);
      return 1;
    }
  }
  return executeApiRequest(client, endpoint, finalFlags);
}
async function executeApiRequest(client, endpoint, flags) {
  let requestConfig;
  try {
    requestConfig = await buildRequest(endpoint, flags);
  } catch (err) {
    printError(err);
    return 1;
  }
  if (flags["--verbose"]) {
    output_manager_default.debug(`Request: ${requestConfig.method} ${requestConfig.url}`);
    if (Object.keys(requestConfig.headers).length > 0) {
      output_manager_default.debug(`Headers: ${JSON.stringify(requestConfig.headers)}`);
    }
    if (requestConfig.body) {
      output_manager_default.debug(
        `Body: ${typeof requestConfig.body === "string" ? requestConfig.body : JSON.stringify(requestConfig.body)}`
      );
    }
  }
  if (flags["--paginate"]) {
    return executePaginatedRequest(client, requestConfig, flags);
  }
  return executeSingleRequest(client, requestConfig, flags);
}
async function executeSingleRequest(client, config, flags) {
  try {
    const confirmed = await client.confirmMutatingOperation(
      config.url,
      config.method
    );
    if (!confirmed) {
      return 1;
    }
    const response = await client.fetch(config.url, {
      method: config.method,
      body: config.body,
      headers: config.headers,
      json: false
      // Get raw response
    });
    return handleResponse(client, response, flags);
  } catch (err) {
    output_manager_default.prettyError(err);
    return 1;
  }
}
async function executePaginatedRequest(client, config, flags) {
  const results = [];
  try {
    const confirmed = await client.confirmMutatingOperation(
      config.url,
      config.method
    );
    if (!confirmed) {
      return 1;
    }
    for await (const page of client.fetchPaginated(
      config.url,
      {
        method: config.method,
        body: config.body,
        headers: config.headers
      }
    )) {
      const data = extractPaginatedData(page);
      results.push(...data);
    }
    return outputResults(client, results, flags);
  } catch (err) {
    output_manager_default.prettyError(err);
    return 1;
  }
}
function extractPaginatedData(page) {
  for (const [key, value] of Object.entries(page)) {
    if (key !== "pagination" && Array.isArray(value)) {
      return value;
    }
  }
  const { pagination, ...rest } = page;
  return [rest];
}
async function handleResponse(client, response, flags) {
  if (flags["--include"]) {
    outputHeaders(client, response);
  }
  if (flags["--silent"]) {
    return response.ok ? 0 : 1;
  }
  const contentType = response.headers.get("content-type") || "";
  if (contentType.includes("application/json")) {
    const json = await response.json();
    if (flags["--verbose"]) {
      output_manager_default.debug(
        `Response status: ${response.status} ${response.statusText}`
      );
    }
    return outputResults(client, json, flags);
  }
  const text = await response.text();
  client.stdout.write(text);
  return response.ok ? 0 : 1;
}
function outputHeaders(client, response) {
  client.stdout.write(`HTTP ${response.status} ${response.statusText}
`);
  response.headers.forEach((value, key) => {
    client.stdout.write(`${key}: ${value}
`);
  });
  client.stdout.write("\n");
}
function outputResults(client, data, flags) {
  const formatted = formatOutput(data, {
    raw: flags["--raw"]
  });
  client.stdout.write(formatted + "\n");
  return 0;
}
async function promptEndpointSelection(client, forceRefresh) {
  try {
    const openApi = new OpenApiCache();
    const success = await openApi.loadWithSpinner(forceRefresh);
    if (!success) {
      output_manager_default.error("Could not load API specification for endpoint selection");
      return null;
    }
    const endpoints = openApi.getEndpoints();
    const selectedEndpoint = await promptForEndpoint(client, endpoints);
    const bodyFieldsSpec = openApi.getBodyFields(selectedEndpoint);
    const { finalUrl, bodyFields } = await promptForParameters(
      client,
      selectedEndpoint.path,
      selectedEndpoint.parameters,
      bodyFieldsSpec
    );
    return {
      path: selectedEndpoint.path,
      method: selectedEndpoint.method,
      finalUrl,
      bodyFields
    };
  } catch (err) {
    output_manager_default.stopSpinner();
    output_manager_default.debug(`Endpoint selection failed: ${err}`);
    return null;
  }
}
async function promptForEndpoint(client, endpoints) {
  const allChoices = endpoints.map((ep) => ({
    name: `${colorizeMethodPadded(ep.method)} ${ep.path}`,
    value: ep,
    // Show full description if available, otherwise show summary
    description: ep.description || ep.summary || void 0,
    // Include summary in searchable metadata
    summary: ep.summary,
    tags: ep.tags
  }));
  const total = allChoices.length;
  return client.input.search({
    message: `Search for an API endpoint (${total} available):`,
    source: async (term) => {
      if (!term) {
        return allChoices;
      }
      const lowerTerm = term.toLowerCase();
      return allChoices.filter((choice) => {
        const searchableText = [
          choice.name,
          choice.summary || "",
          choice.description || "",
          ...choice.tags || []
        ].join(" ").toLowerCase();
        return searchableText.includes(lowerTerm);
      });
    }
  });
}
async function listEndpoints(client, forceRefresh, format4) {
  const openApi = new OpenApiCache();
  const success = await openApi.loadWithSpinner(forceRefresh);
  if (!success) {
    output_manager_default.error("Could not load API specification");
    return 1;
  }
  const endpoints = openApi.getEndpoints();
  if (format4 === "json") {
    return outputEndpointsAsJson(client, endpoints);
  }
  return outputEndpointsAsTable(endpoints);
}
function outputEndpointsAsJson(client, endpoints) {
  const jsonOutput = endpoints.map((ep) => ({
    method: ep.method,
    path: ep.path,
    summary: ep.summary || null,
    description: ep.description || null,
    operationId: ep.operationId || null,
    tags: ep.tags
  }));
  client.stdout.write(JSON.stringify(jsonOutput, null, 2) + "\n");
  return 0;
}
function groupEndpointsByPath(endpoints) {
  const grouped = /* @__PURE__ */ new Map();
  for (const ep of endpoints) {
    const existing = grouped.get(ep.path) || [];
    existing.push({ method: ep.method, summary: ep.summary });
    grouped.set(ep.path, existing);
  }
  const methodOrder = ["GET", "POST", "PUT", "PATCH", "DELETE"];
  for (const [path3, methods] of grouped) {
    methods.sort(
      (a, b) => methodOrder.indexOf(a.method) - methodOrder.indexOf(b.method)
    );
    grouped.set(path3, methods);
  }
  return grouped;
}
function outputEndpointsAsTable(endpoints) {
  const grouped = groupEndpointsByPath(endpoints);
  const methodWidth = 7;
  output_manager_default.log("");
  for (const [path3, methods] of grouped) {
    output_manager_default.log(import_chalk8.default.bold(path3));
    for (const { method, summary } of methods) {
      const coloredMethod = colorizeMethod(method);
      const paddedMethod = method.padEnd(methodWidth);
      const methodDisplay = coloredMethod + paddedMethod.slice(method.length);
      output_manager_default.log(`  ${methodDisplay}  ${import_chalk8.default.gray(summary || "")}`);
    }
    output_manager_default.log("");
  }
  output_manager_default.log(
    `${import_chalk8.default.bold(grouped.size.toString())} routes, ${import_chalk8.default.bold(endpoints.length.toString())} endpoints`
  );
  return 0;
}
function createRequiredValidator(fieldName) {
  return (input) => {
    if (!input.trim()) {
      return `${fieldName} is required`;
    }
    return true;
  };
}
function buildQueryString(params) {
  return Object.entries(params).map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join("&");
}
async function promptForParameters(client, path3, parameters, bodyFieldsSpec) {
  const globalParams = /* @__PURE__ */ new Set(["teamId", "slug"]);
  const pathParams = parameters.filter((p) => p.in === "path");
  const requiredQueryParams = parameters.filter(
    (p) => p.in === "query" && p.required && !globalParams.has(p.name)
  );
  const optionalQueryParams = parameters.filter(
    (p) => p.in === "query" && !p.required && !globalParams.has(p.name)
  );
  const requiredBodyFields = bodyFieldsSpec.filter((f) => f.required);
  const optionalBodyFields = bodyFieldsSpec.filter((f) => !f.required);
  let finalPath = path3;
  for (const param2 of pathParams) {
    const value = await client.input.text({
      message: `Enter value for ${formatPathParam(param2.name)}${formatDescription(param2.description)}:`,
      validate: createRequiredValidator(param2.name)
    });
    finalPath = finalPath.replace(`{${param2.name}}`, encodeURIComponent(value));
  }
  const queryValues = {};
  for (const param2 of requiredQueryParams) {
    queryValues[param2.name] = await client.input.text({
      message: `Enter value for ${import_chalk8.default.cyan(param2.name)}${formatDescription(param2.description)}:`,
      validate: createRequiredValidator(param2.name)
    });
  }
  if (optionalQueryParams.length > 0) {
    const selectedOptionalParams = await client.input.checkbox({
      message: "Select optional query parameters to include:",
      pageSize: 20,
      choices: optionalQueryParams.map((p) => ({
        name: `${import_chalk8.default.cyan(p.name)}${formatDescription(p.description)}`,
        value: p.name
      }))
    });
    for (const paramName of selectedOptionalParams) {
      const param2 = optionalQueryParams.find((p) => p.name === paramName);
      queryValues[param2.name] = await client.input.text({
        message: `Enter value for ${import_chalk8.default.cyan(param2.name)}${formatDescription(param2.description)}:`,
        validate: createRequiredValidator(param2.name)
      });
    }
  }
  const bodyFieldValues = [];
  for (const field of requiredBodyFields) {
    const value = await promptForBodyField(client, field, true);
    bodyFieldValues.push(`${field.name}=${value}`);
  }
  if (optionalBodyFields.length > 0) {
    const selectedOptionalFields = await client.input.checkbox({
      message: "Select optional body fields to include:",
      pageSize: 20,
      choices: optionalBodyFields.map((f) => ({
        name: `${import_chalk8.default.cyan(f.name)}${f.type ? ` ${formatTypeHint(f.type)}` : ""}${formatDescription(f.description)}`,
        value: f.name
      }))
    });
    for (const fieldName of selectedOptionalFields) {
      const field = optionalBodyFields.find((f) => f.name === fieldName);
      const value = await promptForBodyField(client, field, true);
      bodyFieldValues.push(`${field.name}=${value}`);
    }
  }
  const queryString = buildQueryString(queryValues);
  if (queryString) {
    finalPath += `?${queryString}`;
  }
  return { finalUrl: finalPath, bodyFields: bodyFieldValues };
}
async function promptForBodyField(client, field, required) {
  const description = formatDescription(field.description);
  const optionalHint = required ? "" : import_chalk8.default.dim(" (optional)");
  if (field.type === "array" && field.enumValues && field.enumValues.length > 0) {
    const choices = field.enumValues.map((v) => ({
      name: String(v),
      value: String(v)
    }));
    const selected = await client.input.checkbox({
      message: `Select values for ${import_chalk8.default.cyan(field.name)}${optionalHint}${description}:`,
      choices,
      required
    });
    return JSON.stringify(selected);
  }
  if (field.enumValues && field.enumValues.length > 0) {
    const choices = field.enumValues.map((v) => ({
      name: String(v),
      value: String(v)
    }));
    if (!required) {
      choices.unshift({ name: import_chalk8.default.dim("(skip)"), value: "" });
    }
    return client.input.select({
      message: `Select value for ${import_chalk8.default.cyan(field.name)}${optionalHint}${description}:`,
      choices
    });
  }
  const typeHint = field.type ? ` ${formatTypeHint(field.type)}` : "";
  return client.input.text({
    message: `Enter value for ${import_chalk8.default.cyan(field.name)}${optionalHint}${typeHint}${description}:`,
    validate: required ? createRequiredValidator(field.name) : void 0
  });
}

// src/commands/bisect/index.ts
var import_open = __toESM(require_open(), 1);
var import_execa = __toESM(require_execa(), 1);
var import_pluralize = __toESM(require_pluralize(), 1);
var import_chalk10 = __toESM(require_source(), 1);
import { resolve as resolve2 } from "path";
import { URLSearchParams as URLSearchParams2, parse as parse3 } from "url";

// src/util/format-date.ts
var import_ms4 = __toESM(require_ms(), 1);
var import_chalk9 = __toESM(require_source(), 1);
var import_format = __toESM(require_format(), 1);
function formatDate(dateStrOrNumber) {
  if (!dateStrOrNumber) {
    return import_chalk9.default.gray("-");
  }
  const date = new Date(dateStrOrNumber);
  const diff = date.getTime() - Date.now();
  return diff < 0 ? `${(0, import_format.default)(date, "DD MMMM YYYY HH:mm:ss")} ${import_chalk9.default.gray(
    `[${(0, import_ms4.default)(-diff)} ago]`
  )}` : `${(0, import_format.default)(date, "DD MMMM YYYY HH:mm:ss")} ${import_chalk9.default.gray(
    `[in ${(0, import_ms4.default)(diff)}]`
  )}`;
}
function formatDateWithoutTime(dateStrOrNumber) {
  if (!dateStrOrNumber) {
    return import_chalk9.default.gray("-");
  }
  const date = new Date(dateStrOrNumber);
  const diff = date.getTime() - Date.now();
  return diff < 0 ? `${(0, import_format.default)(date, "MMM DD YYYY")} ${import_chalk9.default.gray(`[${(0, import_ms4.default)(-diff)} ago]`)}` : `${(0, import_format.default)(date, "MMM DD YYYY")} ${import_chalk9.default.gray(`[in ${(0, import_ms4.default)(diff)}]`)}`;
}

// src/util/bisect/normalize-url.ts
function hasScheme(url) {
  return url.startsWith("http://") || url.startsWith("https://");
}
function normalizeURL(url) {
  return hasScheme(url) ? url : `https://${url}`;
}

// src/util/telemetry/commands/bisect/index.ts
var BisectTelemetryClient = class extends TelemetryClient {
  trackCliOptionGood(good) {
    if (good) {
      this.trackCliOption({
        option: "good",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionBad(bad) {
    if (bad) {
      this.trackCliOption({
        option: "bad",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionPath(path3) {
    if (path3) {
      this.trackCliOption({
        option: "path",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionRun(run) {
    if (run) {
      this.trackCliOption({
        option: "run",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagOpen(open7) {
    if (open7) {
      this.trackCliFlag("open");
    }
  }
};

// src/commands/bisect/index.ts
async function bisect(client) {
  let parsedArgs = null;
  const flagsSpecification = getFlagsSpecification(bisectCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const telemetry2 = new BisectTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  if (parsedArgs.flags["--help"]) {
    telemetry2.trackCliFlagHelp("bisect");
    output_manager_default.print(help(bisectCommand, { columns: client.stderr.columns }));
    return 2;
  }
  telemetry2.trackCliOptionGood(parsedArgs.flags["--good"]);
  telemetry2.trackCliOptionBad(parsedArgs.flags["--bad"]);
  telemetry2.trackCliOptionPath(parsedArgs.flags["--path"]);
  telemetry2.trackCliOptionRun(parsedArgs.flags["--run"]);
  telemetry2.trackCliFlagOpen(parsedArgs.flags["--open"]);
  const scope = await getScope(client);
  const { contextName } = scope;
  let bad = parsedArgs.flags["--bad"] || await client.input.text({
    message: `Specify a URL where the bug occurs:`,
    validate: (val) => val ? true : "A URL must be provided"
  });
  let good = parsedArgs.flags["--good"] || await client.input.text({
    message: `Specify a URL where the bug does not occur:`,
    validate: (val) => val ? true : "A URL must be provided"
  });
  let subpath = parsedArgs.flags["--path"] || "";
  let run = parsedArgs.flags["--run"] || "";
  const openEnabled = parsedArgs.flags["--open"] || false;
  if (run) {
    run = resolve2(run);
  }
  bad = normalizeURL(bad);
  let parsed = parse3(bad);
  if (!parsed.hostname) {
    output_manager_default.error("Invalid input: no hostname provided");
    return 1;
  }
  bad = parsed.hostname;
  if (typeof parsed.path === "string" && parsed.path !== "/") {
    if (subpath && subpath !== parsed.path) {
      output_manager_default.note(
        `Ignoring subpath ${import_chalk10.default.bold(
          parsed.path
        )} in favor of \`--path\` argument ${import_chalk10.default.bold(subpath)}`
      );
    } else {
      subpath = parsed.path;
    }
  }
  good = normalizeURL(good);
  parsed = parse3(good);
  if (!parsed.hostname) {
    output_manager_default.error("Invalid input: no hostname provided");
    return 1;
  }
  good = parsed.hostname;
  if (typeof parsed.path === "string" && parsed.path !== "/" && subpath && subpath !== parsed.path) {
    output_manager_default.note(
      `Ignoring subpath ${import_chalk10.default.bold(
        parsed.path
      )} which does not match ${import_chalk10.default.bold(subpath)}`
    );
  }
  if (!subpath) {
    subpath = await client.input.text({
      message: `Specify the URL subpath where the bug occurs:`,
      validate: (val) => val ? true : "A subpath must be provided"
    });
  }
  output_manager_default.spinner("Retrieving deployments\u2026");
  const badDeployment = await getDeployment(client, contextName, bad).catch(
    (err) => err
  );
  if (badDeployment) {
    if (badDeployment instanceof Error) {
      badDeployment.message += ` when requesting bad deployment "${normalizeURL(
        bad
      )}"`;
      output_manager_default.prettyError(badDeployment);
      return 1;
    }
    bad = badDeployment.url;
  } else {
    output_manager_default.error(`Failed to retrieve ${import_chalk10.default.bold("bad")} Deployment: ${bad}`);
    return 1;
  }
  const goodDeployment = await getDeployment(client, contextName, good).catch(
    (err) => err
  );
  if (goodDeployment) {
    if (goodDeployment instanceof Error) {
      goodDeployment.message += ` when requesting good deployment "${normalizeURL(
        good
      )}"`;
      output_manager_default.prettyError(goodDeployment);
      return 1;
    }
    good = goodDeployment.url;
  } else {
    output_manager_default.error(
      `Failed to retrieve ${import_chalk10.default.bold("good")} Deployment: ${good}`
    );
    return 1;
  }
  const { projectId } = badDeployment;
  if (projectId !== goodDeployment.projectId) {
    output_manager_default.error(`Good and Bad deployments must be from the same Project`);
    return 1;
  }
  if (badDeployment.url === goodDeployment.url) {
    output_manager_default.error(`Good and Bad deployments must be different`);
    return 1;
  }
  if (badDeployment.createdAt < goodDeployment.createdAt) {
    output_manager_default.error(`Good deployment must be older than the Bad deployment`);
    return 1;
  }
  if (badDeployment.target !== goodDeployment.target) {
    output_manager_default.error(
      `Bad deployment target "${badDeployment.target || "preview"}" does not match good deployment target "${goodDeployment.target || "preview"}"`
    );
    return 1;
  }
  let deployments = [];
  const query = new URLSearchParams2();
  query.set("projectId", projectId);
  if (badDeployment.target) {
    query.set("target", badDeployment.target);
  }
  query.set("state", "READY");
  query.set("until", String(badDeployment.createdAt + 1));
  for await (const chunk of client.fetchPaginated(
    `/v6/deployments?${query}`,
    {
      accountId: badDeployment.ownerId
    }
  )) {
    let newDeployments = chunk.deployments;
    let hasGood = false;
    for (let i = 0; i < newDeployments.length; i++) {
      if (newDeployments[i].url === good) {
        newDeployments = newDeployments.slice(0, i);
        hasGood = true;
        break;
      }
    }
    deployments = deployments.concat(newDeployments);
    if (hasGood)
      break;
  }
  if (!deployments.length) {
    output_manager_default.error(
      "Cannot bisect because this project does not have any deployments"
    );
    return 1;
  }
  let lastBad = deployments.shift();
  while (deployments.length > 0) {
    output_manager_default.print("\n");
    const middleIndex = Math.floor(deployments.length / 2);
    const deployment = deployments[middleIndex];
    const rem = (0, import_pluralize.default)("deployment", deployments.length, true);
    const steps = Math.floor(Math.log2(deployments.length));
    const pSteps = (0, import_pluralize.default)("step", steps, true);
    output_manager_default.log(
      import_chalk10.default.magenta(
        `${import_chalk10.default.bold(
          "Bisecting:"
        )} ${rem} left to test after this (roughly ${pSteps})`
      ),
      import_chalk10.default.magenta
    );
    const testUrl = `https://${deployment.url}${subpath}`;
    output_manager_default.log(`${import_chalk10.default.bold("Deployment URL:")} ${link_default(testUrl)}`);
    output_manager_default.log(`${import_chalk10.default.bold("Date:")} ${formatDate(deployment.createdAt)}`);
    const commit2 = getCommit(deployment);
    if (commit2) {
      const shortSha = commit2.sha.substring(0, 7);
      const firstLine = commit2.message?.split("\n")[0];
      output_manager_default.log(`${import_chalk10.default.bold("Commit:")} [${shortSha}] ${firstLine}`);
    }
    let action;
    if (run) {
      const proc = await (0, import_execa.default)(run, [testUrl], {
        stdio: "inherit",
        reject: false,
        env: {
          ...process.env,
          HOST: deployment.url,
          URL: testUrl
        }
      });
      if (proc instanceof Error && typeof proc.exitCode !== "number") {
        output_manager_default.prettyError(proc);
        return 1;
      }
      const { exitCode: exitCode2 } = proc;
      let color;
      if (exitCode2 === 0) {
        color = import_chalk10.default.green;
        action = "good";
      } else if (exitCode2 === 125) {
        action = "skip";
        color = import_chalk10.default.grey;
      } else {
        action = "bad";
        color = import_chalk10.default.red;
      }
      output_manager_default.log(
        `Run script returned exit code ${import_chalk10.default.bold(String(exitCode2))}: ${color(
          action
        )}`
      );
    } else {
      if (openEnabled) {
        await (0, import_open.default)(testUrl);
      }
      action = await client.input.expand({
        message: "Select an action:",
        choices: [
          { key: "g", name: "Good", value: "good" },
          { key: "b", name: "Bad", value: "bad" },
          { key: "s", name: "Skip", value: "skip" }
        ]
      });
    }
    if (action === "good") {
      deployments = deployments.slice(0, middleIndex);
    } else if (action === "bad") {
      lastBad = deployment;
      deployments = deployments.slice(middleIndex + 1);
    } else if (action === "skip") {
      deployments.splice(middleIndex, 1);
    }
  }
  output_manager_default.print("\n");
  const result = [
    import_chalk10.default.bold(
      `The first bad deployment is: ${link_default(`https://${lastBad.url}`)}`
    ),
    "",
    `   ${import_chalk10.default.bold("Date:")} ${formatDate(lastBad.createdAt)}`
  ];
  const commit = getCommit(lastBad);
  if (commit) {
    const shortSha = commit.sha.substring(0, 7);
    const firstLine = commit.message?.split("\n")[0];
    result.push(` ${import_chalk10.default.bold("Commit:")} [${shortSha}] ${firstLine}`);
  }
  result.push(`${import_chalk10.default.bold("Inspect:")} ${link_default(lastBad.inspectorUrl)}`);
  output_manager_default.print(box(result.join("\n")));
  output_manager_default.print("\n");
  return 0;
}
function getCommit(deployment) {
  const sha = deployment.meta?.githubCommitSha || deployment.meta?.gitlabCommitSha || deployment.meta?.bitbucketCommitSha;
  if (!sha)
    return null;
  const message = deployment.meta?.githubCommitMessage || deployment.meta?.gitlabCommitMessage || deployment.meta?.bitbucketCommitMessage;
  return { sha, message };
}

// src/commands/blob/list.ts
import * as blob from "@vercel/blob";
var import_chalk11 = __toESM(require_source(), 1);
var import_ms5 = __toESM(require_ms(), 1);

// src/util/telemetry/commands/blob/list.ts
var BlobListTelemetryClient = class extends TelemetryClient {
  trackCliOptionLimit(limit) {
    if (limit) {
      this.trackCliOption({
        option: "limit",
        value: String(limit)
      });
    }
  }
  trackCliOptionCursor(cursor) {
    if (cursor) {
      this.trackCliOption({
        option: "cursor",
        value: cursor
      });
    }
  }
  trackCliOptionPrefix(prefix) {
    if (prefix) {
      this.trackCliOption({
        option: "prefix",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionMode(mode) {
    if (mode) {
      this.trackCliOption({
        option: "mode",
        value: mode
      });
    }
  }
};

// src/commands/blob/list.ts
function isMode(mode) {
  return mode === "folded" || mode === "expanded";
}
async function list3(client, argv, rwToken) {
  const telemetryClient = new BlobListTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const flagsSpecification = getFlagsSpecification(listSubcommand12.options);
  let parsedArgs;
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags } = parsedArgs;
  const validationResult = validateLsArgs({
    commandName: "blob list",
    args
  });
  if (validationResult !== 0) {
    return validationResult;
  }
  const {
    "--limit": limit,
    "--cursor": cursor,
    "--prefix": prefix,
    "--mode": modeFlag
  } = flags;
  telemetryClient.trackCliOptionLimit(limit);
  telemetryClient.trackCliOptionCursor(cursor);
  telemetryClient.trackCliOptionPrefix(prefix);
  telemetryClient.trackCliOptionMode(modeFlag);
  const mode = modeFlag ?? "expanded";
  if (!isMode(mode)) {
    output_manager_default.error(
      `Invalid mode: ${mode} has to be either 'folded' or 'expanded'`
    );
    return 1;
  }
  let list9;
  try {
    output_manager_default.debug("Fetching blobs");
    output_manager_default.spinner("Fetching blobs");
    list9 = await blob.list({
      token: rwToken,
      limit: limit ?? 10,
      cursor,
      mode,
      prefix
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  output_manager_default.stopSpinner();
  const headers = ["Uploaded At", "Size", "Pathname", "URL"];
  const urls = [];
  const tablePrint = table(
    [
      headers.map((header) => import_chalk11.default.dim(header)),
      ...list9.blobs.map((blob5) => {
        urls.push(blob5.url);
        const uploadedAt = (0, import_ms5.default)(Date.now() - new Date(blob5.uploadedAt).getTime());
        return [uploadedAt, String(blob5.size), blob5.pathname, blob5.url];
      })
    ],
    { hsep: 5 }
  ).replace(/^/gm, "  ");
  if (list9.blobs.length > 0) {
    output_manager_default.print(`
${tablePrint}

`);
  } else {
    output_manager_default.log("No blobs in this store");
  }
  if (list9.cursor) {
    const nextFlags = getCommandFlags(flags, ["_", "--cursor"]);
    output_manager_default.log(
      `To display the next page run ${getCommandName(
        `blob list${nextFlags} --cursor ${list9.cursor}`
      )}`
    );
  }
  return 0;
}

// src/util/telemetry/commands/blob/index.ts
var BlobTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandList(actual) {
    this.trackCliSubcommand({
      subcommand: "list",
      value: actual
    });
  }
  trackCliSubcommandPut(actual) {
    this.trackCliSubcommand({
      subcommand: "put",
      value: actual
    });
  }
  trackCliSubcommandDel(actual) {
    this.trackCliSubcommand({
      subcommand: "del",
      value: actual
    });
  }
  trackCliSubcommandCopy(actual) {
    this.trackCliSubcommand({
      subcommand: "copy",
      value: actual
    });
  }
  trackCliSubcommandStore(actual) {
    this.trackCliSubcommand({
      subcommand: "store",
      value: actual
    });
  }
  trackCliOptionRwToken() {
    this.trackCliOption({
      option: "--rw-token",
      value: this.redactedValue
    });
  }
};

// src/commands/blob/put.ts
import * as blob2 from "@vercel/blob";
var import_error_utils = __toESM(require_dist(), 1);
import { statSync } from "fs";
import { open as open2 } from "fs/promises";
import { basename } from "path";
var import_chalk12 = __toESM(require_source(), 1);

// src/util/telemetry/commands/blob/put.ts
var BlobPutTelemetryClient = class extends TelemetryClient {
  trackCliArgumentPathToFile(pathToFile) {
    if (pathToFile) {
      this.trackCliArgument({
        arg: "pathToFile",
        value: this.redactedValue
      });
    }
  }
  trackCliInputSourceStdin() {
    this.trackCliArgument({
      arg: "pathToFile",
      value: "__vercel_stdin__"
    });
  }
  trackCliFlagAddRandomSuffix(addRandomSuffix) {
    if (addRandomSuffix) {
      this.trackCliFlag("add-random-suffix");
    }
  }
  trackCliOptionPathname(pathname) {
    if (pathname) {
      this.trackCliOption({
        option: "pathname",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagMultipart(multipart) {
    if (multipart) {
      this.trackCliFlag("multipart");
    }
  }
  trackCliOptionContentType(contentType) {
    if (contentType) {
      this.trackCliOption({
        option: "content-type",
        value: contentType
      });
    }
  }
  trackCliOptionCacheControlMaxAge(cacheControlMaxAge) {
    if (cacheControlMaxAge) {
      this.trackCliOption({
        option: "cache-control-max-age",
        value: String(cacheControlMaxAge)
      });
    }
  }
  trackCliFlagForce(force) {
    if (force) {
      this.trackCliFlag("force");
    }
  }
};

// src/commands/blob/put.ts
async function put2(client, argv, rwToken) {
  const telemetryClient = new BlobPutTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const flagsSpecification = getFlagsSpecification(putSubcommand.options);
  let parsedArgs;
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const {
    flags,
    args: [filePath]
  } = parsedArgs;
  const {
    "--add-random-suffix": addRandomSuffix,
    "--pathname": pathnameFlag,
    "--multipart": multipart,
    "--content-type": contentType,
    "--cache-control-max-age": cacheControlMaxAge,
    "--force": force
  } = flags;
  if (filePath) {
    telemetryClient.trackCliArgumentPathToFile(filePath);
  }
  telemetryClient.trackCliFlagAddRandomSuffix(addRandomSuffix);
  telemetryClient.trackCliOptionPathname(pathnameFlag);
  telemetryClient.trackCliFlagMultipart(multipart);
  telemetryClient.trackCliOptionContentType(contentType);
  telemetryClient.trackCliOptionCacheControlMaxAge(cacheControlMaxAge);
  telemetryClient.trackCliFlagForce(force);
  let putBody;
  let pathname;
  if (!filePath) {
    if (client.stdin.isTTY) {
      output_manager_default.error(
        `Missing input. Usage: ${import_chalk12.default.cyan(
          `${getCommandName("blob put <file>")}`
        )} or pipe data: ${import_chalk12.default.cyan("cat file.txt | vercel blob put --pathname <pathname>")}`
      );
      return 1;
    }
    if (!pathnameFlag) {
      output_manager_default.error(
        `Missing pathname. When reading from stdin, you must specify --pathname. Usage: ${import_chalk12.default.cyan(
          "cat file.txt | vercel blob put --pathname <pathname>"
        )}`
      );
      return 1;
    }
    putBody = process.stdin;
    pathname = pathnameFlag;
    telemetryClient.trackCliInputSourceStdin();
  } else {
    try {
      const stats = statSync(filePath);
      const isFile = stats.isFile();
      if (isFile) {
        const file = await open2(filePath, "r");
        putBody = file.createReadStream();
        pathname = pathnameFlag ?? basename(filePath);
      } else {
        output_manager_default.error("Path to upload is not a file");
        return 1;
      }
    } catch (err) {
      output_manager_default.debug(`Error reading file: ${err}`);
      if ((0, import_error_utils.isErrnoException)(err)) {
        output_manager_default.error(`File doesn't exist at '${filePath}'`);
        return 1;
      }
      output_manager_default.error("Error while reading file");
      return 1;
    }
  }
  if (!pathname || !putBody) {
    output_manager_default.error(
      `Missing pathname or input. Usage: ${import_chalk12.default.cyan(
        `${getCommandName("blob put <file>")}`
      )} or ${import_chalk12.default.cyan(
        `cat file.txt | ${getCommandName("blob put --pathname <pathname>")}`
      )}`
    );
    return 1;
  }
  let result;
  try {
    output_manager_default.debug("Uploading blob");
    output_manager_default.spinner("Uploading blob");
    result = await blob2.put(pathname, putBody, {
      token: rwToken,
      access: "public",
      addRandomSuffix: addRandomSuffix ?? false,
      multipart: multipart ?? true,
      contentType,
      cacheControlMaxAge,
      allowOverwrite: force ?? false
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  output_manager_default.stopSpinner();
  output_manager_default.success(result.url);
  return 0;
}

// src/commands/blob/del.ts
import * as blob3 from "@vercel/blob";

// src/util/telemetry/commands/blob/del.ts
var BlobDelTelemetryClient = class extends TelemetryClient {
  trackCliArgumentUrlsOrPathnames(urlsOrPathnames) {
    if (urlsOrPathnames) {
      this.trackCliArgument({
        arg: "urlsOrPathnames",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/blob/del.ts
async function del2(client, argv, rwToken) {
  const telemetryClient = new BlobDelTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const flagsSpecification = getFlagsSpecification(delSubcommand.options);
  let parsedArgs;
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  if (!parsedArgs.args.length) {
    printError(
      `Missing required arguments: ${getCommandName("blob del urlOrPathname")}`
    );
    return 1;
  }
  const { args } = parsedArgs;
  telemetryClient.trackCliArgumentUrlsOrPathnames(args[0]);
  try {
    output_manager_default.debug("Deleting blob");
    output_manager_default.spinner("Deleting blob");
    await blob3.del(args, { token: rwToken });
  } catch (err) {
    output_manager_default.error(`Error deleting blob: ${err}`);
    return 1;
  }
  output_manager_default.stopSpinner();
  output_manager_default.success("Blob deleted");
  return 0;
}

// src/commands/blob/copy.ts
import * as blob4 from "@vercel/blob";

// src/util/telemetry/commands/blob/copy.ts
var BlobCopyTelemetryClient = class extends TelemetryClient {
  trackCliArgumentFromUrlOrPathname(value) {
    if (value) {
      this.trackCliArgument({
        arg: "fromUrlOrPathname",
        value: this.redactedValue
      });
    }
  }
  trackCliArgumentToPathname(value) {
    if (value) {
      this.trackCliArgument({
        arg: "toPathname",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagAddRandomSuffix(value) {
    if (value) {
      this.trackCliFlag("add-random-suffix");
    }
  }
  trackCliOptionContentType(value) {
    if (value) {
      this.trackCliOption({
        option: "content-type",
        value
      });
    }
  }
  trackCliOptionCacheControlMaxAge(value) {
    if (value) {
      this.trackCliOption({
        option: "cache-control-max-age",
        value: String(value)
      });
    }
  }
};

// src/commands/blob/copy.ts
async function copy2(client, argv, rwToken) {
  const telemetryClient = new BlobCopyTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const flagsSpecification = getFlagsSpecification(copySubcommand.options);
  let parsedArgs;
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  if (!parsedArgs.args || parsedArgs.args.length < 2) {
    printError(
      `Missing required arguments: ${getCommandName(
        "blob copy fromUrlOrPathname toPathname"
      )}`
    );
    return 1;
  }
  const {
    args: [fromUrl, toPathname],
    flags: {
      "--add-random-suffix": addRandomSuffix,
      "--content-type": contentType,
      "--cache-control-max-age": cacheControlMaxAge
    }
  } = parsedArgs;
  telemetryClient.trackCliArgumentFromUrlOrPathname(fromUrl);
  telemetryClient.trackCliArgumentToPathname(toPathname);
  telemetryClient.trackCliFlagAddRandomSuffix(addRandomSuffix);
  telemetryClient.trackCliOptionContentType(contentType);
  telemetryClient.trackCliOptionCacheControlMaxAge(cacheControlMaxAge);
  let result;
  try {
    output_manager_default.debug("Copying blob");
    output_manager_default.spinner("Copying blob");
    result = await blob4.copy(fromUrl, toPathname, {
      token: rwToken,
      access: "public",
      addRandomSuffix: addRandomSuffix ?? false,
      contentType,
      cacheControlMaxAge
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  output_manager_default.stopSpinner();
  output_manager_default.success(result.url);
  return 0;
}

// src/util/integration-resource/connect-resource-to-project.ts
async function connectResourceToProject(client, projectId, storeId, environments, accountId) {
  return client.fetch(`/v1/storage/stores/${storeId}/connections`, {
    json: true,
    method: "POST",
    body: {
      envVarEnvironments: environments,
      projectId,
      type: "integration"
    },
    accountId
  });
}

// src/commands/blob/store-add.ts
var import_chalk13 = __toESM(require_source(), 1);

// src/util/telemetry/commands/blob/store-add.ts
var BlobAddStoreTelemetryClient = class extends TelemetryClient {
  trackCliArgumentName(value) {
    if (value) {
      this.trackCliArgument({
        arg: "name",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionRegion(value) {
    if (value) {
      this.trackCliOption({
        option: "region",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/blob/store-add.ts
async function addStore(client, argv) {
  const telemetryClient = new BlobAddStoreTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const flagsSpecification = getFlagsSpecification(addStoreSubcommand.options);
  let parsedArgs;
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const {
    args: [nameArg],
    flags
  } = parsedArgs;
  const region = flags["--region"] || "iad1";
  let name = nameArg;
  if (!name) {
    name = await client.input.text({
      message: "Enter a name for your blob store",
      validate: (value) => {
        if (value.length < 5) {
          return "Name must be at least 5 characters long";
        }
        return true;
      }
    });
  }
  telemetryClient.trackCliArgumentName(name);
  telemetryClient.trackCliOptionRegion(flags["--region"]);
  const link = await getLinkedProject(client);
  let storeId;
  let storeRegion;
  try {
    output_manager_default.debug("Creating new blob store");
    output_manager_default.spinner("Creating new blob store");
    const requestBody = {
      name,
      region
    };
    const res = await client.fetch(
      "/v1/storage/stores/blob",
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(requestBody),
        accountId: link.status === "linked" ? link.org.id : void 0
      }
    );
    storeId = res.store.id;
    storeRegion = res.store.region;
  } catch (err) {
    printError(err);
    return 1;
  }
  output_manager_default.stopSpinner();
  const regionInfo = storeRegion ? ` in ${storeRegion}` : "";
  output_manager_default.success(`Blob store created: ${name} (${storeId})${regionInfo}`);
  if (link.status === "linked") {
    const res = await client.input.confirm(
      `Would you like to link this blob store to ${link.project.name}?`,
      true
    );
    if (res) {
      const environments = await client.input.checkbox({
        message: "Select environments",
        choices: [
          { name: "Production", value: "production", checked: true },
          { name: "Preview", value: "preview", checked: true },
          { name: "Development", value: "development", checked: true }
        ]
      });
      output_manager_default.spinner(
        `Connecting ${import_chalk13.default.bold(name)} to ${import_chalk13.default.bold(link.project.name)}...`
      );
      await connectResourceToProject(
        client,
        link.project.id,
        storeId,
        environments,
        link.org.id
      );
      output_manager_default.success(
        `Blob store ${import_chalk13.default.bold(name)} linked to ${import_chalk13.default.bold(
          link.project.name
        )}. Make sure to pull the new environment variables using ${getCommandName("env pull")}`
      );
    }
  }
  return 0;
}

// src/commands/blob/store-remove.ts
async function removeStore(client, argv, rwToken) {
  const flagsSpecification = getFlagsSpecification(
    removeStoreSubcommand.options
  );
  let parsedArgs;
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  let {
    args: [storeId]
  } = parsedArgs;
  if (!storeId && rwToken.success) {
    const [, , , id] = rwToken.token.split("_");
    storeId = `store_${id}`;
  }
  if (!storeId) {
    storeId = await client.input.text({
      message: "Enter the ID of the blob store you want to remove",
      validate: (value) => {
        if (value.length !== 22) {
          return "ID must be 22 characters long";
        }
        return true;
      }
    });
  }
  try {
    const link = await getLinkedProject(client);
    const store2 = await client.fetch(
      `/v1/storage/stores/${storeId}`,
      {
        method: "GET",
        accountId: link.status === "linked" ? link.org.id : void 0
      }
    );
    const res = await client.input.confirm(
      `Are you sure you want to remove ${store2.store.name} (${store2.store.id})? This action cannot be undone.`,
      false
    );
    if (!res) {
      output_manager_default.success("Blob store not removed");
      return 0;
    }
    output_manager_default.debug("Deleting blob store");
    output_manager_default.spinner("Deleting blob store");
    await client.fetch(
      `/v1/storage/stores/blob/${storeId}`,
      {
        method: "DELETE",
        accountId: link.status === "linked" ? link.org.id : void 0
      }
    );
  } catch (err) {
    printError(err);
    return 1;
  }
  output_manager_default.stopSpinner();
  output_manager_default.success("Blob store deleted");
  return 0;
}

// src/util/telemetry/commands/blob/store.ts
var BlobStoreTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandAdd(actual) {
    this.trackCliSubcommand({
      subcommand: "add",
      value: actual
    });
  }
  trackCliSubcommandRemove(actual) {
    this.trackCliSubcommand({
      subcommand: "remove",
      value: actual
    });
  }
  trackCliSubcommandGet(actual) {
    this.trackCliSubcommand({
      subcommand: "get",
      value: actual
    });
  }
};

// src/commands/blob/store-get.ts
var import_bytes = __toESM(require_bytes(), 1);
var import_date_fns = __toESM(require_date_fns(), 1);
var import_chalk14 = __toESM(require_source(), 1);

// src/util/telemetry/commands/blob/store-get.ts
var BlobGetStoreTelemetryClient = class extends TelemetryClient {
  trackCliArgumentStoreId(value) {
    if (value) {
      this.trackCliArgument({
        arg: "storeId",
        value
      });
    }
  }
};

// src/commands/blob/store-get.ts
async function getStore(client, argv, rwToken) {
  const telemetryClient = new BlobGetStoreTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const flagsSpecification = getFlagsSpecification(getStoreSubcommand.options);
  let parsedArgs;
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const {
    args: [storeIdArg]
  } = parsedArgs;
  let storeId = storeIdArg;
  if (!storeId && rwToken.success) {
    const [, , , id] = rwToken.token.split("_");
    storeId = `store_${id}`;
  }
  if (!storeId) {
    storeId = await client.input.text({
      message: "Enter the ID of the blob store you want to remove",
      validate: (value) => {
        if (value.length !== 22) {
          return "ID must be 22 characters long";
        }
        return true;
      }
    });
  }
  telemetryClient.trackCliArgumentStoreId(storeId);
  try {
    const link = await getLinkedProject(client);
    output_manager_default.debug("Getting blob store");
    output_manager_default.spinner("Getting blob store");
    const store2 = await client.fetch(`/v1/storage/stores/${storeId}`, {
      method: "GET",
      accountId: link.status === "linked" ? link.org.id : void 0
    });
    const dateTimeFormat = "MM/DD/YYYY HH:mm:ss.SS";
    const regionInfo = store2.store.region ? `
Region: ${store2.store.region}` : "";
    output_manager_default.print(
      `Blob Store: ${import_chalk14.default.bold(store2.store.name)} (${import_chalk14.default.dim(store2.store.id)})
Billing State: ${store2.store.billingState === "active" ? import_chalk14.default.green("Active") : import_chalk14.default.red("Inactive")}
Size: ${(0, import_bytes.default)(store2.store.size)}${regionInfo}
Created At: ${(0, import_date_fns.format)(new Date(store2.store.createdAt), dateTimeFormat)}
Updated At: ${(0, import_date_fns.format)(new Date(store2.store.updatedAt), dateTimeFormat)}
`
    );
  } catch (err) {
    printError(err);
    return 1;
  }
  output_manager_default.stopSpinner();
  return 0;
}

// src/commands/blob/store.ts
var COMMAND_CONFIG2 = {
  add: getCommandAliases(addStoreSubcommand),
  remove: getCommandAliases(removeStoreSubcommand),
  get: getCommandAliases(getStoreSubcommand)
};
async function store(client, rwToken) {
  const telemetry2 = new BlobStoreTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const flagsSpecification = getFlagsSpecification(storeSubcommand.options);
  let parsedArgs;
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification, {
      permissive: true
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  const subArgs = parsedArgs.args.slice(2);
  const { subcommand, args, subcommandOriginal } = getSubcommand2(
    subArgs,
    COMMAND_CONFIG2
  );
  const needHelp = parsedArgs.flags["--help"];
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp("blob store", subcommand);
    output_manager_default.print(help(storeSubcommand, { columns: client.stderr.columns }));
    return 2;
  }
  function printHelp(command) {
    output_manager_default.print(
      help(command, { parent: storeSubcommand, columns: client.stderr.columns })
    );
  }
  switch (subcommand) {
    case "add":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("blob store", subcommandOriginal);
        printHelp(addStoreSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandAdd(subcommandOriginal);
      return addStore(client, args);
    case "remove":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("blob store", subcommandOriginal);
        printHelp(removeStoreSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandRemove(subcommandOriginal);
      return removeStore(client, args, rwToken);
    case "get":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("blob store", subcommandOriginal);
        printHelp(getStoreSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandGet(subcommandOriginal);
      return getStore(client, args, rwToken);
    default:
      output_manager_default.error(getInvalidSubcommand(COMMAND_CONFIG2));
      output_manager_default.print(help(storeSubcommand, { columns: client.stderr.columns }));
      return 2;
  }
}

// src/util/blob/token.ts
import { resolve as resolve3 } from "path";

// src/util/output/list-item.ts
var import_chalk15 = __toESM(require_source(), 1);
var listItem = (msg, n) => {
  if (!n) {
    n = "-";
  }
  if (Number(n)) {
    n += ".";
  }
  return `${(0, import_chalk15.default)(n.toString())} ${msg}`;
};
var list_item_default = listItem;

// src/util/blob/token.ts
var ErrorMessage = `No Vercel Blob token found. To fix this issue, choose one of the following options:
${list_item_default(`Pass the token directly as an option: ${getCommandName("blob list --rw-token BLOB_TOKEN")}`, 1)}
${list_item_default(`Set the Token as an environment variable: ${cmd(`BLOB_READ_WRITE_TOKEN=BLOB_TOKEN ${packageName} blob list`)}`, 2)}
${list_item_default("Link your current folder to a Vercel Project that has a Vercel Blob store connected", 3)}`;
async function getBlobRWToken(client, argv) {
  const flagsSpecification = getFlagsSpecification(blobCommand.options);
  try {
    const parsedArgs = parseArguments(argv, flagsSpecification);
    const {
      flags: { "--rw-token": rwToken }
    } = parsedArgs;
    if (rwToken) {
      return { token: rwToken, success: true };
    }
  } catch (err) {
  }
  if (process.env.BLOB_READ_WRITE_TOKEN) {
    return { token: process.env.BLOB_READ_WRITE_TOKEN, success: true };
  }
  const filename = ".env.local";
  const fullPath = resolve3(client.cwd, filename);
  try {
    const env = await createEnvObject(fullPath);
    if (env?.BLOB_READ_WRITE_TOKEN) {
      return { token: env.BLOB_READ_WRITE_TOKEN, success: true };
    }
  } catch (error) {
  }
  return {
    error: ErrorMessage,
    success: false
  };
}

// src/commands/blob/index.ts
var COMMAND_CONFIG3 = {
  list: getCommandAliases(listSubcommand12),
  put: getCommandAliases(putSubcommand),
  del: getCommandAliases(delSubcommand),
  copy: getCommandAliases(copySubcommand),
  store: getCommandAliases(storeSubcommand)
};
async function main2(client) {
  const telemetry2 = new BlobTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const flagsSpecification = getFlagsSpecification(blobCommand.options);
  let parsedArgs;
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification, {
      permissive: true
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  const subArgs = parsedArgs.args.slice(1);
  const { subcommand, args, subcommandOriginal } = getSubcommand2(
    subArgs,
    COMMAND_CONFIG3
  );
  const needHelp = parsedArgs.flags["--help"];
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp("blob", subcommand);
    output_manager_default.print(help(blobCommand, { columns: client.stderr.columns }));
    return 2;
  }
  function printHelp(command) {
    output_manager_default.print(
      help(command, { parent: blobCommand, columns: client.stderr.columns })
    );
  }
  const token = await getBlobRWToken(client, client.argv);
  telemetry2.trackCliOptionRwToken();
  switch (subcommand) {
    case "list":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("blob", subcommandOriginal);
        printHelp(listSubcommand12);
        return 2;
      }
      telemetry2.trackCliSubcommandList(subcommandOriginal);
      if (!token.success) {
        printError(token.error);
        return 1;
      }
      return list3(client, args, token.token);
    case "put":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("blob", subcommandOriginal);
        printHelp(putSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandPut(subcommandOriginal);
      if (!token.success) {
        printError(token.error);
        return 1;
      }
      return put2(client, args, token.token);
    case "del":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("blob", subcommandOriginal);
        printHelp(delSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandDel(subcommandOriginal);
      if (!token.success) {
        printError(token.error);
        return 1;
      }
      return del2(client, args, token.token);
    case "copy":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("blob", subcommandOriginal);
        printHelp(copySubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandCopy(subcommandOriginal);
      if (!token.success) {
        printError(token.error);
        return 1;
      }
      return copy2(client, args, token.token);
    case "store":
      telemetry2.trackCliSubcommandStore(subcommandOriginal);
      return store(client, token);
    default:
      output_manager_default.error(getInvalidSubcommand(COMMAND_CONFIG3));
      output_manager_default.print(help(blobCommand, { columns: client.stderr.columns }));
      return 2;
  }
}

// src/util/telemetry/commands/cache/purge.ts
var CachePurgeTelemetryClient = class extends TelemetryClient {
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
  trackCliOptionType(type) {
    if (type) {
      this.trackCliOption({
        option: "type",
        value: type
      });
    }
  }
};

// src/commands/cache/purge.ts
async function purge(client, argv) {
  const telemetry2 = new CachePurgeTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(purgeSubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const link = await getLinkedProject(client);
  if (link.status === "not_linked") {
    output_manager_default.error(
      "No project linked. Run `vercel link` to link a project to this directory."
    );
    return 1;
  }
  if (link.status === "error") {
    return link.exitCode;
  }
  const { project, org } = link;
  client.config.currentTeam = org.type === "team" ? org.id : void 0;
  const yes = Boolean(parsedArgs.flags["--yes"]);
  telemetry2.trackCliFlagYes(yes);
  const type = parsedArgs.flags["--type"] || "all";
  telemetry2.trackCliOptionType(parsedArgs.flags["--type"]);
  const cacheTypeMap = {
    cdn: "the CDN cache",
    data: "the Data cache",
    all: "the CDN cache and Data cache"
  };
  const validTypes = Object.keys(cacheTypeMap);
  if (!validTypes.includes(type)) {
    output_manager_default.error(
      `Invalid cache type "${type}". Valid types are: ${validTypes.join(", ")}`
    );
    return 1;
  }
  const typeDesciption = cacheTypeMap[type];
  const msg = `You are about to purge ${typeDesciption} for project ${project.name}`;
  const query = new URLSearchParams({ projectIdOrName: project.id }).toString();
  if (!yes) {
    if (!process.stdin.isTTY) {
      output_manager_default.print(
        `${msg}. To continue, run ${getCommandName("cache purge --yes")}.`
      );
      return 1;
    }
    const confirmed = await client.input.confirm(`${msg}. Continue?`, true);
    if (!confirmed) {
      output_manager_default.print(`Canceled.
`);
      return 0;
    }
  }
  const requests = [];
  if (type === "cdn" || type === "all") {
    requests.push(
      client.fetch(`/v1/edge-cache/purge-all?${query}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        }
      })
    );
  }
  if (type === "data" || type === "all") {
    requests.push(
      client.fetch(`/v1/data-cache/purge-all?${query}`, {
        method: "DELETE",
        headers: {
          "Content-Type": "application/json"
        }
      })
    );
  }
  await Promise.all(requests);
  output_manager_default.print(
    prependEmoji(`Successfully purged ${typeDesciption}`, emoji("success")) + `
`
  );
  return 0;
}

// src/util/telemetry/commands/cache/invalidate.ts
var CacheInvalidateTelemetryClient = class extends TelemetryClient {
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
  trackCliOptionTag(tag) {
    if (tag) {
      this.trackCliOption({
        option: "tag",
        value: tag
      });
    }
  }
  trackCliOptionSrcimg(srcimg) {
    if (srcimg) {
      this.trackCliOption({
        option: "srcimg",
        value: srcimg
      });
    }
  }
};

// src/commands/cache/invalidate.ts
var import_pluralize2 = __toESM(require_pluralize(), 1);
async function invalidate(client, argv) {
  const telemetry2 = new CacheInvalidateTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(
    invalidateSubcommand.options
  );
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const link = await getLinkedProject(client);
  if (link.status === "not_linked") {
    output_manager_default.error(
      "No project linked. Run `vercel link` to link a project to this directory."
    );
    return 1;
  }
  if (link.status === "error") {
    return link.exitCode;
  }
  const { project, org } = link;
  client.config.currentTeam = org.type === "team" ? org.id : void 0;
  const yes = Boolean(parsedArgs.flags["--yes"]);
  const tag = parsedArgs.flags["--tag"];
  const srcimg = parsedArgs.flags["--srcimg"];
  telemetry2.trackCliFlagYes(yes);
  telemetry2.trackCliOptionTag(tag);
  telemetry2.trackCliOptionSrcimg(srcimg);
  if (tag && srcimg) {
    output_manager_default.error(`Cannot use both --tag and --srcimg options`);
    return 1;
  }
  let itemName = "";
  let itemValue = "";
  let flag = "";
  let postUrl = "";
  let postBody = {};
  if (tag) {
    itemName = (0, import_pluralize2.default)("tag", tag.split(",").length, false);
    itemValue = tag;
    flag = "--tag";
    postUrl = "/v1/edge-cache/invalidate-by-tags";
    postBody = { tags: tag };
  } else if (srcimg) {
    itemName = "source image";
    itemValue = srcimg;
    flag = "--srcimg";
    postUrl = "/v1/edge-cache/invalidate-by-src-images";
    postBody = { srcImages: [srcimg] };
  } else {
    output_manager_default.error(`The --tag or --srcimg option is required`);
    return 1;
  }
  const msg = `You are about to invalidate all cached content associated with ${itemName} ${itemValue} for project ${project.name}`;
  if (!yes) {
    if (!process.stdin.isTTY) {
      output_manager_default.print(
        `${msg}. To continue, run ${getCommandName(`cache invalidate ${flag} ${itemValue} --yes`)}.`
      );
      return 1;
    }
    const confirmed = await client.input.confirm(`${msg}. Continue?`, true);
    if (!confirmed) {
      output_manager_default.print(`Canceled.
`);
      return 0;
    }
  }
  await client.fetch(`${postUrl}?projectIdOrName=${project.id}`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(postBody)
  });
  output_manager_default.print(
    prependEmoji(
      `Successfully invalidated all cached content associated with ${itemName} ${itemValue}`,
      emoji("success")
    ) + `
`
  );
  return 0;
}

// src/util/telemetry/commands/cache/dangerously-delete.ts
var CacheDangerouslyDeleteTelemetryClient = class extends TelemetryClient {
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
  trackCliOptionTag(tag) {
    if (tag) {
      this.trackCliOption({
        option: "tag",
        value: tag
      });
    }
  }
  trackCliOptionSrcimg(srcimg) {
    if (srcimg) {
      this.trackCliOption({
        option: "srcimg",
        value: srcimg
      });
    }
  }
  trackCliOptionRevalidationDeadlineSeconds(seconds) {
    if (seconds) {
      this.trackCliOption({
        option: "revalidation-deadline-seconds",
        value: seconds?.toString()
      });
    }
  }
};

// src/commands/cache/dangerously-delete.ts
var import_pluralize3 = __toESM(require_pluralize(), 1);
async function dangerouslyDelete(client, argv) {
  const telemetry2 = new CacheDangerouslyDeleteTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(
    dangerouslyDeleteSubcommand.options
  );
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const link = await getLinkedProject(client);
  if (link.status === "not_linked") {
    output_manager_default.error(
      "No project linked. Run `vercel link` to link a project to this directory."
    );
    return 1;
  }
  if (link.status === "error") {
    return link.exitCode;
  }
  const { project, org } = link;
  client.config.currentTeam = org.type === "team" ? org.id : void 0;
  const yes = Boolean(parsedArgs.flags["--yes"]);
  const tag = parsedArgs.flags["--tag"];
  const srcimg = parsedArgs.flags["--srcimg"];
  const revalidate = parsedArgs.flags["--revalidation-deadline-seconds"];
  telemetry2.trackCliFlagYes(yes);
  telemetry2.trackCliOptionTag(tag);
  telemetry2.trackCliOptionSrcimg(srcimg);
  telemetry2.trackCliOptionRevalidationDeadlineSeconds(revalidate);
  if (tag && srcimg) {
    output_manager_default.error(`Cannot use both --tag and --srcimg options`);
    return 1;
  }
  let itemName = "";
  let itemValue = "";
  let flag = "";
  let postUrl = "";
  let postBody = {};
  if (tag) {
    itemName = (0, import_pluralize3.default)("tag", tag.split(",").length, false);
    itemValue = tag;
    flag = "--tag";
    postUrl = "/v1/edge-cache/dangerously-delete-by-tags";
    postBody = { tags: tag, revalidationDeadlineSeconds: revalidate };
  } else if (srcimg) {
    itemName = "source image";
    itemValue = srcimg;
    flag = "--srcimg";
    postUrl = "/v1/edge-cache/dangerously-delete-by-src-images";
    postBody = { srcImages: [srcimg], revalidationDeadlineSeconds: revalidate };
  } else {
    output_manager_default.error(`The --tag or --srcimg option is required`);
    return 1;
  }
  const msg = `You are about to dangerously delete all cached content associated with ${itemName} ${itemValue} for project ${project.name}`;
  if (!yes) {
    if (!process.stdin.isTTY) {
      const optional = typeof revalidate !== "undefined" ? ` --revalidation-deadline-seconds ${revalidate}` : "";
      output_manager_default.print(
        `${msg}. To continue, run ${getCommandName(`cache dangerously-delete ${flag} ${itemValue}${optional} --yes`)}.`
      );
      return 1;
    }
    const confirmed = await client.input.confirm(`${msg}. Continue?`, true);
    if (!confirmed) {
      output_manager_default.print(`Canceled.
`);
      return 0;
    }
  }
  await client.fetch(`${postUrl}?projectIdOrName=${project.id}`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(postBody)
  });
  output_manager_default.print(
    prependEmoji(
      `Successfully deleted all cached content associated with ${itemName} ${itemValue}`,
      emoji("success")
    ) + `
`
  );
  return 0;
}

// src/util/telemetry/commands/cache/index.ts
var CacheTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandPurge(actual) {
    this.trackCliSubcommand({
      subcommand: "purge",
      value: actual
    });
  }
  trackCliSubcommandInvalidate(actual) {
    this.trackCliSubcommand({
      subcommand: "invalidate",
      value: actual
    });
  }
  trackCliSubcommandDangerouslyDelete(actual) {
    this.trackCliSubcommand({
      subcommand: "dangerously-delete",
      value: actual
    });
  }
};

// src/commands/cache/index.ts
var COMMAND_CONFIG4 = {
  purge: getCommandAliases(purgeSubcommand),
  invalidate: getCommandAliases(invalidateSubcommand),
  "dangerously-delete": getCommandAliases(dangerouslyDeleteSubcommand)
};
async function main3(client) {
  const telemetry2 = new CacheTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(cacheCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification, {
      permissive: true
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  const subArgs = parsedArgs.args.slice(1);
  const { subcommand, args, subcommandOriginal } = getSubcommand2(
    subArgs,
    COMMAND_CONFIG4
  );
  const needHelp = parsedArgs.flags["--help"];
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp(cacheCommand.name);
    output_manager_default.print(help(cacheCommand, { columns: client.stderr.columns }));
    return 0;
  }
  function printHelp(command) {
    telemetry2.trackCliFlagHelp(command.name, subcommandOriginal);
    output_manager_default.print(
      help(command, { parent: cacheCommand, columns: client.stderr.columns })
    );
  }
  switch (subcommand) {
    case "purge":
      if (needHelp) {
        printHelp(purgeSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandPurge(subcommandOriginal);
      return purge(client, args);
    case "invalidate":
      if (needHelp) {
        printHelp(invalidateSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandInvalidate(subcommandOriginal);
      return invalidate(client, args);
    case "dangerously-delete":
      if (needHelp) {
        printHelp(dangerouslyDeleteSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandDangerouslyDelete(subcommandOriginal);
      return dangerouslyDelete(client, args);
    default:
      output_manager_default.error(getInvalidSubcommand(COMMAND_CONFIG4));
      output_manager_default.print(help(cacheCommand, { columns: client.stderr.columns }));
      return 2;
  }
}

// src/commands/certs/add.ts
var import_chalk16 = __toESM(require_source(), 1);

// src/util/certs/create-cert-from-file.ts
var import_error_utils2 = __toESM(require_dist(), 1);
import { readFileSync } from "fs";
import { resolve as resolve4 } from "path";
async function createCertFromFile(client, keyPath, certPath, caPath) {
  output_manager_default.spinner("Adding your custom certificate");
  try {
    const cert = readFileSync(resolve4(certPath), "utf8");
    const key = readFileSync(resolve4(keyPath), "utf8");
    const ca = readFileSync(resolve4(caPath), "utf8");
    const certificate = await client.fetch("/v3/certs", {
      method: "PUT",
      body: {
        ca,
        cert,
        key
      }
    });
    return certificate;
  } catch (err) {
    if ((0, import_error_utils2.isErrnoException)(err) && err.code === "ENOENT") {
      return new Error(`The specified file "${err.path}" doesn't exist.`);
    }
    if (isAPIError(err) && err.status < 500) {
      return err;
    }
    throw err;
  }
}

// src/util/telemetry/commands/certs/add.ts
var CertsAddTelemetryClient = class extends TelemetryClient {
  trackCliFlagOverwrite(v) {
    if (v) {
      this.trackCliFlag("overwrite");
    }
  }
  trackCliOptionCrt(v) {
    if (v) {
      this.trackCliOption({
        option: "crt",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionKey(v) {
    if (v) {
      this.trackCliOption({
        option: "key",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionCa(v) {
    if (v) {
      this.trackCliOption({
        option: "ca",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/certs/add.ts
async function add(client, argv) {
  const { telemetryEventStore } = client;
  const addStamp = stamp_default();
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(addSubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  let cert;
  const {
    "--overwrite": overwrite,
    "--crt": crtPath,
    "--key": keyPath,
    "--ca": caPath
  } = opts;
  const telemetry2 = new CertsAddTelemetryClient({
    opts: {
      store: telemetryEventStore
    }
  });
  telemetry2.trackCliFlagOverwrite(overwrite);
  telemetry2.trackCliOptionCrt(crtPath);
  telemetry2.trackCliOptionKey(keyPath);
  telemetry2.trackCliOptionCa(caPath);
  if (overwrite) {
    output_manager_default.error("Overwrite option is deprecated");
    return 1;
  }
  if (crtPath || keyPath || caPath) {
    if (args.length !== 0 || !crtPath || !keyPath || !caPath) {
      output_manager_default.error(
        `Invalid number of arguments to create a custom certificate entry. Usage:`
      );
      output_manager_default.print(
        `  ${import_chalk16.default.cyan(
          `${getCommandName(
            "certs add --crt <domain.crt> --key <domain.key> --ca <ca.crt>"
          )}`
        )}
`
      );
      return 1;
    }
    cert = await createCertFromFile(client, keyPath, crtPath, caPath);
  } else {
    output_manager_default.warn(
      `${import_chalk16.default.cyan(
        getCommandName("certs add")
      )} will be soon deprecated. Please use ${import_chalk16.default.cyan(
        getCommandName("certs issue <cn> <cns>")
      )} instead`
    );
    if (args.length < 1) {
      output_manager_default.error(
        `Invalid number of arguments to create a custom certificate entry. Usage:`
      );
      output_manager_default.print(
        `  ${import_chalk16.default.cyan(getCommandName("certs add <cn>[, <cn>]"))}
`
      );
      return 1;
    }
    const cns = args.reduce(
      (res, item) => res.concat(item.split(",")),
      []
    );
    output_manager_default.spinner(
      `Generating a certificate for ${import_chalk16.default.bold(cns.join(", "))}`
    );
    const { contextName } = await getScope(client);
    cert = await createCertForCns(client, cns, contextName);
    output_manager_default.stopSpinner();
  }
  if (cert instanceof Error) {
    output_manager_default.error(cert.message);
    return 1;
  } else {
    output_manager_default.success(
      `Certificate entry for ${import_chalk16.default.bold(
        cert.cns.join(", ")
      )} created ${addStamp()}`
    );
  }
  return 0;
}
var add_default = add;

// src/commands/certs/issue.ts
var import_chalk19 = __toESM(require_source(), 1);
var import_tldts3 = __toESM(require_cjs(), 1);

// src/util/certs/finish-cert-order.ts
var import_chalk17 = __toESM(require_source(), 1);
async function startCertOrder(client, cns, context) {
  output_manager_default.spinner(`Issuing a certificate for ${import_chalk17.default.bold(cns.join(", "))}`);
  try {
    const cert = await client.fetch("/v3/certs", {
      method: "PATCH",
      body: {
        op: "finalizeOrder",
        domains: cns
      }
    });
    return cert;
  } catch (err) {
    if (isAPIError(err)) {
      if (err.code === "cert_order_not_found") {
        return new CertOrderNotFound(cns);
      }
      const mappedError = mapCertError(err, cns);
      if (mappedError) {
        return mappedError;
      }
    }
    throw err;
  }
}

// src/util/certs/get-cns-from-args.ts
function getCnsFromArgs(args) {
  return args.reduce((res, item) => [...res, ...item.split(",")], []).filter((i) => i);
}

// src/util/certs/start-cert-order.ts
var import_chalk18 = __toESM(require_source(), 1);
async function startCertOrder2(client, cns, contextName) {
  output_manager_default.spinner(
    `Starting certificate issuance for ${import_chalk18.default.bold(
      cns.join(", ")
    )} under ${import_chalk18.default.bold(contextName)}`
  );
  const order = await client.fetch("/v3/certs", {
    method: "PATCH",
    body: {
      op: "startOrder",
      domains: cns
    }
  });
  return order;
}

// src/util/telemetry/commands/certs/issue.ts
var CertsIssueTelemetryClient = class extends CertsAddTelemetryClient {
  trackCliArgumentCn(value) {
    if (value) {
      this.trackCliArgument({
        arg: "cn",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagChallengeOnly(v) {
    if (v) {
      this.trackCliFlag("challenge-only");
    }
  }
};

// src/commands/certs/issue.ts
async function issue(client, argv) {
  let cert;
  const { telemetryEventStore } = client;
  const addStamp = stamp_default();
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(issueSubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  const {
    "--challenge-only": challengeOnly,
    "--overwrite": overwrite,
    "--crt": crtPath,
    "--key": keyPath,
    "--ca": caPath
  } = opts;
  const telemetry2 = new CertsIssueTelemetryClient({
    opts: {
      store: telemetryEventStore
    }
  });
  telemetry2.trackCliFlagChallengeOnly(challengeOnly);
  telemetry2.trackCliFlagOverwrite(overwrite);
  telemetry2.trackCliOptionCrt(crtPath);
  telemetry2.trackCliOptionKey(keyPath);
  telemetry2.trackCliOptionCa(caPath);
  if (overwrite) {
    output_manager_default.error("Overwrite option is deprecated");
    return 1;
  }
  if (crtPath || keyPath || caPath) {
    if (args.length !== 0 || !crtPath || !keyPath || !caPath) {
      output_manager_default.error(
        `Invalid number of arguments to create a custom certificate entry. Usage:`
      );
      output_manager_default.print(
        `  ${import_chalk19.default.cyan(
          getCommandName(
            "certs issue --crt <domain.crt> --key <domain.key> --ca <ca.crt>"
          )
        )}
`
      );
      return 1;
    }
    cert = await createCertFromFile(client, keyPath, crtPath, caPath);
    if (cert instanceof Error) {
      output_manager_default.error(cert.message);
      return 1;
    }
    output_manager_default.success(
      `Certificate entry for ${import_chalk19.default.bold(
        cert.cns.join(", ")
      )} created ${addStamp()}`
    );
    return 0;
  }
  if (args.length < 1) {
    output_manager_default.error(
      `Invalid number of arguments to create a custom certificate entry. Usage:`
    );
    output_manager_default.print(
      `  ${import_chalk19.default.cyan(getCommandName("certs issue <cn>[, <cn>]"))}
`
    );
    return 1;
  }
  telemetry2.trackCliArgumentCn(args[0]);
  const cns = getCnsFromArgs(args);
  const { contextName } = await getScope(client);
  if (challengeOnly) {
    return runStartOrder(client, cns, contextName, addStamp);
  }
  cert = await startCertOrder(client, cns, contextName);
  if (cert instanceof CertOrderNotFound) {
    cert = await createCertForCns(client, cns, contextName);
  }
  if (cert instanceof CertError) {
    if (cert.meta.code === "wildcard_not_allowed") {
      return runStartOrder(client, cns, contextName, addStamp, {
        fallingBack: true
      });
    }
  }
  const handledResult = handleCertError(cert);
  if (handledResult === 1) {
    return handledResult;
  }
  if (handledResult instanceof DomainPermissionDenied) {
    output_manager_default.error(
      `You do not have permissions over domain ${import_chalk19.default.underline(
        handledResult.meta.domain
      )} under ${import_chalk19.default.bold(handledResult.meta.context)}.`
    );
    return 1;
  }
  output_manager_default.success(
    `Certificate entry for ${import_chalk19.default.bold(
      handledResult.cns.join(", ")
    )} created ${addStamp()}`
  );
  return 0;
}
async function runStartOrder(client, cns, contextName, stamp, { fallingBack = false } = {}) {
  const { challengesToResolve } = await startCertOrder2(
    client,
    cns,
    contextName
  );
  const pendingChallenges = challengesToResolve.filter(
    (challenge) => challenge.status === "pending"
  );
  if (fallingBack) {
    output_manager_default.warn(
      `To generate a wildcard certificate for domain for an external domain you must solve challenges manually.`
    );
  }
  if (pendingChallenges.length === 0) {
    output_manager_default.log(
      `A certificate issuance for ${import_chalk19.default.bold(
        cns.join(", ")
      )} has been started ${stamp()}`
    );
    output_manager_default.print(
      `  There are no pending challenges. Finish the issuance by running: 
`
    );
    output_manager_default.print(
      `  ${import_chalk19.default.cyan(getCommandName(`certs issue ${cns.join(" ")}`))}
`
    );
    return 0;
  }
  output_manager_default.log(
    `A certificate issuance for ${import_chalk19.default.bold(
      cns.join(", ")
    )} has been started ${stamp()}`
  );
  output_manager_default.print(
    `  Add the following TXT records with your registrar to be able to the solve the DNS challenge:

`
  );
  const [header, ...rows] = formatDNSTable(
    pendingChallenges.map((challenge) => {
      const subdomain = (0, import_tldts3.getSubdomain)(challenge.domain);
      if (subdomain === null) {
        throw new InvalidDomain(challenge.domain);
      }
      return [
        subdomain ? `_acme-challenge.${subdomain}` : `_acme-challenge`,
        "TXT",
        challenge.value
      ];
    })
  ).split("\n");
  output_manager_default.print(`${header}
`);
  client.stdout.write(`${rows.join("\n")}

`);
  output_manager_default.log(`To issue the certificate once the records are added, run:`);
  output_manager_default.print(
    `  ${import_chalk19.default.cyan(getCommandName(`certs issue ${cns.join(" ")}`))}
`
  );
  output_manager_default.print(
    "  Read more: https://err.sh/vercel/solve-challenges-manually\n"
  );
  return 0;
}

// src/commands/certs/ls.ts
var import_chalk20 = __toESM(require_source(), 1);
var import_ms6 = __toESM(require_ms(), 1);

// src/util/certs/get-certs.ts
async function getCerts(client, next, limit = 20) {
  let certsUrl = `/v4/certs?limit=${limit}`;
  if (next) {
    certsUrl += `&until=${next}`;
  }
  return await client.fetch(certsUrl);
}

// src/util/telemetry/commands/certs/ls.ts
var CertsLsTelemetryClient = class extends TelemetryClient {
  trackCliOptionLimit(limit) {
    if (limit) {
      this.trackCliOption({
        option: "limit",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionNext(next) {
    if (next) {
      this.trackCliOption({
        option: "next",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/certs/ls.ts
async function ls2(client, argv) {
  const { telemetryEventStore } = client;
  const telemetry2 = new CertsLsTelemetryClient({
    opts: {
      store: telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(listSubcommand3.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  const validationResult = validateLsArgs({
    commandName: "certs ls",
    args
  });
  if (validationResult !== 0) {
    return validationResult;
  }
  telemetry2.trackCliOptionLimit(opts["--limit"]);
  telemetry2.trackCliOptionNext(opts["--next"]);
  let paginationOptions;
  try {
    paginationOptions = getPaginationOpts(opts);
  } catch (err) {
    output_manager_default.prettyError(err);
    return 1;
  }
  const lsStamp = stamp_default();
  const { certs, pagination } = await getCerts(client, ...paginationOptions);
  const { contextName } = await getScope(client);
  output_manager_default.log(
    `${certs.length > 0 ? "Certificates" : "No certificates"} found under ${import_chalk20.default.bold(contextName)} ${lsStamp()}`
  );
  if (certs.length > 0) {
    client.stdout.write(formatCertsTable(certs));
  }
  if (pagination && pagination.count === 20) {
    const flags = getCommandFlags(opts, ["_", "--next"]);
    output_manager_default.log(
      `To display the next page run ${getCommandName(
        `certs ls${flags} --next ${pagination.next}`
      )}`
    );
  }
  return 0;
}
function formatCertsTable(certsList) {
  return `${table(
    [formatCertsTableHead(), ...formatCertsTableBody(certsList)],
    { align: ["l", "l", "r", "c", "r"], hsep: 2 }
  ).replace(/^(.*)/gm, "  $1")}
`;
}
function formatCertsTableHead() {
  return [
    import_chalk20.default.dim("id"),
    import_chalk20.default.dim("cns"),
    import_chalk20.default.dim("expiration"),
    import_chalk20.default.dim("renew"),
    import_chalk20.default.dim("age")
  ];
}
function formatCertsTableBody(certsList) {
  const now = /* @__PURE__ */ new Date();
  return certsList.reduce(
    (result, cert) => result.concat(formatCert(now, cert)),
    []
  );
}
function formatCert(time, cert) {
  return cert.cns.map(
    (cn, idx) => idx === 0 ? formatCertFirstCn(time, cert, cn, cert.cns.length > 1) : formatCertNonFirstCn(cn, cert.cns.length > 1)
  );
}
function formatCertNonFirstCn(cn, multiple) {
  return ["", formatCertCn(cn, multiple), "", "", ""];
}
function formatCertCn(cn, multiple) {
  return multiple ? `${import_chalk20.default.gray("-")} ${import_chalk20.default.bold(cn)}` : import_chalk20.default.bold(cn);
}
function formatCertFirstCn(time, cert, cn, multiple) {
  return [
    cert.uid,
    formatCertCn(cn, multiple),
    formatExpirationDate(new Date(cert.expiration)),
    cert.autoRenew ? "yes" : "no",
    import_chalk20.default.gray((0, import_ms6.default)(time.getTime() - new Date(cert.created).getTime()))
  ];
}
function formatExpirationDate(date) {
  const diff = date.getTime() - Date.now();
  return diff < 0 ? import_chalk20.default.gray(`${(0, import_ms6.default)(-diff)} ago`) : import_chalk20.default.gray(`in ${(0, import_ms6.default)(diff)}`);
}
var ls_default = ls2;

// src/commands/certs/rm.ts
var import_chalk21 = __toESM(require_source(), 1);
var import_ms7 = __toESM(require_ms(), 1);
var import_pluralize4 = __toESM(require_pluralize(), 1);

// src/util/certs/delete-cert-by-id.ts
async function deleteCertById(client, id) {
  return client.fetch(`/v5/certs/${id}`, {
    method: "DELETE"
  });
}

// src/util/certs/get-cert-by-id.ts
async function getCertById(client, id) {
  try {
    return await client.fetch(`/v6/certs/${id}`);
  } catch (err) {
    if (isAPIError(err) && err.code === "cert_not_found") {
      return new CertNotFound(id);
    }
    throw err;
  }
}

// src/util/certs/get-custom-certs-for-domain.ts
import { stringify } from "querystring";
async function getCustomCertsForDomain(client, context, domain) {
  try {
    const { certs } = await client.fetch(
      `/v5/now/certs?${stringify({ domain, custom: true })}`
    );
    return certs;
  } catch (err) {
    if (isAPIError(err) && err.code === "forbidden") {
      return new CertsPermissionDenied(context, domain);
    }
    throw err;
  }
}

// src/util/telemetry/commands/certs/remove.ts
var CertsRemoveTelemetryClient = class extends TelemetryClient {
  trackCliArgumentId(v) {
    if (v) {
      this.trackCliArgument({
        arg: "id",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/certs/rm.ts
async function rm2(client, argv) {
  const rmStamp = stamp_default();
  const { telemetryEventStore } = client;
  const telemetry2 = new CertsRemoveTelemetryClient({
    opts: {
      store: telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(removeSubcommand2.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args } = parsedArgs;
  const id = args[0];
  telemetry2.trackCliArgumentId(id);
  if (args.length !== 1) {
    output_manager_default.error(
      `Invalid number of arguments. Usage: ${import_chalk21.default.cyan(
        `${getCommandName("certs rm <id or cn>")}`
      )}`
    );
    return 1;
  }
  const { contextName } = await getScope(client);
  const certs = await getCertsToDelete(client, contextName, id);
  if (certs instanceof CertsPermissionDenied) {
    output_manager_default.error(
      `You don't have access to ${param(id)}'s certs under ${contextName}.`
    );
    return 1;
  }
  if (certs.length === 0) {
    if (id.includes(".")) {
      output_manager_default.error(
        `No custom certificates found for "${id}" under ${import_chalk21.default.bold(
          contextName
        )}`
      );
    } else {
      output_manager_default.error(
        `No certificates found by id "${id}" under ${import_chalk21.default.bold(contextName)}`
      );
    }
    return 1;
  }
  const yes = await readConfirmation(
    client,
    "The following certificates will be removed permanently",
    certs
  );
  if (!yes) {
    return 0;
  }
  await Promise.all(certs.map((cert) => deleteCertById(client, cert.uid)));
  output_manager_default.success(
    `${import_chalk21.default.bold(
      (0, import_pluralize4.default)("Certificate", certs.length, true)
    )} removed ${rmStamp()}`
  );
  return 0;
}
async function getCertsToDelete(client, contextName, id) {
  const cert = await getCertById(client, id);
  if (cert instanceof CertNotFound) {
    const certs = await getCustomCertsForDomain(client, contextName, id);
    if (certs instanceof CertsPermissionDenied) {
      return certs;
    }
    return certs;
  }
  return [cert];
}
function readConfirmation(client, msg, certs) {
  return new Promise((resolve6) => {
    output_manager_default.log(msg);
    output_manager_default.print(
      `${table(certs.map(formatCertRow), {
        align: ["l", "r", "l"],
        hsep: 6
      }).replace(/^(.*)/gm, "  $1")}
`
    );
    output_manager_default.print(
      `${import_chalk21.default.bold.red("> Are you sure?")} ${import_chalk21.default.gray("(y/N) ")}`
    );
    client.stdin.on("data", (d) => {
      process.stdin.pause();
      resolve6(d.toString().trim().toLowerCase() === "y");
    }).resume();
  });
}
function formatCertRow(cert) {
  return [
    cert.uid,
    import_chalk21.default.bold(cert.cns ? cert.cns.join(", ") : "\u2013"),
    ...cert.created ? [import_chalk21.default.gray(`${(0, import_ms7.default)(Date.now() - new Date(cert.created).getTime())} ago`)] : []
  ];
}
var rm_default = rm2;

// src/util/telemetry/commands/certs/index.ts
var CertsTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandIssue(actual) {
    this.trackCliSubcommand({
      subcommand: "issue",
      value: actual
    });
  }
  trackCliSubcommandAdd(actual) {
    this.trackCliSubcommand({
      subcommand: "add",
      value: actual
    });
  }
  trackCliSubcommandRemove(actual) {
    this.trackCliSubcommand({
      subcommand: "remove",
      value: actual
    });
  }
  trackCliSubcommandList(actual) {
    this.trackCliSubcommand({
      subcommand: "list",
      value: actual
    });
  }
};

// src/commands/certs/index.ts
var COMMAND_CONFIG5 = {
  add: getCommandAliases(addSubcommand),
  issue: getCommandAliases(issueSubcommand),
  ls: getCommandAliases(listSubcommand3),
  rm: getCommandAliases(removeSubcommand2)
};
async function main4(client) {
  const { telemetryEventStore } = client;
  const telemetry2 = new CertsTelemetryClient({
    opts: {
      store: telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(certsCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification, {
      permissive: true
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  const { subcommand, subcommandOriginal, args } = getSubcommand2(
    parsedArgs.args.slice(1),
    COMMAND_CONFIG5
  );
  const needHelp = parsedArgs.flags["--help"];
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp("certs", subcommand);
    output_manager_default.print(help(certsCommand, { columns: client.stderr.columns }));
    return 2;
  }
  function printHelp(command) {
    output_manager_default.print(
      help(command, { parent: certsCommand, columns: client.stderr.columns })
    );
  }
  switch (subcommand) {
    case "issue":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("certs", subcommandOriginal);
        printHelp(issueSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandIssue(subcommandOriginal);
      return issue(client, args);
    case "ls":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("certs", subcommandOriginal);
        printHelp(listSubcommand3);
        return 2;
      }
      telemetry2.trackCliSubcommandList(subcommandOriginal);
      return ls_default(client, args);
    case "rm":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("certs", subcommandOriginal);
        printHelp(removeSubcommand2);
        return 2;
      }
      telemetry2.trackCliSubcommandRemove(subcommandOriginal);
      return rm_default(client, args);
    case "add":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("certs", subcommandOriginal);
        printHelp(addSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandAdd(subcommandOriginal);
      return add_default(client, args);
    default:
      output_manager_default.error("Please specify a valid subcommand: ls | issue | rm");
      output_manager_default.print(help(certsCommand, { columns: client.stderr.columns }));
      return 2;
  }
}

// src/commands/curl/index.ts
import { spawn } from "child_process";

// src/commands/curl/utils.ts
var requoteArgs = (arg) => {
  if (arg.includes(" ")) {
    if (arg.includes('"')) {
      return `'${arg}'`;
    } else {
      return `"${arg}"`;
    }
  }
  return arg;
};

// src/util/telemetry/commands/curl/index.ts
var CurlTelemetryClient = class extends TelemetryClient {
  trackCliArgumentPath(path3) {
    if (path3) {
      const value = path3.startsWith("/") ? "slash" : "no-slash";
      this.trackCliArgument({
        arg: "path",
        value
      });
    }
  }
  trackCliOptionDeployment(deploymentId) {
    if (deploymentId) {
      const value = deploymentId.startsWith("http://") || deploymentId.startsWith("https://") ? "url" : deploymentId.startsWith("dpl_") ? "dpl_" : "no-prefix";
      this.trackCliOption({
        option: "deployment",
        value
      });
    }
  }
  trackCliOptionProtectionBypass(secret) {
    if (secret) {
      this.trackCliOption({
        option: "protection-bypass",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/curl/shared.ts
var import_chalk23 = __toESM(require_source(), 1);
var import_error_utils3 = __toESM(require_dist(), 1);

// src/commands/curl/bypass-token.ts
var import_chalk22 = __toESM(require_source(), 1);
async function createDeploymentProtectionToken(client, projectId, orgId) {
  if (!client.authConfig.token) {
    output_manager_default.debug(
      "No auth token available, skipping deployment protection token"
    );
    throw new Error(
      "Authentication required to create protection bypass token"
    );
  }
  try {
    const response = await client.fetch(`/v1/projects/${projectId}/protection-bypass`, {
      method: "PATCH",
      body: "{}",
      headers: {
        "Content-Type": "application/json"
      },
      accountId: orgId
    });
    const { protectionBypass } = response;
    output_manager_default.log(
      `You require a deployment protection bypass token to access this deployment... Generating one now...`
    );
    output_manager_default.log(
      `Successfully generated deployment protection bypass token for project ${import_chalk22.default.bold(projectId)}
`
    );
    output_manager_default.debug(`Protection Bypass Response: ${protectionBypass}`);
    await sleep(1e3);
    return getAutomationBypassToken(protectionBypass);
  } catch (error) {
    output_manager_default.debug(
      `Failed to generate deployment protection bypass token: ${error}`
    );
    output_manager_default.note(
      'To bypass deployment protection, create a "Protection Bypass for Automation" secret in your project settings:'
    );
    output_manager_default.log(`  1. Visit ${import_chalk22.default.cyan("https://vercel.com/dashboard")}`);
    output_manager_default.log(`  2. Go to your project settings \u2192 Deployment Protection`);
    output_manager_default.log(`  3. Generate a "Protection Bypass for Automation" secret`);
    output_manager_default.log(
      `  4. Use it with ${import_chalk22.default.cyan(
        "--protection-bypass"
      )} flag or set ${import_chalk22.default.cyan("VERCEL_AUTOMATION_BYPASS_SECRET")} env var`
    );
    output_manager_default.log("");
    throw new Error("Failed to create deployment protection bypass token");
  }
}
function getAutomationBypassToken(protectionBypass) {
  if (!protectionBypass) {
    throw new Error("No protection bypass tokens found");
  }
  const token = Object.keys(protectionBypass).find(
    (key) => protectionBypass[key].scope === "automation-bypass"
  );
  if (!token) {
    throw new Error(
      "No automation bypass token found in protection bypass settings"
    );
  }
  return token;
}
async function getOrCreateDeploymentProtectionToken(client, { project, org }) {
  if (process.env.VERCEL_AUTOMATION_BYPASS_SECRET) {
    output_manager_default.debug("Using protection bypass secret from environment variable");
    return process.env.VERCEL_AUTOMATION_BYPASS_SECRET;
  }
  if (project.protectionBypass && Object.values(project.protectionBypass).length) {
    const protectionBypass = getAutomationBypassToken(project.protectionBypass);
    if (protectionBypass) {
      output_manager_default.debug(
        `Using existing protection bypass token from project settings: ${protectionBypass}`
      );
      return protectionBypass;
    }
  }
  const token = await createDeploymentProtectionToken(
    client,
    project.id,
    org.id
  );
  return token;
}

// src/commands/curl/deployment-url.ts
async function getDeploymentUrlById(client, deploymentIdOrUrl, accountId) {
  try {
    if (deploymentIdOrUrl.startsWith("http://") || deploymentIdOrUrl.startsWith("https://")) {
      try {
        const url = new URL(deploymentIdOrUrl);
        return url.origin;
      } catch (err) {
        output_manager_default.debug(`Invalid deployment URL provided: ${deploymentIdOrUrl}`);
        return null;
      }
    }
    if (deploymentIdOrUrl.includes("vercel.app")) {
      return `https://${deploymentIdOrUrl}`;
    }
    let fullDeploymentId = deploymentIdOrUrl;
    if (!fullDeploymentId.startsWith("dpl_")) {
      fullDeploymentId = `dpl_${deploymentIdOrUrl}`;
    }
    const deployment = await client.fetch(
      `/v13/deployments/${fullDeploymentId}`,
      { accountId }
    );
    if (!deployment || !deployment.url) {
      return null;
    }
    return `https://${deployment.url}`;
  } catch (error) {
    output_manager_default.debug(`Failed to fetch deployment by ID: ${error}`);
    return null;
  }
}

// src/commands/curl/shared.ts
function setupCurlLikeCommand(client, command, telemetryClient) {
  const { print } = output_manager_default;
  let parsedArgs = null;
  const flagsSpecification = getFlagsSpecification(command.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { flags } = parsedArgs;
  if (parsedArgs.flags["--help"]) {
    print(help(command, { columns: client.stderr.columns }));
    return 2;
  }
  if (parsedArgs.args[0] === command.name) {
    parsedArgs.args.shift();
  }
  const separatorIndex = process.argv.indexOf("--");
  const path3 = parsedArgs.args[0];
  telemetryClient.trackCliArgumentPath(path3);
  const deploymentFlag = flags["--deployment"];
  if (deploymentFlag) {
    telemetryClient.trackCliOptionDeployment(deploymentFlag);
  }
  const protectionBypassFlag = flags["--protection-bypass"];
  if (protectionBypassFlag) {
    telemetryClient.trackCliOptionProtectionBypass(protectionBypassFlag);
  }
  if (!path3 || path3 === "--" || path3.startsWith("-")) {
    output_manager_default.error(
      `${getCommandName(`${command.name} <path>`)} requires an API path (e.g., '/' or '/api/hello' or 'api/hello')`
    );
    print(help(command, { columns: client.stderr.columns }));
    return 1;
  }
  if (path3.startsWith("http://") || path3.startsWith("https://")) {
    output_manager_default.error(
      `The <path> argument must be a relative API path (e.g., '/' or '/api/hello'), not a full URL.`
    );
    output_manager_default.print(
      `To target a specific deployment within the currently linked project, use the --deployment <id|url> flag.`
    );
    print(help(command, { columns: client.stderr.columns }));
    return 1;
  }
  const toolFlags = separatorIndex !== -1 ? process.argv.slice(separatorIndex + 1) : [];
  output_manager_default.debug(
    `${command.name} flags (${toolFlags.length} args): ${JSON.stringify(toolFlags)}`
  );
  return {
    path: path3,
    deploymentFlag,
    protectionBypassFlag,
    toolFlags
  };
}
async function getDeploymentUrlAndToken(client, commandName, path3, options) {
  const { deploymentFlag, protectionBypassFlag } = options;
  let link;
  let scope;
  try {
    scope = await getScope(client);
  } catch (err) {
    if ((0, import_error_utils3.isErrnoException)(err) && (err.code === "NOT_AUTHORIZED" || err.code === "TEAM_DELETED")) {
      output_manager_default.error(err.message);
      return 1;
    }
    throw err;
  }
  try {
    link = await ensureLink(commandName, client, client.cwd);
  } catch (err) {
    if ((0, import_error_utils3.isErrnoException)(err) && err.code === "NOT_AUTHORIZED") {
      output_manager_default.error(err.message);
      return 1;
    }
    throw err;
  }
  if (typeof link === "number") {
    return link;
  }
  const { project } = link;
  const linkedProject = await getLinkedProject(client, client.cwd);
  if (linkedProject.status !== "linked") {
    output_manager_default.error("This command requires a linked project. Please run:");
    output_manager_default.print("  vercel link");
    return 1;
  }
  if (!linkedProject.project || !linkedProject.org) {
    output_manager_default.error("Failed to get project information");
    return 1;
  }
  const preferredAlias = linkedProject.project.targets?.production?.alias?.[0];
  const backupAlias = linkedProject.project.latestDeployments?.[0]?.url;
  const target = preferredAlias || backupAlias;
  let baseUrl;
  if (deploymentFlag) {
    const accountId = scope.team?.id || scope.user.id;
    const deploymentUrl = await getDeploymentUrlById(
      client,
      deploymentFlag,
      accountId
    );
    if (!deploymentUrl) {
      output_manager_default.error(`No deployment found for ID "${deploymentFlag}"`);
      return 1;
    }
    baseUrl = deploymentUrl;
  } else if (target) {
    baseUrl = `https://${target}`;
  } else {
    throw new Error("No deployment URL found for the project");
  }
  const fullUrl = `${baseUrl}${path3.startsWith("/") ? path3 : `/${path3}`}`;
  output_manager_default.debug(`${import_chalk23.default.cyan("Target URL:")} ${import_chalk23.default.bold(fullUrl)}`);
  let deploymentProtectionToken = null;
  if (project.id) {
    try {
      deploymentProtectionToken = protectionBypassFlag ?? await getOrCreateDeploymentProtectionToken(client, link);
    } catch (err) {
      output_manager_default.error(
        `Failed to get deployment protection bypass token: ${err instanceof Error ? err.message : String(err)}`
      );
      return 1;
    }
  }
  return {
    fullUrl,
    deploymentProtectionToken,
    link
  };
}

// src/commands/curl/index.ts
async function curl(client) {
  const telemetryClient = new CurlTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const setup = setupCurlLikeCommand(client, curlCommand, telemetryClient);
  if (typeof setup === "number") {
    return setup;
  }
  const { path: path3, deploymentFlag, protectionBypassFlag, toolFlags } = setup;
  const result = await getDeploymentUrlAndToken(client, "curl", path3, {
    deploymentFlag,
    protectionBypassFlag
  });
  if (typeof result === "number") {
    return result;
  }
  const { fullUrl, deploymentProtectionToken } = result;
  const curlFlags = [...toolFlags];
  if (deploymentProtectionToken) {
    curlFlags.unshift(
      "--header",
      `x-vercel-protection-bypass: ${deploymentProtectionToken}`
    );
  }
  curlFlags.unshift("--url", fullUrl);
  output_manager_default.debug(`Executing: curl ${curlFlags.map(requoteArgs).join(" ")}`);
  return new Promise((resolve6) => {
    const curlProcess = spawn("curl", curlFlags, {
      stdio: "inherit",
      shell: false
    });
    curlProcess.on("error", (err) => {
      if ("code" in err && err.code === "ENOENT") {
        output_manager_default.error("curl command not found. Please install curl.");
        resolve6(1);
      } else {
        output_manager_default.error(`Failed to execute curl: ${err.message}`);
        resolve6(1);
      }
    });
    curlProcess.on("close", (code2) => {
      resolve6(code2 ?? 1);
    });
  });
}

// src/commands/dns/add.ts
var import_chalk25 = __toESM(require_source(), 1);

// src/util/dns/add-dns-record.ts
async function addDNSRecord(client, domain, recordData) {
  try {
    const record = await client.fetch(
      `/v3/domains/${encodeURIComponent(domain)}/records`,
      {
        body: recordData,
        method: "POST"
      }
    );
    return record;
  } catch (err) {
    if (isAPIError(err)) {
      if (err.status === 400 && err.code === "invalid_type") {
        return new DNSInvalidType(recordData.type);
      }
      if (err.status === 400 && err.message.includes("port")) {
        return new DNSInvalidPort();
      }
      if (err.status === 400) {
        return err;
      }
      if (err.status === 403) {
        return new DNSPermissionDenied(domain);
      }
      if (err.status === 404) {
        return new DomainNotFound(domain);
      }
      if (err.status === 409) {
        const { oldId = "" } = err;
        return new DNSConflictingRecord(oldId);
      }
    }
    throw err;
  }
}

// src/util/dns/parse-add-dns-record-args.ts
function parseAddArgs(args) {
  if (!args || args.length < 1) {
    return null;
  }
  const [domain, ...rest] = args;
  if (domain && rest.length === 0) {
    return {
      domain,
      data: null
    };
  }
  const name = args[1] === "@" ? "" : args[1].toString();
  const type = args[2];
  const value = args[3];
  if (!(domain && typeof name === "string" && type)) {
    return null;
  }
  if (type === "MX" && args.length === 5) {
    return {
      domain,
      data: { name, type, value, mxPriority: Number(args[4]) }
    };
  }
  if (type === "SRV" && args.length === 7) {
    return {
      domain,
      data: {
        name,
        type,
        srv: {
          priority: Number(value),
          weight: Number(args[4]),
          port: Number(args[5]),
          target: args[6]
        }
      }
    };
  }
  if (args.length === 4) {
    return {
      domain,
      data: {
        name,
        type,
        value
      }
    };
  }
  return null;
}

// src/util/dns/get-dns-data.ts
var import_chalk24 = __toESM(require_source(), 1);
var RECORD_TYPES = ["A", "AAAA", "ALIAS", "CAA", "CNAME", "MX", "SRV", "TXT"];
async function getDNSData(client, data) {
  if (data) {
    return data;
  }
  try {
    const possibleTypes = new Set(RECORD_TYPES);
    const type = (await client.input.text({
      message: `- Record type (${RECORD_TYPES.join(", ")}): `,
      validate: (v) => Boolean(v && possibleTypes.has(v.trim().toUpperCase()))
    })).trim().toUpperCase();
    const name = await getRecordName(client, type);
    if (type === "SRV") {
      const priority = await getNumber(client, `- ${type} priority: `);
      const weight = await getNumber(client, `- ${type} weight: `);
      const port = await getNumber(client, `- ${type} port: `);
      const target = await getTrimmedString(client, `- ${type} target: `);
      output_manager_default.log(
        `${import_chalk24.default.cyan(name)} ${import_chalk24.default.bold(type)} ${import_chalk24.default.cyan(
          `${priority}`
        )} ${import_chalk24.default.cyan(`${weight}`)} ${import_chalk24.default.cyan(`${port}`)} ${import_chalk24.default.cyan(
          target
        )}.`
      );
      return await verifyData(client) ? {
        name,
        type,
        srv: {
          priority,
          weight,
          port,
          target
        }
      } : null;
    }
    if (type === "MX") {
      const mxPriority = await getNumber(client, `- ${type} priority: `);
      const value2 = await getTrimmedString(client, `- ${type} host: `);
      output_manager_default.log(
        `${import_chalk24.default.cyan(name)} ${import_chalk24.default.bold(type)} ${import_chalk24.default.cyan(
          `${mxPriority}`
        )} ${import_chalk24.default.cyan(value2)}`
      );
      return await verifyData(client) ? {
        name,
        type,
        value: value2,
        mxPriority
      } : null;
    }
    const value = await getTrimmedString(client, `- ${type} value: `);
    output_manager_default.log(`${import_chalk24.default.cyan(name)} ${import_chalk24.default.bold(type)} ${import_chalk24.default.cyan(value)}`);
    return await verifyData(client) ? {
      name,
      type,
      value
    } : null;
  } catch (error) {
    return null;
  }
}
async function verifyData(client) {
  return client.input.confirm("Is this correct?", false);
}
async function getRecordName(client, type) {
  const input = await client.input.text({
    message: `- ${type} name: `
  });
  return input === "@" ? "" : input;
}
async function getNumber(client, label) {
  return Number(
    await client.input.text({
      message: label,
      validate: (v) => Boolean(v && Number(v))
    })
  );
}
async function getTrimmedString(client, label) {
  const res = await client.input.text({
    message: label,
    validate: (v) => Boolean(v && v.trim().length > 0)
  });
  return res.trim();
}

// src/util/telemetry/commands/dns/add.ts
var ALLOWED_RECORD_TYPES = [
  "A",
  "AAAA",
  "ALIAS",
  "CNAME",
  "TXT",
  "MX",
  "SRV"
];
var DnsAddTelemetryClient = class extends TelemetryClient {
  trackCliArgumentDomain(domain) {
    if (domain) {
      this.trackCliArgument({
        arg: "domain",
        value: this.redactedValue
      });
    }
  }
  trackCliArgumentName(name) {
    if (name) {
      this.trackCliArgument({
        arg: "name",
        value: this.redactedValue
      });
    }
  }
  trackCliArgumentType(type) {
    if (type) {
      const allowedType = ALLOWED_RECORD_TYPES.includes(type) ? type : this.redactedValue;
      this.trackCliArgument({
        arg: "type",
        value: allowedType
      });
    }
  }
  trackCliArgumentValues(values) {
    if (values?.length) {
      this.trackCliArgument({
        arg: "values",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/dns/add.ts
async function add2(client, argv) {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(addSubcommand2.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args } = parsedArgs;
  const parsedParams = parseAddArgs(args);
  if (!parsedParams) {
    output_manager_default.error(
      `Invalid number of arguments. See: ${import_chalk25.default.cyan(
        `${getCommandName("dns --help")}`
      )} for usage.`
    );
    return 1;
  }
  const addStamp = stamp_default();
  const { domain, data: argData } = parsedParams;
  const valueArgs = args.slice(3);
  const telemetryClient = new DnsAddTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  telemetryClient.trackCliArgumentDomain(domain);
  telemetryClient.trackCliArgumentName(parsedParams.data?.name);
  telemetryClient.trackCliArgumentType(parsedParams.data?.type);
  telemetryClient.trackCliArgumentValues(valueArgs);
  const data = await getDNSData(client, argData);
  if (!data) {
    output_manager_default.log(`Canceled`);
    return 1;
  }
  const { contextName } = await getScope(client);
  const record = await addDNSRecord(client, domain, data);
  if (record instanceof DomainNotFound) {
    output_manager_default.error(
      `The domain ${domain} can't be found under ${import_chalk25.default.bold(
        contextName
      )} ${import_chalk25.default.gray(addStamp())}`
    );
    return 1;
  }
  if (record instanceof DNSPermissionDenied) {
    output_manager_default.error(
      `You don't have permissions to add records to domain ${domain} under ${import_chalk25.default.bold(
        contextName
      )} ${import_chalk25.default.gray(addStamp())}`
    );
    return 1;
  }
  if (record instanceof DNSInvalidPort) {
    output_manager_default.error(
      `Invalid <port> parameter. A number was expected ${import_chalk25.default.gray(
        addStamp()
      )}`
    );
    return 1;
  }
  if (record instanceof DNSInvalidType) {
    output_manager_default.error(
      `Invalid <type> parameter "${record.meta.type}". Expected one of A, AAAA, ALIAS, CAA, CNAME, MX, SRV, TXT ${import_chalk25.default.gray(
        addStamp()
      )}`
    );
    return 1;
  }
  if (record instanceof Error) {
    output_manager_default.error(record.message);
    return 1;
  }
  output_manager_default.success(
    `DNS record for domain ${import_chalk25.default.bold(domain)} ${import_chalk25.default.gray(
      `(${record.uid})`
    )} created under ${import_chalk25.default.bold(contextName)} ${import_chalk25.default.gray(addStamp())}`
  );
  return 0;
}

// src/commands/dns/import.ts
var import_chalk27 = __toESM(require_source(), 1);

// src/util/dns/import-zonefile.ts
var import_chalk26 = __toESM(require_source(), 1);
import { readFileSync as readFileSync2 } from "fs";
import { resolve as resolve5 } from "path";
async function importZonefile(client, contextName, domain, zonefilePath) {
  output_manager_default.spinner(
    `Importing Zone file for domain ${domain} under ${import_chalk26.default.bold(contextName)}`
  );
  const zonefile = readFileSync2(resolve5(zonefilePath), "utf8");
  try {
    const res = await client.fetch(
      `/v3/domains/${encodeURIComponent(domain)}/records`,
      {
        headers: { "Content-Type": "text/dns" },
        body: zonefile,
        method: "PUT",
        json: false
      }
    );
    const { recordIds } = await res.json();
    return recordIds;
  } catch (err) {
    if (isAPIError(err)) {
      if (err.code === "not_found") {
        return new DomainNotFound(domain, contextName);
      }
      if (err.code === "invalid_domain") {
        return new InvalidDomain(domain);
      }
    }
    throw err;
  }
}

// src/util/telemetry/commands/dns/import.ts
var DnsImportTelemetryClient = class extends TelemetryClient {
  trackCliArgumentDomain(domain) {
    if (domain) {
      this.trackCliArgument({
        arg: "domain",
        value: this.redactedValue
      });
    }
  }
  trackCliArgumentZonefile(path3) {
    if (path3) {
      this.trackCliArgument({
        arg: "zoneFilePath",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/dns/import.ts
async function importZone(client, argv) {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(importSubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args } = parsedArgs;
  const { telemetryEventStore } = client;
  const { contextName } = await getScope(client);
  const telemetry2 = new DnsImportTelemetryClient({
    opts: {
      store: telemetryEventStore
    }
  });
  if (args.length !== 2) {
    output_manager_default.error(
      `Invalid number of arguments. Usage: ${import_chalk27.default.cyan(
        `${getCommandName("dns import <domain> <zonefile>")}`
      )}`
    );
    return 1;
  }
  const addStamp = stamp_default();
  const [domain, zonefilePath] = args;
  telemetry2.trackCliArgumentDomain(domain);
  telemetry2.trackCliArgumentZonefile(zonefilePath);
  const recordIds = await importZonefile(
    client,
    contextName,
    domain,
    zonefilePath
  );
  if (recordIds instanceof DomainNotFound) {
    output_manager_default.error(
      `The domain ${domain} can't be found under ${import_chalk27.default.bold(
        contextName
      )} ${import_chalk27.default.gray(addStamp())}`
    );
    return 1;
  }
  if (recordIds instanceof InvalidDomain) {
    output_manager_default.error(
      `The domain ${domain} doesn't match with the one found in the Zone file ${import_chalk27.default.gray(
        addStamp()
      )}`
    );
    return 1;
  }
  output_manager_default.success(
    `${recordIds.length} DNS records for domain ${import_chalk27.default.bold(
      domain
    )} created under ${import_chalk27.default.bold(contextName)} ${import_chalk27.default.gray(addStamp())}`
  );
  return 0;
}

// src/commands/dns/ls.ts
var import_chalk29 = __toESM(require_source(), 1);
var import_ms8 = __toESM(require_ms(), 1);

// src/util/dns/get-domain-dns-records.ts
async function getDomainDNSRecords(client, domain, apiVersion = 3, nextTimestamp, limit = 20) {
  output_manager_default.debug(`Fetching for DNS records of domain ${domain}`);
  try {
    let url = `/v${apiVersion}/domains/${encodeURIComponent(
      domain
    )}/records?limit=${limit}`;
    if (nextTimestamp) {
      url += `&until=${nextTimestamp}`;
    }
    const data = await client.fetch(url);
    return data;
  } catch (err) {
    if (isAPIError(err) && err.code === "not_found") {
      return new DomainNotFound(domain);
    }
    throw err;
  }
}

// src/util/domains/get-domains.ts
async function getDomains(client, next, limit = 20) {
  let domainUrl = `/v5/domains?limit=${limit}`;
  if (next) {
    domainUrl += `&until=${next}`;
  }
  return await client.fetch(domainUrl);
}

// src/util/dns/get-dns-records.ts
var import_chalk28 = __toESM(require_source(), 1);
async function getDNSRecords(client, contextName, next) {
  const { domainNames, pagination } = await getDomainNames(
    client,
    contextName,
    next
  );
  const domainsRecords = await Promise.all(
    domainNames.map(createGetDomainRecords(client))
  );
  const onlyRecords = domainsRecords.map(
    (item) => item instanceof DomainNotFound ? [] : item
  );
  return {
    records: onlyRecords.reduce(getAddDomainName(domainNames), []),
    pagination
  };
}
function createGetDomainRecords(client) {
  return async (domainName) => {
    const data = await getDomainDNSRecords(client, domainName);
    if (data instanceof DomainNotFound) {
      return [];
    }
    return data.records;
  };
}
function getAddDomainName(domainNames) {
  return (prev, item, idx) => [
    ...prev,
    {
      domainName: domainNames[idx],
      records: item
    }
  ];
}
async function getDomainNames(client, contextName, next) {
  output_manager_default.spinner(`Fetching domains under ${import_chalk28.default.bold(contextName)}`);
  const { domains: domains2, pagination } = await getDomains(client, next);
  return { domainNames: domains2.map((domain) => domain.name), pagination };
}

// src/util/telemetry/commands/dns/ls.ts
var DnsLsTelemetryClient = class extends TelemetryClient {
  trackCliArgumentDomain(domainName) {
    if (domainName) {
      this.trackCliArgument({
        arg: "domain",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionLimit(limit) {
    if (limit) {
      this.trackCliOption({
        option: "limit",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionNext(next) {
    if (next) {
      this.trackCliOption({
        option: "next",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/dns/ls.ts
async function ls3(client, argv) {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(listSubcommand4.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  const validationResult = validateLsArgs({
    commandName: "dns ls [domain]",
    args,
    maxArgs: 1,
    exitCode: 1
  });
  if (validationResult !== 0) {
    return validationResult;
  }
  const { telemetryEventStore } = client;
  const { contextName } = await getScope(client);
  const telemetry2 = new DnsLsTelemetryClient({
    opts: {
      store: telemetryEventStore
    }
  });
  const [domainName] = args;
  const lsStamp = stamp_default();
  telemetry2.trackCliArgumentDomain(domainName);
  telemetry2.trackCliOptionLimit(opts["--limit"]);
  telemetry2.trackCliOptionNext(opts["--next"]);
  let paginationOptions;
  try {
    paginationOptions = getPaginationOpts(opts);
  } catch (err) {
    output_manager_default.prettyError(err);
    return 1;
  }
  if (domainName) {
    const data = await getDomainDNSRecords(
      client,
      domainName,
      4,
      ...paginationOptions
    );
    if (data instanceof DomainNotFound) {
      output_manager_default.error(
        `The domain ${domainName} can't be found under ${import_chalk29.default.bold(
          contextName
        )} ${import_chalk29.default.gray(lsStamp())}`
      );
      return 1;
    }
    const { records, pagination: pagination2 } = data;
    output_manager_default.log(
      `${records.length > 0 ? "Records" : "No records"} found under ${import_chalk29.default.bold(contextName)} ${import_chalk29.default.gray(lsStamp())}`
    );
    client.stdout.write(getDNSRecordsTable([{ domainName, records }]));
    if (pagination2 && pagination2.count === 20) {
      const flags = getCommandFlags(opts, ["_", "--next"]);
      output_manager_default.log(
        `To display the next page run ${getCommandName(
          `dns ls ${domainName}${flags} --next ${pagination2.next}`
        )}`
      );
    }
    return 0;
  }
  const { records: dnsRecords, pagination } = await getDNSRecords(
    client,
    contextName,
    ...paginationOptions
  );
  const nRecords = dnsRecords.reduce((p, r) => r.records.length + p, 0);
  output_manager_default.log(
    `${nRecords > 0 ? "Records" : "No records"} found under ${import_chalk29.default.bold(
      contextName
    )} ${import_chalk29.default.gray(lsStamp())}`
  );
  output_manager_default.log(getDNSRecordsTable(dnsRecords));
  if (pagination && pagination.count === 20) {
    const flags = getCommandFlags(opts, ["_", "--next"]);
    output_manager_default.log(
      `To display the next page run ${getCommandName(
        `dns ls${flags} --next ${pagination.next}`
      )}`
    );
  }
  return 0;
}
function getDNSRecordsTable(dnsRecords) {
  return formatTable(
    ["", "id", "name", "type", "value", "created"],
    ["l", "r", "l", "l", "l", "l"],
    dnsRecords.map(({ domainName, records }) => ({
      name: import_chalk29.default.bold(domainName),
      rows: records.map(getDNSRecordRow)
    }))
  );
}
function getDNSRecordRow(record) {
  const isSystemRecord = record.creator === "system";
  const createdAt = `${(0, import_ms8.default)(
    Date.now() - new Date(Number(record.createdAt)).getTime()
  )} ago`;
  const priority = record.mxPriority || record.priority || null;
  return [
    "",
    !isSystemRecord ? record.id : "",
    record.name,
    record.type,
    priority ? `${priority} ${record.value}` : record.value,
    import_chalk29.default.gray(isSystemRecord ? "default" : createdAt)
  ];
}

// src/commands/dns/rm.ts
var import_chalk30 = __toESM(require_source(), 1);
var import_ms9 = __toESM(require_ms(), 1);

// src/util/dns/delete-dns-record-by-id.ts
async function deleteDNSRecordById(client, domain, recordId) {
  return client.fetch(
    `/v3/domains/${encodeURIComponent(domain)}/records/${recordId}`,
    {
      method: "DELETE"
    }
  );
}

// src/util/dns/get-dns-record-by-id.ts
async function getDNSRecordById(client, id) {
  return client.fetch(`/v5/domains/records/${id}`);
}

// src/util/telemetry/commands/dns/rm.ts
var DnsRmTelemetryClient = class extends TelemetryClient {
  trackCliArgumentId(recordId) {
    if (recordId) {
      this.trackCliArgument({
        arg: "recordId",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
};

// src/commands/dns/rm.ts
async function rm3(client, argv) {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(removeSubcommand3.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags } = parsedArgs;
  const { telemetryEventStore } = client;
  const telemetry2 = new DnsRmTelemetryClient({
    opts: {
      store: telemetryEventStore
    }
  });
  await getScope(client);
  const [recordId] = args;
  if (args.length !== 1) {
    output_manager_default.error(
      `Invalid number of arguments. Usage: ${import_chalk30.default.cyan(
        `${getCommandName("dns rm <id>")}`
      )}`
    );
    return 1;
  }
  telemetry2.trackCliArgumentId(recordId);
  telemetry2.trackCliFlagYes(flags["--yes"]);
  const record = await getDNSRecordById(client, recordId);
  if (!record) {
    output_manager_default.error("DNS record not found");
    return 1;
  }
  const { domain: domainName } = record;
  const skipConfirmation = flags["--yes"];
  const yes = skipConfirmation || await readConfirmation2(
    client,
    "The following record will be removed permanently",
    domainName,
    record
  );
  if (!yes) {
    output_manager_default.error(`User canceled.`);
    return 0;
  }
  const rmStamp = stamp_default();
  await deleteDNSRecordById(client, domainName, record.id);
  output_manager_default.success(
    `Record ${import_chalk30.default.gray(`${record.id}`)} removed ${import_chalk30.default.gray(rmStamp())}`
  );
  return 0;
}
function readConfirmation2(client, msg, domainName, record) {
  return new Promise((resolve6) => {
    output_manager_default.log(msg);
    output_manager_default.print(
      `${table([getDeleteTableRow(domainName, record)], {
        align: ["l", "r", "l"],
        hsep: 6
      }).replace(/^(.*)/gm, "  $1")}
`
    );
    output_manager_default.print(
      `${import_chalk30.default.bold.red("> Are you sure?")} ${import_chalk30.default.gray("(y/N) ")}`
    );
    client.stdin.on("data", (d) => {
      process.stdin.pause();
      resolve6(d.toString().trim().toLowerCase() === "y");
    }).resume();
  });
}
function getDeleteTableRow(domainName, record) {
  const recordName = `${record.name.length > 0 ? `${record.name}.` : ""}${domainName}`;
  return [
    record.id,
    import_chalk30.default.bold(
      `${recordName} ${record.type} ${record.value} ${record.mxPriority || ""}`
    ),
    import_chalk30.default.gray(
      `${(0, import_ms9.default)(Date.now() - new Date(Number(record.createdAt)).getTime())} ago`
    )
  ];
}

// src/util/telemetry/commands/dns/index.ts
var DnsTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandAdd(actual) {
    this.trackCliSubcommand({
      subcommand: "add",
      value: actual
    });
  }
  trackCliSubcommandRemove(actual) {
    this.trackCliSubcommand({
      subcommand: "remove",
      value: actual
    });
  }
  trackCliSubcommandImport(actual) {
    this.trackCliSubcommand({
      subcommand: "import",
      value: actual
    });
  }
  trackCliSubcommandList(actual) {
    this.trackCliSubcommand({
      subcommand: "list",
      value: actual
    });
  }
};

// src/commands/dns/index.ts
var COMMAND_CONFIG6 = {
  add: getCommandAliases(addSubcommand2),
  import: getCommandAliases(importSubcommand),
  ls: getCommandAliases(listSubcommand4),
  rm: getCommandAliases(removeSubcommand3)
};
async function dns(client) {
  const { telemetryEventStore } = client;
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(dnsCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification, {
      permissive: true
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  const telemetry2 = new DnsTelemetryClient({
    opts: {
      store: telemetryEventStore
    }
  });
  const { subcommand, subcommandOriginal, args } = getSubcommand2(
    parsedArgs.args.slice(1),
    COMMAND_CONFIG6
  );
  const needHelp = parsedArgs.flags["--help"];
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp("dns", subcommand);
    output_manager_default.print(help(dnsCommand, { columns: client.stderr.columns }));
    return 2;
  }
  function printHelp(command) {
    output_manager_default.print(
      help(command, { parent: dnsCommand, columns: client.stderr.columns })
    );
  }
  switch (subcommand) {
    case "add":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("dns", subcommandOriginal);
        printHelp(addSubcommand2);
        return 2;
      }
      telemetry2.trackCliSubcommandAdd(subcommandOriginal);
      return add2(client, args);
    case "import":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("dns", subcommandOriginal);
        printHelp(importSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandImport(subcommandOriginal);
      return importZone(client, args);
    case "rm":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("dns", subcommandOriginal);
        printHelp(removeSubcommand3);
        return 2;
      }
      telemetry2.trackCliSubcommandRemove(subcommandOriginal);
      return rm3(client, args);
    default:
      if (needHelp) {
        telemetry2.trackCliFlagHelp("dns", subcommandOriginal);
        printHelp(listSubcommand4);
        return 2;
      }
      telemetry2.trackCliSubcommandList(subcommandOriginal);
      return ls3(client, args);
  }
}

// src/commands/domains/add.ts
var import_chalk34 = __toESM(require_source(), 1);

// src/util/format-ns-table.ts
var import_chalk31 = __toESM(require_source(), 1);

// src/util/output/chars.ts
var chars = {
  tick: process.platform === "win32" ? "\u221A" : "\u2714",
  cross: process.platform === "win32" ? "\u2613" : "\u2718"
};
var chars_default = chars;

// src/util/format-ns-table.ts
function formatNSTable(intendedNameservers, currentNameservers, { extraSpace = "" } = {}) {
  const sortedIntended = intendedNameservers.sort();
  const sortedCurrent = currentNameservers.sort();
  const maxLength = Math.max(
    intendedNameservers.length,
    currentNameservers.length
  );
  const rows = [];
  for (let i = 0; i < maxLength; i++) {
    rows.push([
      sortedIntended[i] || import_chalk31.default.gray("-"),
      sortedCurrent[i] || import_chalk31.default.gray("-"),
      sortedIntended[i] === sortedCurrent[i] ? import_chalk31.default.green(chars_default.tick) : import_chalk31.default.red(chars_default.cross)
    ]);
  }
  return table(
    [
      [
        import_chalk31.default.gray("Intended Nameservers"),
        import_chalk31.default.gray("Current Nameservers"),
        ""
      ],
      ...rows
    ],
    { hsep: 4 }
  ).replace(/^(.*)/gm, `${extraSpace}$1`);
}

// src/util/domains/is-public-suffix.ts
function isPublicSuffix(domainName) {
  return domainName.endsWith(".vercel.app") || domainName.endsWith(".now.sh");
}

// src/util/domains/get-domain-config.ts
async function getDomainConfig(client, domainName) {
  try {
    const config = await client.fetch(
      `/v4/domains/${domainName}/config`
    );
    return config;
  } catch (err) {
    if (isAPIError(err) && err.status < 500) {
      return err;
    }
    throw err;
  }
}

// src/util/projects/add-domain-to-project.ts
var import_chalk32 = __toESM(require_source(), 1);
async function addDomainToProject(client, projectNameOrId, domain) {
  output_manager_default.spinner(
    `Adding domain ${domain} to project ${import_chalk32.default.bold(projectNameOrId)}`
  );
  try {
    const response = await client.fetch(
      `/projects/${encodeURIComponent(projectNameOrId)}/alias`,
      {
        method: "POST",
        body: JSON.stringify({
          target: "PRODUCTION",
          domain
        })
      }
    );
    const aliasTarget = response.find(
      (aliasTarget2) => aliasTarget2.domain === domain
    );
    if (!aliasTarget) {
      throw new Error(
        `Unexpected error when adding the domain "${domain}" to project "${projectNameOrId}".`
      );
    }
    return aliasTarget;
  } catch (err) {
    if (isAPIError(err) && err.status < 500) {
      return err;
    }
    throw err;
  }
}

// src/util/projects/remove-domain-from-project.ts
var import_chalk33 = __toESM(require_source(), 1);
async function removeDomainFromProject(client, projectNameOrId, domain) {
  output_manager_default.spinner(
    `Removing domain ${domain} from project ${import_chalk33.default.bold(projectNameOrId)}`
  );
  try {
    const response = await client.fetch(
      `/projects/${encodeURIComponent(
        projectNameOrId
      )}/alias?domain=${encodeURIComponent(domain)}`,
      {
        method: "DELETE"
      }
    );
    return response;
  } catch (err) {
    if (isAPIError(err) && err.status < 500) {
      return err;
    }
    throw err;
  }
}

// src/util/telemetry/commands/domains/add.ts
var DomainsAddTelemetryClient = class extends TelemetryClient {
  trackCliFlagForce(force) {
    if (force) {
      this.trackCliFlag("force");
    }
  }
  trackCliArgumentDomain(domainName) {
    if (domainName) {
      this.trackCliArgument({
        arg: "domain",
        value: this.redactedValue
      });
    }
  }
  trackCliArgumentProject(projectName) {
    if (projectName) {
      this.trackCliArgument({
        arg: "project",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/domains/add.ts
async function add3(client, argv) {
  const telemetry2 = new DomainsAddTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(addSubcommand3.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  const force = opts["--force"];
  telemetry2.trackCliFlagForce(force);
  const { contextName } = await getScope(client);
  const project = await getLinkedProject(client).then((result) => {
    if (result.status === "linked") {
      return result.project;
    }
    return null;
  });
  if (project && args.length !== 1) {
    output_manager_default.error(
      `${getCommandName("domains add <domain>")} expects one argument.`
    );
    return 1;
  }
  if (!project && args.length !== 2) {
    output_manager_default.error(
      `${getCommandName(
        "domains add <domain> <project>"
      )} expects two arguments.`
    );
    return 1;
  }
  const domainName = String(args[0]);
  const projectName = project ? project.name : String(args[1]);
  telemetry2.trackCliArgumentDomain(domainName);
  telemetry2.trackCliArgumentProject(args[1]);
  const addStamp = stamp_default();
  let aliasTarget = await addDomainToProject(client, projectName, domainName);
  if (aliasTarget instanceof Error) {
    if (aliasTarget instanceof APIError && aliasTarget.code === "ALIAS_DOMAIN_EXIST" && aliasTarget.project && aliasTarget.project.id) {
      if (force) {
        const removeResponse = await removeDomainFromProject(
          client,
          aliasTarget.project.id,
          domainName
        );
        if (removeResponse instanceof Error) {
          output_manager_default.prettyError(removeResponse);
          return 1;
        }
        aliasTarget = await addDomainToProject(client, projectName, domainName);
      }
    }
    if (aliasTarget instanceof Error) {
      output_manager_default.prettyError(aliasTarget);
      return 1;
    }
  }
  output_manager_default.success(
    `Domain ${import_chalk34.default.bold(domainName)} added to project ${import_chalk34.default.bold(
      projectName
    )}. ${addStamp()}`
  );
  if (isPublicSuffix(domainName)) {
    output_manager_default.log(
      "The domain will automatically get assigned to your latest production deployment."
    );
    return 0;
  }
  const domainResponse = await getDomain(client, contextName, domainName);
  if (domainResponse instanceof Error) {
    output_manager_default.prettyError(domainResponse);
    return 1;
  }
  const domainConfig = await getDomainConfig(client, domainName);
  if (domainConfig.misconfigured) {
    output_manager_default.warn(
      "This domain is not configured properly. To configure it you should either:"
    );
    output_manager_default.print(
      `  ${import_chalk34.default.grey("a)")} Set the following record on your DNS provider to continue: ${code(`A ${domainName} 76.76.21.21`)} ${import_chalk34.default.grey("[recommended]")}
`
    );
    output_manager_default.print(
      `  ${import_chalk34.default.grey("b)")} Change your Domains's nameservers to the intended set`
    );
    output_manager_default.print(
      `
${formatNSTable(
        domainResponse.intendedNameservers,
        domainResponse.nameservers,
        { extraSpace: "     " }
      )}

`
    );
    output_manager_default.print(
      "  We will run a verification for you and you will receive an email upon completion.\n"
    );
    output_manager_default.print("  Read more: https://vercel.link/domain-configuration\n\n");
  } else {
    output_manager_default.log(
      "The domain will automatically get assigned to your latest production deployment."
    );
  }
  return 0;
}

// src/commands/domains/buy.ts
var import_chalk35 = __toESM(require_source(), 1);
var import_tldts4 = __toESM(require_cjs(), 1);
var import_error_utils4 = __toESM(require_dist(), 1);

// src/util/telemetry/commands/domains/buy.ts
var DomainsBuyTelemetryClient = class extends TelemetryClient {
  trackCliArgumentDomain(v) {
    if (v) {
      this.trackCliArgument({
        arg: "domain",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/domains/buy.ts
async function buy(client, argv) {
  const telemetry2 = new DomainsBuyTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(buySubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args } = parsedArgs;
  const [domainName] = args;
  const skipConfirmation = !!process.env.CI;
  telemetry2.trackCliArgumentDomain(domainName);
  if (!domainName) {
    output_manager_default.error(
      `Missing domain name. Run ${getCommandName(`domains --help`)}`
    );
    return 1;
  }
  const { contextName } = await getScope(client);
  const parsedDomain = (0, import_tldts4.parse)(domainName);
  const { domain: rootDomain, subdomain } = parsedDomain;
  if (subdomain || !rootDomain) {
    output_manager_default.error(
      `Invalid domain name "${domainName}". Run ${getCommandName(
        `domains --help`
      )}`
    );
    return 1;
  }
  const availableStamp = stamp_default();
  const domainPrice = await getDomainPrice(client, domainName);
  if (domainPrice instanceof Error) {
    output_manager_default.prettyError(domainPrice);
    return 1;
  }
  const { years, purchasePrice, renewalPrice } = domainPrice;
  if (purchasePrice === null || renewalPrice === null) {
    output_manager_default.error("Domain price not found");
    return 1;
  }
  if (!(await getDomainStatus(client, domainName)).available) {
    output_manager_default.error(
      `The domain ${param(domainName)} is ${import_chalk35.default.underline(
        "unavailable"
      )}! ${availableStamp()}`
    );
    return 1;
  }
  output_manager_default.log(
    `The domain ${param(domainName)} is ${import_chalk35.default.underline(
      "available"
    )} to buy under ${import_chalk35.default.bold(contextName)}! ${availableStamp()}`
  );
  if (skipConfirmation) {
    output_manager_default.error(
      "Domain purchase in CI mode is not supported. Please run this command interactively to provide contact information."
    );
    return 1;
  }
  if (!await client.input.confirm(
    `Buy now for ${import_chalk35.default.bold(`$${purchasePrice}`)} (${`${years}yr${years > 1 ? "s" : ""}`})?`,
    false
  )) {
    return 0;
  }
  const autoRenew = await client.input.confirm(
    years === 1 ? `Auto renew yearly for ${import_chalk35.default.bold(`$${renewalPrice}`)}?` : `Auto renew every ${years} years for ${import_chalk35.default.bold(
      `$${renewalPrice}`
    )}?`,
    true
  );
  const contactInformation = await collectContactInformation(client);
  let buyResult;
  const purchaseStamp = stamp_default();
  output_manager_default.spinner("Purchasing");
  try {
    buyResult = await purchaseDomain(
      client,
      domainName,
      purchasePrice,
      years,
      autoRenew,
      contactInformation
    );
  } catch (err) {
    output_manager_default.error(
      "An unexpected error occurred while purchasing your domain. Please try again later."
    );
    output_manager_default.debug(`Server response: ${(0, import_error_utils4.errorToString)(err)}`);
    return 1;
  }
  output_manager_default.stopSpinner();
  if (buyResult instanceof UnsupportedTLD) {
    output_manager_default.error(
      `The TLD for domain name ${buyResult.meta.domain} is not supported.`
    );
    return 1;
  }
  if (buyResult instanceof TLDNotSupportedViaCLI) {
    output_manager_default.error(
      `Purchased for the TLD for domain name ${buyResult.meta.domain} are not supported via the CLI. Use the REST API or the dashboard to purchase.`
    );
    return 1;
  }
  if (buyResult instanceof InvalidDomain) {
    output_manager_default.error(`The domain ${buyResult.meta.domain} is not valid.`);
    return 1;
  }
  if (buyResult instanceof DomainNotAvailable) {
    output_manager_default.error(`The domain ${buyResult.meta.domain} is not available.`);
    return 1;
  }
  if (buyResult instanceof UnexpectedDomainPurchaseError) {
    output_manager_default.error(`An unexpected error happened while performing the purchase.`);
    return 1;
  }
  if (buyResult instanceof DomainPaymentError) {
    output_manager_default.error(`Your card was declined.`);
    return 1;
  }
  output_manager_default.success(`Domain ${param(domainName)} purchased ${purchaseStamp()}`);
  output_manager_default.note(
    `You may now use your domain as an alias to your deployments. Run ${getCommandName(
      `alias --help`
    )}`
  );
  return 0;
}

// src/commands/domains/transfer-in.ts
var import_chalk36 = __toESM(require_source(), 1);

// src/util/domains/transfer-in-domain.ts
async function transferInDomain(client, name, authCode, expectedPrice, years) {
  const { team } = await getScope(client);
  const teamParam = team ? `?teamId=${team.slug}` : "";
  try {
    const { orderId } = await client.fetch(
      `/v1/registrar/domains/${name}/transfer${teamParam}`,
      {
        body: {
          authCode,
          autoRenew: true,
          years,
          expectedPrice,
          contactInformation: {
            firstName: "Vercel",
            lastName: "Whois",
            email: "domains@registrar.vercel.com",
            phone: "+14153985463",
            address1: "100 First Street, Suite 2400",
            city: "San Fransisco",
            state: "CA",
            zip: "94105",
            country: "US",
            companyName: "Vercel Inc."
          }
        },
        method: "POST"
      }
    );
    const order = await pollForOrder(client, orderId);
    if (order === null) {
      return new UnexpectedDomainTransferError(name);
    }
    if (order.status === "completed") {
      const domain = order.domains.find((domain2) => domain2.domainName === name);
      if (domain?.status === "completed") {
        return { ok: true };
      }
    }
    if (order.error?.code === "payment_failed") {
      return new DomainPaymentError();
    }
    return new UnexpectedDomainTransferError(name);
  } catch (err) {
    if (isAPIError(err)) {
      if (err.code === "invalid_name") {
        return new InvalidDomain(name);
      }
      if (err.code === "tld_not_supported") {
        return new UnsupportedTLD(name);
      }
      if (err.code === "domain_not_available") {
        return new DomainNotAvailable(name);
      }
    }
    throw err;
  }
}

// src/util/domains/get-auth-code.ts
async function getAuthCode(client, code2) {
  if (isValidAuthCode(code2)) {
    return code2;
  }
  return client.input.text({
    message: `- Transfer auth code: `,
    validate: isValidAuthCode
  });
}
function isValidAuthCode(code2) {
  return !!(code2 && code2.length > 0);
}

// src/util/is-root-domain.ts
var import_tldts5 = __toESM(require_cjs(), 1);
function isRootDomain(domainName) {
  const parsedDomain = (0, import_tldts5.parse)(domainName);
  const { domain: rootDomain, subdomain } = parsedDomain;
  return Boolean(!subdomain && rootDomain);
}

// src/util/telemetry/commands/domains/transfer-in.ts
var DomainsTransferInTelemetryClient = class extends TelemetryClient {
  trackCliOptionCode(code2) {
    if (code2) {
      this.trackCliOption({
        option: "code",
        value: this.redactedValue
      });
    }
  }
  trackCliArgumentDomain(domainName) {
    if (domainName) {
      this.trackCliArgument({
        arg: "domain",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/domains/transfer-in.ts
async function transferIn(client, argv) {
  const telemetry2 = new DomainsTransferInTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(
    transferInSubcommand.options
  );
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  telemetry2.trackCliOptionCode(opts["--code"]);
  const [domainName] = args;
  if (!domainName) {
    output_manager_default.error(
      `Missing domain name. Run ${getCommandName(`domains --help`)}`
    );
    return 1;
  }
  telemetry2.trackCliArgumentDomain(domainName);
  if (!isRootDomain(domainName)) {
    output_manager_default.error(
      `Invalid domain name ${param(domainName)}. Run ${getCommandName(
        `domains --help`
      )}`
    );
    return 1;
  }
  const availableStamp = stamp_default();
  const domainPrice = await getDomainPrice(client, domainName);
  if (domainPrice instanceof Error) {
    output_manager_default.prettyError(domainPrice);
    return 1;
  }
  const { transferPrice, years } = domainPrice;
  if (transferPrice === null) {
    output_manager_default.error(`The domain ${param(domainName)} is not transferable.`);
    return 1;
  }
  const { contextName } = await getScope(client);
  output_manager_default.log(
    `The domain ${param(domainName)} is ${import_chalk36.default.underline(
      "available"
    )} to transfer under ${import_chalk36.default.bold(contextName)}! ${availableStamp()}`
  );
  const authCode = await getAuthCode(client, opts["--code"]);
  const shouldTransfer = await client.input.confirm(
    `Transfer now with 1yr renewal for ${import_chalk36.default.bold(`$${transferPrice}`)}?`,
    false
  );
  if (!shouldTransfer) {
    return 0;
  }
  const transferStamp = stamp_default();
  output_manager_default.spinner(`Initiating transfer for domain ${domainName}`);
  const transferInResult = await transferInDomain(
    client,
    domainName,
    authCode,
    transferPrice,
    years
  );
  if (transferInResult instanceof InvalidDomain) {
    output_manager_default.error(`The domain ${transferInResult.meta.domain} is not valid.`);
    return 1;
  }
  if (transferInResult instanceof DomainNotAvailable) {
    output_manager_default.error(
      `The domain "${transferInResult.meta.domain}" is not transferable.`
    );
    return 1;
  }
  if (transferInResult instanceof UnsupportedTLD) {
    output_manager_default.error(
      `The TLD for domain name ${transferInResult.meta.domain} is not supported.`
    );
    return 1;
  }
  if (transferInResult instanceof DomainPaymentError) {
    output_manager_default.error(`Your card was declined.`);
    return 1;
  }
  if (transferInResult instanceof UnexpectedDomainTransferError) {
    output_manager_default.error(`An unexpected error happened while initiating the transfer.`);
    return 1;
  }
  output_manager_default.success(
    `Domain ${param(domainName)} transfer started ${transferStamp()}`
  );
  output_manager_default.print(
    `  To finalize the transfer, we are waiting for approval from your current registrar.
`
  );
  output_manager_default.print(`  You will receive an email upon completion.
`);
  output_manager_default.warn(
    `Once transferred, your domain ${param(
      domainName
    )} will be using Vercel DNS.
`
  );
  output_manager_default.print(
    `  To transfer with previous DNS records, export the zone file from your previous registrar.
`
  );
  output_manager_default.print(`  Then import it to Vercel DNS by using:
`);
  output_manager_default.print(
    `    ${getCommandName(`dns import ${domainName} <zonefile>`)}

`
  );
  return 0;
}

// src/commands/domains/inspect.ts
var import_chalk37 = __toESM(require_source(), 1);

// src/util/projects/find-projects-for-domain.ts
async function findProjectsForDomain(client, domainName) {
  try {
    const result = [];
    for await (const chunk of client.fetchPaginated(
      "/v9/projects"
    )) {
      for (const project of chunk.projects) {
        if (project.targets?.production?.alias?.some?.(
          (alias2) => alias2.endsWith(domainName)
        )) {
          result.push(project);
        }
      }
    }
    return result;
  } catch (err) {
    if (isAPIError(err) && err.status < 500) {
      return err;
    }
    throw err;
  }
}

// src/util/domains/get-domain-registrar.ts
function getDomainRegistrar(domain) {
  if (domain.boughtAt) {
    return "Vercel";
  }
  if (typeof domain.orderedAt === "number" && !domain.boughtAt) {
    return "Purchase in Process";
  }
  return "Third Party";
}

// src/util/telemetry/commands/domains/inspect.ts
var DomainsInspectTelemetryClient = class extends TelemetryClient {
  trackCliArgumentDomain(name) {
    if (name) {
      this.trackCliArgument({
        arg: "domain",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/domains/inspect.ts
async function inspect(client, argv) {
  const telemetry2 = new DomainsInspectTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(inspectSubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args } = parsedArgs;
  const [domainName] = args;
  const inspectStamp = stamp_default();
  if (!domainName) {
    output_manager_default.error(
      `${getCommandName(`domains inspect <domain>`)} expects one argument`
    );
    return 1;
  }
  telemetry2.trackCliArgumentDomain(domainName);
  if (args.length !== 1) {
    output_manager_default.error(
      `Invalid number of arguments. Usage: ${import_chalk37.default.cyan(
        `${getCommandName("domains inspect <domain>")}`
      )}`
    );
    return 1;
  }
  output_manager_default.debug(`Fetching domain info`);
  const { contextName } = await getScope(client);
  output_manager_default.spinner(
    `Fetching Domain ${domainName} under ${import_chalk37.default.bold(contextName)}`
  );
  const information = await fetchInformation({
    client,
    contextName,
    domainName
  });
  if (typeof information === "number") {
    return information;
  }
  const { domain, projects, renewalPrice, domainConfig } = information;
  output_manager_default.log(
    `Domain ${domainName} found under ${import_chalk37.default.bold(contextName)} ${import_chalk37.default.gray(
      inspectStamp()
    )}`
  );
  output_manager_default.print("\n");
  output_manager_default.print(import_chalk37.default.bold("  General\n\n"));
  output_manager_default.print(`    ${import_chalk37.default.cyan("Name")}			${domain.name}
`);
  output_manager_default.print(
    `    ${import_chalk37.default.cyan("Registrar")}			${getDomainRegistrar(domain)}
`
  );
  output_manager_default.print(
    `    ${import_chalk37.default.cyan("Expiration Date")}		${formatDate(domain.expiresAt)}
`
  );
  output_manager_default.print(
    `    ${import_chalk37.default.cyan("Creator")}			${domain.creator.username}
`
  );
  output_manager_default.print(
    `    ${import_chalk37.default.cyan("Created At")}			${formatDate(domain.createdAt)}
`
  );
  output_manager_default.print(`    ${import_chalk37.default.cyan("Edge Network")}		yes
`);
  output_manager_default.print(
    `    ${import_chalk37.default.cyan("Renewal Price")}		${domain.boughtAt && renewalPrice ? `$${renewalPrice} USD` : import_chalk37.default.gray("-")}
`
  );
  output_manager_default.print("\n");
  output_manager_default.print(import_chalk37.default.bold("  Nameservers\n\n"));
  output_manager_default.print(
    `${formatNSTable(domain.intendedNameservers, domain.nameservers, {
      extraSpace: "    "
    })}
`
  );
  output_manager_default.print("\n");
  if (Array.isArray(projects) && projects.length > 0) {
    output_manager_default.print(import_chalk37.default.bold("  Projects\n"));
    const table3 = formatTable(
      ["Project", "Domains"],
      ["l", "l"],
      [
        {
          rows: projects.map((project) => {
            const name = project.name;
            const domains2 = (project.targets?.production?.alias || []).filter(
              (alias2) => alias2.endsWith(domainName)
            );
            const cols = domains2.length ? domains2.join(", ") : "-";
            return [name, cols];
          })
        }
      ]
    );
    output_manager_default.print(
      table3.split("\n").map((line) => `   ${line}`).join("\n")
    );
    output_manager_default.print("\n");
  }
  if (domainConfig.misconfigured) {
    output_manager_default.warn(
      `This Domain is not configured properly. To configure it you should either:`,
      null,
      null,
      null
    );
    output_manager_default.print(
      `  ${import_chalk37.default.grey("a)")} Set the following record on your DNS provider to continue: ${code(`A ${domainName} 76.76.21.21`)} ${import_chalk37.default.grey("[recommended]")}
`
    );
    output_manager_default.print(
      `  ${import_chalk37.default.grey("b)")} Change your Domains's nameservers to the intended set detailed above.

`
    );
    output_manager_default.print(
      `  We will run a verification for you and you will receive an email upon completion.
`
    );
    const contextNameConst = contextName;
    const projectNames = Array.from(
      new Set(projects.map((project) => project.name))
    );
    if (projectNames.length) {
      projectNames.forEach((name, index) => {
        const prefix = index === 0 ? "  Read more:" : " ".repeat(12);
        output_manager_default.print(
          `${prefix} https://vercel.com/${contextNameConst}/${name}/settings/domains
`
        );
      });
    } else {
      output_manager_default.print(`  Read more: https://vercel.link/domain-configuration
`);
    }
    output_manager_default.print("\n");
  }
  return null;
}
async function fetchInformation({
  client,
  contextName,
  domainName
}) {
  const [domain, renewalPrice] = await Promise.all([
    getDomainByName(client, contextName, domainName, { ignoreWait: true }),
    getDomainPrice(client, domainName).then((res) => res instanceof Error ? null : res.renewalPrice).catch(() => null)
  ]);
  if (domain instanceof DomainNotFound) {
    output_manager_default.prettyError(domain);
    return 1;
  }
  if (domain instanceof DomainPermissionDenied) {
    output_manager_default.prettyError(domain);
    output_manager_default.log(`Run ${getCommandName(`domains ls`)} to see your domains.`);
    return 1;
  }
  const projects = await findProjectsForDomain(client, domainName);
  if (projects instanceof Error) {
    output_manager_default.prettyError(projects);
    return 1;
  }
  const domainConfig = await getDomainConfig(client, domainName);
  return {
    domain,
    projects,
    renewalPrice,
    domainConfig
  };
}

// src/commands/domains/ls.ts
var import_ms10 = __toESM(require_ms(), 1);
var import_chalk38 = __toESM(require_source(), 1);
var import_pluralize5 = __toESM(require_pluralize(), 1);

// src/util/telemetry/commands/domains/ls.ts
var DomainsLsTelemetryClient = class extends TelemetryClient {
  trackCliOptionLimit(limit) {
    if (limit) {
      this.trackCliOption({
        option: "limit",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionNext(next) {
    if (next) {
      this.trackCliOption({
        option: "next",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/domains/ls.ts
async function ls4(client, argv) {
  const telemetry2 = new DomainsLsTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(listSubcommand5.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  const validationResult = validateLsArgs({
    commandName: "domains ls",
    args,
    maxArgs: 0,
    exitCode: 2
  });
  if (validationResult !== 0) {
    return validationResult;
  }
  telemetry2.trackCliOptionLimit(opts["--limit"]);
  telemetry2.trackCliOptionNext(opts["--next"]);
  telemetry2.trackCliOptionFormat(opts["--format"]);
  const formatResult = validateJsonOutput(opts);
  if (!formatResult.valid) {
    output_manager_default.error(formatResult.error);
    return 1;
  }
  const asJson = formatResult.jsonOutput;
  let paginationOptions;
  try {
    paginationOptions = getPaginationOpts(opts);
  } catch (err) {
    output_manager_default.prettyError(err);
    return 1;
  }
  const { contextName } = await getScope(client);
  const lsStamp = stamp_default();
  output_manager_default.spinner(`Fetching Domains under ${import_chalk38.default.bold(contextName)}`);
  const { domains: domains2, pagination } = await getDomains(
    client,
    ...paginationOptions
  );
  if (asJson) {
    output_manager_default.stopSpinner();
    const jsonOutput = {
      domains: domains2.map((domain) => ({
        name: domain.name,
        registrar: getDomainRegistrar(domain),
        nameservers: isDomainExternal(domain) ? "external" : "vercel",
        expiresAt: domain.expiresAt,
        createdAt: domain.createdAt,
        creator: domain.creator.username
      })),
      pagination
    };
    client.stdout.write(`${JSON.stringify(jsonOutput, null, 2)}
`);
  } else {
    output_manager_default.log(
      `${(0, import_pluralize5.default)("Domain", domains2.length, true)} found under ${import_chalk38.default.bold(
        contextName
      )} ${import_chalk38.default.gray(lsStamp())}`
    );
    if (domains2.length > 0) {
      output_manager_default.print(
        formatDomainsTable(domains2).replace(/^(.*)/gm, `${" ".repeat(1)}$1`)
      );
      output_manager_default.print("\n\n");
    }
    if (pagination && pagination.count === 20) {
      const flags = getCommandFlags(opts, ["_", "--next", "--format"]);
      output_manager_default.log(
        `To display the next page, run ${getCommandName(
          `domains ls${flags} --next ${pagination.next}`
        )}`
      );
    }
  }
  return 0;
}
function formatDomainsTable(domains2) {
  const current = Date.now();
  const rows = domains2.map((domain) => {
    const expiration = formatDateWithoutTime(domain.expiresAt);
    const age = domain.createdAt ? (0, import_ms10.default)(current - domain.createdAt) : "-";
    return [
      domain.name,
      getDomainRegistrar(domain),
      isDomainExternal(domain) ? "Third Party" : "Vercel",
      expiration,
      domain.creator.username,
      import_chalk38.default.gray(age)
    ];
  });
  return formatTable(
    ["Domain", "Registrar", "Nameservers", "Expiration Date", "Creator", "Age"],
    ["l", "l", "l", "l", "l", "l"],
    [{ rows }]
  );
}

// src/commands/domains/rm.ts
var import_chalk39 = __toESM(require_source(), 1);
var import_pluralize6 = __toESM(require_pluralize(), 1);

// src/util/domains/remove-domain-by-name.ts
async function removeDomainByName(now, contextName, domain) {
  try {
    return await now.fetch(`/v3/domains/${encodeURIComponent(domain)}`, {
      method: "DELETE"
    });
  } catch (err) {
    if (isAPIError(err)) {
      if (err.code === "not_found") {
        return new DomainNotFound(domain);
      }
      if (err.code === "forbidden") {
        return new DomainPermissionDenied(domain, contextName);
      }
      if (err.code === "domain_removal_conflict") {
        return new DomainRemovalConflict({
          aliases: err.aliases,
          certs: err.certs,
          message: err.message,
          pendingAsyncPurchase: err.pendingAsyncPurchase,
          resolvable: err.resolvable,
          suffix: err.suffix,
          transferring: err.transferring
        });
      }
    }
    throw err;
  }
}

// src/util/domains/set-custom-suffix.ts
async function setCustomSuffix(client, contextName, domain, suffix) {
  try {
    return await client.fetch(`/v1/custom-suffix`, {
      method: "PATCH",
      body: {
        suffix
      }
    });
  } catch (err) {
    if (isAPIError(err)) {
      if (err.code === "forbidden") {
        return new DomainPermissionDenied(domain, contextName);
      }
      if (err.code === "domain_external") {
        return new DomainExternal(domain);
      }
      if (err.code === "domain_invalid") {
        return new InvalidDomain(domain);
      }
      if (err.code === "domain_not_found") {
        return new DomainNotFound(domain);
      }
      if (err.code === "domain_not_verified") {
        return new DomainNotVerified(domain);
      }
      if (err.code === "domain_permission_denied") {
        return new DomainPermissionDenied(domain, contextName);
      }
    }
    throw err;
  }
}

// src/util/telemetry/commands/domains/rm.ts
var DomainsRmTelemetryClient = class extends TelemetryClient {
  trackCliArgumentDomain(v) {
    if (v) {
      this.trackCliArgument({
        arg: "domain",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagYes(v) {
    if (v) {
      this.trackCliFlag("yes");
    }
  }
};

// src/commands/domains/rm.ts
async function rm4(client, argv) {
  const telemetry2 = new DomainsRmTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(removeSubcommand4.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  const [domainName] = args;
  telemetry2.trackCliArgumentDomain(domainName);
  telemetry2.trackCliFlagYes(opts["--yes"]);
  if (!domainName) {
    output_manager_default.error(
      `${getCommandName(`domains rm <domain>`)} expects one argument`
    );
    return 1;
  }
  const { contextName } = await getScope(client);
  if (args.length !== 1) {
    output_manager_default.error(
      `Invalid number of arguments. Usage: ${import_chalk39.default.cyan(
        `${getCommandName("domains rm <domain>")}`
      )}`
    );
    return 1;
  }
  const domain = await getDomainByName(client, contextName, domainName);
  if (domain instanceof DomainNotFound || domain.name !== domainName) {
    output_manager_default.error(
      `Domain not found by "${domainName}" under ${import_chalk39.default.bold(contextName)}`
    );
    output_manager_default.log(`Run ${getCommandName(`domains ls`)} to see your domains.`);
    return 1;
  }
  if (domain instanceof DomainPermissionDenied) {
    output_manager_default.error(
      `You don't have access to the domain ${domainName} under ${import_chalk39.default.bold(
        contextName
      )}`
    );
    output_manager_default.log(`Run ${getCommandName(`domains ls`)} to see your domains.`);
    return 1;
  }
  const projects = await findProjectsForDomain(client, domain.name);
  if (Array.isArray(projects) && projects.length > 0) {
    output_manager_default.warn(
      `The domain is currently used by ${(0, import_pluralize6.default)(
        "project",
        projects.length,
        true
      )}.`
    );
  }
  const skipConfirmation = opts["--yes"] || false;
  if (!skipConfirmation && !await client.input.confirm(
    `Are you sure you want to remove ${param(domainName)}?`,
    false
  )) {
    output_manager_default.log("Canceled");
    return 0;
  }
  return removeDomain(client, contextName, skipConfirmation, domain);
}
async function removeDomain(client, contextName, skipConfirmation, domain, aliasIds = [], certIds = [], suffix = false, attempt = 1) {
  const removeStamp = stamp_default();
  output_manager_default.debug(`Removing domain`);
  for (const id of aliasIds) {
    output_manager_default.debug(`Removing alias ${id}`);
    try {
      await removeAliasById(client, id);
    } catch (err) {
      if (!isAPIError(err) || err.status !== 404) {
        throw err;
      }
    }
  }
  for (const id of certIds) {
    output_manager_default.debug(`Removing cert ${id}`);
    try {
      await deleteCertById(client, id);
    } catch (err) {
      if (!isAPIError(err) || err.status !== 404) {
        throw err;
      }
    }
  }
  if (suffix) {
    output_manager_default.debug(`Removing custom suffix`);
    await setCustomSuffix(client, contextName, domain.name, null);
  }
  const removeResult = await removeDomainByName(
    client,
    contextName,
    domain.name
  );
  if (removeResult instanceof DomainNotFound) {
    output_manager_default.error(`Domain not found under ${import_chalk39.default.bold(contextName)}`);
    output_manager_default.log(`Run ${getCommandName(`domains ls`)} to see your domains.`);
    return 1;
  }
  if (removeResult instanceof DomainPermissionDenied) {
    output_manager_default.error(
      `You don't have permissions over domain ${import_chalk39.default.underline(
        removeResult.meta.domain
      )} under ${import_chalk39.default.bold(removeResult.meta.context)}.`
    );
    return 1;
  }
  if (removeResult instanceof DomainRemovalConflict) {
    if (attempt >= 2) {
      output_manager_default.error(removeResult.message);
      return 1;
    }
    const {
      aliases,
      certs,
      suffix: suffix2,
      transferring,
      pendingAsyncPurchase,
      resolvable
    } = removeResult.meta;
    if (transferring) {
      output_manager_default.error(
        `${param(
          domain.name
        )} transfer should be declined or approved before removing.`
      );
      return 1;
    }
    if (pendingAsyncPurchase) {
      output_manager_default.error(
        `Cannot remove ${param(
          domain.name
        )} because it is still in the process of being purchased.`
      );
      return 1;
    }
    if (!resolvable) {
      output_manager_default.error(removeResult.message);
      return 1;
    }
    output_manager_default.log(
      `We found conflicts when attempting to remove ${param(domain.name)}.`
    );
    if (aliases.length > 0) {
      output_manager_default.warn(
        `This domain's ${import_chalk39.default.bold(
          (0, import_pluralize6.default)("alias", aliases.length, true)
        )} will be removed. Run ${getCommandName(`alias ls`)} to list them.`
      );
    }
    if (certs.length > 0) {
      output_manager_default.warn(
        `This domain's ${import_chalk39.default.bold(
          (0, import_pluralize6.default)("certificate", certs.length, true)
        )} will be removed. Run ${getCommandName(`cert ls`)} to list them.`
      );
    }
    if (suffix2) {
      output_manager_default.warn(
        `The ${import_chalk39.default.bold(`custom suffix`)} associated with this domain.`
      );
    }
    if (!skipConfirmation && !await client.input.confirm(
      `Remove conflicts associated with domain?`,
      false
    )) {
      output_manager_default.log("Canceled");
      return 0;
    }
    return removeDomain(
      client,
      contextName,
      skipConfirmation,
      domain,
      aliases,
      certs,
      suffix2,
      attempt + 1
    );
  }
  output_manager_default.success(`Domain ${import_chalk39.default.bold(domain.name)} removed ${removeStamp()}`);
  return 0;
}

// src/commands/domains/move.ts
var import_chalk40 = __toESM(require_source(), 1);
var import_pluralize7 = __toESM(require_pluralize(), 1);

// src/util/domains/move-out-domain.ts
async function moveOutDomain(client, contextName, name, destination) {
  try {
    return await client.fetch(
      `/v4/domains/${encodeURIComponent(name)}`,
      {
        body: { op: "move-out", destination },
        method: "PATCH"
      }
    );
  } catch (err) {
    if (isAPIError(err)) {
      if (err.code === "forbidden") {
        return new DomainPermissionDenied(name, contextName);
      }
      if (err.code === "not_found") {
        return new DomainNotFound(name);
      }
      if (err.code === "invalid_move_destination") {
        return new InvalidMoveDestination(destination);
      }
      if (err.code === "domain_move_conflict") {
        const { pendingAsyncPurchase, resolvable, suffix, message } = err;
        return new DomainMoveConflict({
          message,
          pendingAsyncPurchase,
          resolvable,
          suffix
        });
      }
    }
    throw err;
  }
}

// src/util/alias/get-domain-aliases.ts
async function getDomainAliases(client, domain) {
  const { aliases } = await getAliases(client);
  return aliases.filter((alias2) => alias2.alias.endsWith(domain));
}

// src/util/telemetry/commands/domains/move.ts
var DomainsMoveTelemetryClient = class extends TelemetryClient {
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
  trackCliArgumentDomain(domainName) {
    if (domainName) {
      this.trackCliArgument({
        arg: "domain",
        value: this.redactedValue
      });
    }
  }
  trackCliArgumentDestination(destination) {
    if (destination) {
      this.trackCliArgument({
        arg: "destination",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/domains/move.ts
async function move(client, argv) {
  const telemetry2 = new DomainsMoveTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(moveSubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  telemetry2.trackCliFlagYes(opts["--yes"]);
  telemetry2.trackCliArgumentDomain(args[0]);
  telemetry2.trackCliArgumentDestination(args[1]);
  const { contextName, user } = await getScope(client);
  const { domainName, destination } = await getArgs(client, args);
  if (!isRootDomain(domainName)) {
    output_manager_default.error(
      `Invalid domain name "${domainName}". Run ${getCommandName(
        `domains --help`
      )}`
    );
    return 1;
  }
  const domain = await getDomainByName(client, contextName, domainName);
  if (domain instanceof DomainNotFound) {
    output_manager_default.error(`Domain not found under ${import_chalk40.default.bold(contextName)}`);
    output_manager_default.log(`Run ${getCommandName(`domains ls`)} to see your domains.`);
    return 1;
  }
  if (domain instanceof DomainPermissionDenied) {
    output_manager_default.error(
      `You don't have permissions over domain ${import_chalk40.default.underline(
        domain.meta.domain
      )} under ${import_chalk40.default.bold(domain.meta.context)}.`
    );
    return 1;
  }
  const teams2 = await getTeams(client);
  const matchId = await findDestinationMatch(destination, user, teams2);
  if (matchId && matchId === user.id && user.version === "northstar") {
    output_manager_default.error(`You may not move your domain to your user account.`);
    return 1;
  }
  if (!matchId && !opts["--yes"]) {
    output_manager_default.warn(
      `You're not a member of ${param(destination)}. ${param(
        destination
      )} will have 24 hours to accept your move request before it expires.`
    );
    if (!await client.input.confirm(
      `Are you sure you want to move ${param(domainName)} to ${param(
        destination
      )}?`,
      false
    )) {
      output_manager_default.log("Canceled");
      return 0;
    }
  }
  if (!opts["--yes"]) {
    const aliases = await getDomainAliases(client, domainName);
    if (aliases.length > 0) {
      output_manager_default.warn(
        `This domain's ${import_chalk40.default.bold(
          (0, import_pluralize7.default)("alias", aliases.length, true)
        )} will be removed. Run ${getCommandName(`alias ls`)} to list them.`
      );
      if (!await client.input.confirm(
        `Are you sure you want to move ${param(domainName)}?`,
        false
      )) {
        output_manager_default.log("Canceled");
        return 0;
      }
    }
  }
  const context = contextName;
  output_manager_default.spinner("Moving");
  const moveTokenResult = await moveOutDomain(
    client,
    context,
    domainName,
    matchId || destination
  );
  if (moveTokenResult instanceof DomainMoveConflict) {
    const { suffix, pendingAsyncPurchase } = moveTokenResult.meta;
    if (suffix) {
      output_manager_default.error(
        `Please remove custom suffix for ${param(domainName)} before moving out`
      );
      return 1;
    }
    if (pendingAsyncPurchase) {
      output_manager_default.error(
        `Cannot remove ${param(
          domain.name
        )} because it is still in the process of being purchased.`
      );
      return 1;
    }
    output_manager_default.error(moveTokenResult.message);
    return 1;
  }
  if (moveTokenResult instanceof DomainNotFound) {
    output_manager_default.error(`Domain not found under ${import_chalk40.default.bold(contextName)}`);
    output_manager_default.log(`Run ${getCommandName(`domains ls`)} to see your domains.`);
    return 1;
  }
  if (moveTokenResult instanceof DomainPermissionDenied) {
    output_manager_default.error(
      `You don't have permissions over domain ${import_chalk40.default.underline(
        moveTokenResult.meta.domain
      )} under ${import_chalk40.default.bold(moveTokenResult.meta.context)}.`
    );
    return 1;
  }
  if (moveTokenResult instanceof InvalidMoveDestination) {
    output_manager_default.error(
      `Destination ${import_chalk40.default.bold(
        destination
      )} is invalid. Please supply a valid username, email, team slug, user id, or team id.`
    );
    return 1;
  }
  const { moved } = moveTokenResult;
  if (moved) {
    output_manager_default.success(`${param(domainName)} was moved to ${param(destination)}.`);
  } else {
    output_manager_default.success(
      `Sent ${param(destination)} an email to approve the ${param(
        domainName
      )} move request.`
    );
  }
  return 0;
}
async function getArgs(client, args) {
  let [domainName, destination] = args;
  if (!domainName) {
    domainName = await client.input.text({
      message: `- Domain name: `,
      validate: isRootDomain
    });
  }
  if (!destination) {
    destination = await client.input.text({
      message: `- Destination: `,
      validate: (v) => Boolean(v && v.length > 0)
    });
  }
  return { domainName, destination };
}
async function findDestinationMatch(destination, user, teams2) {
  if (user.id === destination || user.username === destination) {
    return user.id;
  }
  for (const team of teams2) {
    if (team.id === destination || team.slug === destination) {
      return team.id;
    }
  }
  return null;
}

// src/util/telemetry/commands/domains/index.ts
var DomainsTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandAdd(actual) {
    this.trackCliSubcommand({
      subcommand: "add",
      value: actual
    });
  }
  trackCliSubcommandInspect(actual) {
    this.trackCliSubcommand({
      subcommand: "inspect",
      value: actual
    });
  }
  trackCliSubcommandMove(actual) {
    this.trackCliSubcommand({
      subcommand: "move",
      value: actual
    });
  }
  trackCliSubcommandBuy(actual) {
    this.trackCliSubcommand({
      subcommand: "buy",
      value: actual
    });
  }
  trackCliSubcommandRemove(actual) {
    this.trackCliSubcommand({
      subcommand: "remove",
      value: actual
    });
  }
  trackCliSubcommandTransferIn(actual) {
    this.trackCliSubcommand({
      subcommand: "transfer-in",
      value: actual
    });
  }
  trackCliSubcommandList(actual) {
    this.trackCliSubcommand({
      subcommand: "list",
      value: actual
    });
  }
};

// src/commands/domains/index.ts
var COMMAND_CONFIG7 = {
  add: ["add"],
  buy: ["buy"],
  inspect: ["inspect"],
  ls: ["ls", "list"],
  move: ["move"],
  rm: ["rm", "remove"],
  transferIn: ["transfer-in"]
};
async function main5(client) {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(domainsCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification, {
      permissive: true
    });
  } catch (error) {
    printError(error);
    return 1;
  }
  const telemetry2 = new DomainsTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const { subcommand, args, subcommandOriginal } = getSubcommand2(
    parsedArgs.args.slice(1),
    COMMAND_CONFIG7
  );
  const needHelp = parsedArgs.flags["--help"];
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp("domains");
    output_manager_default.print(help(domainsCommand, { columns: client.stderr.columns }));
    return 2;
  }
  function printHelp(command) {
    output_manager_default.print(
      help(command, { parent: domainsCommand, columns: client.stderr.columns })
    );
    return 2;
  }
  switch (subcommand) {
    case "add":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("domains", subcommandOriginal);
        return printHelp(addSubcommand3);
      }
      telemetry2.trackCliSubcommandAdd(subcommandOriginal);
      return add3(client, args);
    case "inspect":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("domains", subcommandOriginal);
        return printHelp(inspectSubcommand);
      }
      telemetry2.trackCliSubcommandInspect(subcommandOriginal);
      return inspect(client, args);
    case "move":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("domains", subcommandOriginal);
        return printHelp(moveSubcommand);
      }
      telemetry2.trackCliSubcommandMove(subcommandOriginal);
      return move(client, args);
    case "buy":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("domains", subcommandOriginal);
        return printHelp(buySubcommand);
      }
      telemetry2.trackCliSubcommandBuy(subcommandOriginal);
      return buy(client, args);
    case "rm":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("domains", subcommandOriginal);
        return printHelp(removeSubcommand4);
      }
      telemetry2.trackCliSubcommandRemove(subcommandOriginal);
      return rm4(client, args);
    case "transferIn":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("domains", subcommandOriginal);
        return printHelp(transferInSubcommand);
      }
      telemetry2.trackCliSubcommandTransferIn(subcommandOriginal);
      return transferIn(client, args);
    default:
      if (needHelp) {
        telemetry2.trackCliFlagHelp("domains", subcommandOriginal);
        return printHelp(transferInSubcommand);
      }
      telemetry2.trackCliSubcommandList(subcommandOriginal);
      return ls4(client, args);
  }
}

// src/util/telemetry/commands/flags/index.ts
var FlagsTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandList(actual) {
    this.trackCliSubcommand({
      subcommand: "ls",
      value: actual
    });
  }
  trackCliSubcommandInspect(actual) {
    this.trackCliSubcommand({
      subcommand: "inspect",
      value: actual
    });
  }
  trackCliSubcommandAdd(actual) {
    this.trackCliSubcommand({
      subcommand: "add",
      value: actual
    });
  }
  trackCliSubcommandRemove(actual) {
    this.trackCliSubcommand({
      subcommand: "rm",
      value: actual
    });
  }
  trackCliSubcommandArchive(actual) {
    this.trackCliSubcommand({
      subcommand: "archive",
      value: actual
    });
  }
  trackCliSubcommandDisable(actual) {
    this.trackCliSubcommand({
      subcommand: "disable",
      value: actual
    });
  }
  trackCliSubcommandEnable(actual) {
    this.trackCliSubcommand({
      subcommand: "enable",
      value: actual
    });
  }
  trackCliSubcommandSdkKeys(actual) {
    this.trackCliSubcommand({
      subcommand: "sdk-keys",
      value: actual
    });
  }
};

// src/commands/flags/ls.ts
var import_chalk41 = __toESM(require_source(), 1);
var import_ms11 = __toESM(require_ms(), 1);
var import_pluralize8 = __toESM(require_pluralize(), 1);

// src/util/flags/get-flags.ts
async function getFlags(client, projectId, state = "active") {
  output_manager_default.debug(`Fetching feature flags for project ${projectId}`);
  const url = `/v1/projects/${encodeURIComponent(projectId)}/feature-flags/flags?state=${state}`;
  const response = await client.fetch(url);
  return response.data;
}
async function getFlag(client, projectId, flagIdOrSlug) {
  output_manager_default.debug(
    `Fetching feature flag ${flagIdOrSlug} for project ${projectId}`
  );
  const url = `/v1/projects/${encodeURIComponent(projectId)}/feature-flags/flags/${encodeURIComponent(flagIdOrSlug)}`;
  const response = await client.fetch(url);
  return response;
}
async function getFlagSettings(client, projectId) {
  output_manager_default.debug(`Fetching feature flag settings for project ${projectId}`);
  const url = `/v1/projects/${encodeURIComponent(projectId)}/feature-flags/settings`;
  const response = await client.fetch(url);
  return response;
}

// src/util/telemetry/commands/flags/ls.ts
var FlagsLsTelemetryClient = class extends TelemetryClient {
  trackCliOptionState(state) {
    if (state) {
      this.trackCliOption({
        option: "state",
        value: state
      });
    }
  }
  trackCliFlagJson(json) {
    if (json) {
      this.trackCliFlag("json");
    }
  }
};

// src/commands/flags/ls.ts
async function ls5(client, argv) {
  const telemetryClient = new FlagsLsTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(listSubcommand6.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { flags } = parsedArgs;
  const state = flags["--state"] || "active";
  const json = flags["--json"];
  telemetryClient.trackCliOptionState(state);
  telemetryClient.trackCliFlagJson(json);
  const link = await getLinkedProject(client);
  if (link.status === "error") {
    return link.exitCode;
  } else if (link.status === "not_linked") {
    output_manager_default.error(
      `Your codebase isn't linked to a project on Vercel. Run ${getCommandName("link")} to begin.`
    );
    return 1;
  }
  client.config.currentTeam = link.org.type === "team" ? link.org.id : void 0;
  const { project, org } = link;
  const projectSlugLink = formatProject(org.slug, project.name);
  const lsStamp = stamp_default();
  output_manager_default.spinner(`Fetching ${state} feature flags for ${projectSlugLink}`);
  try {
    const flagsList = await getFlags(client, project.id, state);
    output_manager_default.stopSpinner();
    const sortedFlags = flagsList.sort((a, b) => b.updatedAt - a.updatedAt);
    if (json) {
      outputJson(client, sortedFlags);
    } else if (flagsList.length === 0) {
      output_manager_default.log(
        `No ${state} feature flags found for ${projectSlugLink} ${import_chalk41.default.gray(lsStamp())}`
      );
    } else {
      output_manager_default.log(
        `${(0, import_pluralize8.default)("feature flag", flagsList.length, true)} found for ${projectSlugLink} ${import_chalk41.default.gray(lsStamp())}`
      );
      printFlagsTable(sortedFlags);
    }
  } catch (err) {
    output_manager_default.stopSpinner();
    printError(err);
    return 1;
  }
  return 0;
}
function outputJson(client, flags) {
  const jsonOutput = {
    flags: flags.map((flag) => ({
      id: flag.id,
      slug: flag.slug,
      description: flag.description ?? null,
      kind: flag.kind,
      state: flag.state,
      variants: flag.variants,
      createdAt: flag.createdAt,
      updatedAt: flag.updatedAt
    }))
  };
  client.stdout.write(`${JSON.stringify(jsonOutput, null, 2)}
`);
}
function printFlagsTable(flags) {
  const headers = ["Name", "Kind", "State", "Variants", "Updated"];
  const now = Date.now();
  const rows = flags.map((flag) => [
    import_chalk41.default.bold(flag.slug),
    flag.kind,
    flag.state === "active" ? import_chalk41.default.green(flag.state) : import_chalk41.default.gray(flag.state),
    String(flag.variants.length),
    (0, import_ms11.default)(now - flag.updatedAt) + " ago"
  ]);
  const table3 = formatTable(
    headers,
    ["l", "l", "l", "r", "l"],
    [{ name: "", rows }]
  );
  output_manager_default.print(`
${table3}
`);
}

// src/commands/flags/inspect.ts
var import_chalk42 = __toESM(require_source(), 1);

// src/util/flags/dashboard-url.ts
function getFlagDashboardUrl(orgSlug, projectName, flagSlug) {
  return `https://vercel.com/${orgSlug}/${projectName}/flag/${flagSlug}`;
}
function getFlagsDashboardUrl(orgSlug, projectName) {
  return `https://vercel.com/${orgSlug}/${projectName}/flags`;
}

// src/util/telemetry/commands/flags/inspect.ts
var FlagsInspectTelemetryClient = class extends TelemetryClient {
  trackCliArgumentFlag(flag) {
    if (flag) {
      this.trackCliArgument({
        arg: "flag",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/flags/inspect.ts
async function inspect2(client, argv) {
  const telemetryClient = new FlagsInspectTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(inspectSubcommand2.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args } = parsedArgs;
  const [flagArg] = args;
  if (!flagArg) {
    output_manager_default.error(
      `Missing required argument: flag. Usage: ${getCommandName("flags inspect <flag>")}`
    );
    return 1;
  }
  telemetryClient.trackCliArgumentFlag(flagArg);
  const link = await getLinkedProject(client);
  if (link.status === "error") {
    return link.exitCode;
  } else if (link.status === "not_linked") {
    output_manager_default.error(
      `Your codebase isn't linked to a project on Vercel. Run ${getCommandName("link")} to begin.`
    );
    return 1;
  }
  client.config.currentTeam = link.org.type === "team" ? link.org.id : void 0;
  const { project, org } = link;
  const projectSlugLink = formatProject(org.slug, project.name);
  try {
    const [flag, settings] = await Promise.all([
      getFlag(client, project.id, flagArg),
      getFlagSettings(client, project.id)
    ]);
    printFlagDetails(flag, settings, projectSlugLink, org.slug, project.name);
  } catch (err) {
    printError(err);
    return 1;
  }
  return 0;
}
function resolveTargetingLabel(settings, entityKind, attribute, value) {
  const entity = settings.entities.find((e2) => e2.kind === entityKind);
  if (!entity)
    return void 0;
  const attr = entity.attributes.find((a) => a.key === attribute);
  if (!attr?.labels)
    return void 0;
  const labelEntry = attr.labels.find((l) => l.value === value);
  return labelEntry?.label;
}
function formatRuleOutcome(outcome, variants) {
  if (outcome.type === "variant") {
    const variant = variants.find((v) => v.id === outcome.variantId);
    return variant?.label || outcome.variantId;
  } else if (outcome.type === "split") {
    const weights = Object.entries(outcome.weights).map(([id, weight]) => {
      const variant = variants.find((v) => v.id === id);
      const label = variant?.label || id;
      return `${label}: ${weight}%`;
    }).join(", ");
    return `split (${weights})`;
  }
  return "unknown";
}
function formatCondition(condition, settings) {
  let lhs;
  if (condition.lhs.type === "segment") {
    lhs = "segment";
  } else {
    lhs = `${condition.lhs.kind}.${condition.lhs.attribute}`;
  }
  const cmp = import_chalk42.default.dim(formatComparison(condition.cmp));
  if (condition.rhs === void 0 || condition.rhs === null) {
    return { text: `${lhs} ${cmp}` };
  }
  if (typeof condition.rhs === "object") {
    if (condition.rhs.type === "list" && Array.isArray(condition.rhs.items)) {
      const items = condition.rhs.items.map((item) => {
        const itemValue = typeof item === "object" && item !== null && "value" in item ? String(item.value) : String(item);
        if (condition.lhs.type === "entity") {
          const label = resolveTargetingLabel(
            settings,
            condition.lhs.kind,
            condition.lhs.attribute,
            itemValue
          );
          return label ? `${itemValue} ${import_chalk42.default.gray(label)}` : itemValue;
        }
        return itemValue;
      });
      return { text: `${lhs} ${cmp}`, listItems: items };
    }
    return { text: `${lhs} ${cmp} ${JSON.stringify(condition.rhs)}` };
  }
  let rhs;
  if (condition.lhs.type === "entity") {
    const label = resolveTargetingLabel(
      settings,
      condition.lhs.kind,
      condition.lhs.attribute,
      String(condition.rhs)
    );
    rhs = label ? `${condition.rhs} ${import_chalk42.default.gray(label)}` : String(condition.rhs);
  } else {
    rhs = String(condition.rhs);
  }
  return { text: `${lhs} ${cmp} ${rhs}` };
}
function formatComparison(cmp) {
  const operators = {
    eq: "is",
    oneOf: "is in",
    gt: "is greater than",
    gte: "is greater than or equal to",
    lt: "is less than",
    lte: "is less than or equal to",
    ex: "has any value",
    "!ex": "has no value",
    startsWith: "starts with",
    endsWith: "ends with",
    containsAnyOf: "contains any of",
    containsAllOf: "contains all of",
    containsNoneOf: "contains none of"
  };
  return operators[cmp] || cmp;
}
function printFlagDetails(flag, settings, projectSlugLink, orgSlug, projectName) {
  const dashboardUrl = getFlagDashboardUrl(orgSlug, projectName, flag.slug);
  output_manager_default.log(
    `
Feature flag ${import_chalk42.default.bold(flag.slug)} for ${projectSlugLink}
`
  );
  output_manager_default.print(`  ${import_chalk42.default.cyan(dashboardUrl)}

`);
  output_manager_default.print(`  ${import_chalk42.default.dim("ID:")}           ${flag.id}
`);
  output_manager_default.print(`  ${import_chalk42.default.dim("Kind:")}         ${flag.kind}
`);
  output_manager_default.print(
    `  ${import_chalk42.default.dim("State:")}        ${flag.state === "active" ? import_chalk42.default.green(flag.state) : import_chalk42.default.gray(flag.state)}
`
  );
  if (flag.description) {
    output_manager_default.print(`  ${import_chalk42.default.dim("Description:")}  ${flag.description}
`);
  }
  output_manager_default.print(
    `  ${import_chalk42.default.dim("Created:")}      ${formatDate(flag.createdAt)}
`
  );
  output_manager_default.print(
    `  ${import_chalk42.default.dim("Updated:")}      ${formatDate(flag.updatedAt)}
`
  );
  output_manager_default.print(`
  ${import_chalk42.default.dim("Variants:")}
`);
  for (const variant of flag.variants) {
    output_manager_default.print(`    ${import_chalk42.default.cyan(variant.id)}
`);
    if (variant.label) {
      output_manager_default.print(`      ${import_chalk42.default.dim("Label:")} ${variant.label}
`);
    }
    output_manager_default.print(
      `      ${import_chalk42.default.dim("Value:")} ${import_chalk42.default.yellow(JSON.stringify(variant.value))}
`
    );
  }
  const envOrder = ["production", "preview", "development"];
  const sortedEnvs = Object.entries(flag.environments).sort(([a], [b]) => {
    const aIndex = envOrder.indexOf(a);
    const bIndex = envOrder.indexOf(b);
    if (aIndex === -1 && bIndex === -1)
      return a.localeCompare(b);
    if (aIndex === -1)
      return 1;
    if (bIndex === -1)
      return -1;
    return aIndex - bIndex;
  });
  output_manager_default.print(`
  ${import_chalk42.default.dim("Environments:")}
`);
  for (const [envName, envConfig] of sortedEnvs) {
    if (envConfig.active) {
      if (envConfig.reuse?.active) {
        output_manager_default.print(
          `    ${import_chalk42.default.bold(envName)}: reuses ${import_chalk42.default.cyan(envConfig.reuse.environment)} environment
`
        );
        continue;
      }
      output_manager_default.print(`    ${import_chalk42.default.bold(envName)}: ${import_chalk42.default.green("active")}
`);
      if (envConfig.targets && Object.keys(envConfig.targets).length > 0) {
        output_manager_default.print(`      ${import_chalk42.default.dim("Targeting:")}
`);
        for (const [variantId2, entityKinds] of Object.entries(
          envConfig.targets
        )) {
          const variant = flag.variants.find((v) => v.id === variantId2);
          const variantLabel = variant?.label || variantId2;
          for (const [entityKind, attributes] of Object.entries(entityKinds)) {
            for (const [attribute, values] of Object.entries(attributes)) {
              const valueList = values.map((v) => {
                const label = resolveTargetingLabel(
                  settings,
                  entityKind,
                  attribute,
                  v.value
                );
                return label ? `${v.value} ${import_chalk42.default.gray(label)}` : v.value;
              }).join(", ");
              output_manager_default.print(
                `        ${import_chalk42.default.dim(`${entityKind}.${attribute}:`)} ${valueList} ${import_chalk42.default.dim("\u2192")} ${variantLabel}
`
              );
            }
          }
        }
      }
      if (envConfig.rules && envConfig.rules.length > 0) {
        output_manager_default.print(`      ${import_chalk42.default.dim("Rules:")}
`);
        for (const rule of envConfig.rules) {
          const outcome = formatRuleOutcome(rule.outcome, flag.variants);
          output_manager_default.print(`        ${import_chalk42.default.dim("\u2192")} ${outcome}
`);
          for (const condition of rule.conditions) {
            const { text, listItems } = formatCondition(condition, settings);
            output_manager_default.print(`          ${import_chalk42.default.dim("if")} ${text}
`);
            if (listItems && listItems.length > 0) {
              for (const item of listItems) {
                output_manager_default.print(`             ${import_chalk42.default.dim("-")} ${item}
`);
              }
            }
          }
        }
      }
      if (envConfig.fallthrough) {
        const fallthrough = envConfig.fallthrough;
        if (fallthrough.type === "variant") {
          const defaultVariant = flag.variants.find(
            (v) => v.id === fallthrough.variantId
          );
          const defaultLabel = defaultVariant?.label || fallthrough.variantId;
          output_manager_default.print(`      ${import_chalk42.default.dim("Default:")} ${defaultLabel}
`);
        } else if (fallthrough.type === "split") {
          const weights = Object.entries(fallthrough.weights).map(([id, weight]) => {
            const variant = flag.variants.find((v) => v.id === id);
            const label = variant?.label || id;
            return `${label}: ${weight}%`;
          }).join(", ");
          output_manager_default.print(`      ${import_chalk42.default.dim("Default split:")} ${weights}
`);
        }
      }
    } else {
      output_manager_default.print(`    ${import_chalk42.default.bold(envName)}: ${import_chalk42.default.yellow("paused")}
`);
    }
  }
  output_manager_default.print("\n");
}

// src/commands/flags/add.ts
var import_chalk43 = __toESM(require_source(), 1);
import { randomBytes } from "crypto";

// src/util/flags/create-flag.ts
async function createFlag(client, projectId, request) {
  const url = `/v1/projects/${encodeURIComponent(projectId)}/feature-flags/flags`;
  output_manager_default.debug(
    `Creating feature flag ${request.slug} for project ${projectId}`
  );
  output_manager_default.debug(`API endpoint: PUT ${url}`);
  output_manager_default.debug(`Request body: ${JSON.stringify(request, null, 2)}`);
  try {
    const response = await client.fetch(url, {
      method: "PUT",
      body: request
    });
    output_manager_default.debug(`Response: ${JSON.stringify(response, null, 2)}`);
    return response;
  } catch (err) {
    output_manager_default.debug(`API error occurred`);
    if (err instanceof Error) {
      output_manager_default.debug(`Error message: ${err.message}`);
      output_manager_default.debug(`Error name: ${err.name}`);
      output_manager_default.debug(`Error stack: ${err.stack}`);
      const errWithBody = err;
      if (errWithBody.status) {
        output_manager_default.debug(`Error status: ${errWithBody.status}`);
      }
      if (errWithBody.body) {
        output_manager_default.debug(
          `Error body: ${JSON.stringify(errWithBody.body, null, 2)}`
        );
      }
    }
    throw err;
  }
}

// src/util/telemetry/commands/flags/add.ts
var FlagsAddTelemetryClient = class extends TelemetryClient {
  trackCliArgumentSlug(slug) {
    if (slug) {
      this.trackCliArgument({
        arg: "slug",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionKind(kind) {
    if (kind) {
      this.trackCliOption({
        option: "kind",
        value: kind
      });
    }
  }
  trackCliOptionDescription(description) {
    if (description) {
      this.trackCliOption({
        option: "description",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/flags/add.ts
function variantId(size = 21) {
  const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const bytes3 = randomBytes(size);
  let id = "";
  for (let i = 0; i < size; i++) {
    id += alphabet[bytes3[i] % alphabet.length];
  }
  return id;
}
async function add4(client, argv) {
  const telemetryClient = new FlagsAddTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(addSubcommand4.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags } = parsedArgs;
  const [slug] = args;
  if (!slug) {
    output_manager_default.error("Please provide a slug for the feature flag");
    output_manager_default.log(`Example: ${getCommandName("flags add my-feature")}`);
    return 1;
  }
  const kind = flags["--kind"] || "boolean";
  const description = flags["--description"];
  telemetryClient.trackCliArgumentSlug(slug);
  telemetryClient.trackCliOptionKind(kind);
  telemetryClient.trackCliOptionDescription(description);
  if (kind !== "boolean" && kind !== "string" && kind !== "number") {
    output_manager_default.error(
      `Invalid kind: ${kind}. Must be one of: boolean, string, number`
    );
    return 1;
  }
  const link = await getLinkedProject(client);
  if (link.status === "error") {
    return link.exitCode;
  } else if (link.status === "not_linked") {
    output_manager_default.error(
      `Your codebase isn't linked to a project on Vercel. Run ${getCommandName("link")} to begin.`
    );
    return 1;
  }
  client.config.currentTeam = link.org.type === "team" ? link.org.id : void 0;
  const { project } = link;
  const defaultVariants = getDefaultVariants(kind);
  const defaultEnvConfig = {
    revision: 0,
    active: false,
    pausedOutcome: {
      type: "variant",
      variantId: defaultVariants[0].id
    },
    fallthrough: {
      type: "variant",
      variantId: defaultVariants[0].id
    },
    rules: [],
    reuse: {
      active: false,
      environment: ""
    }
  };
  const request = {
    slug,
    kind,
    description: description || "",
    variants: defaultVariants,
    environments: {
      production: defaultEnvConfig,
      preview: defaultEnvConfig,
      development: defaultEnvConfig
    }
  };
  try {
    output_manager_default.spinner("Creating feature flag...");
    const flag = await createFlag(client, project.id, request);
    output_manager_default.stopSpinner();
    output_manager_default.success(
      `Feature flag ${import_chalk43.default.bold(flag.slug)} created successfully`
    );
    output_manager_default.log(`
  ${import_chalk43.default.dim("ID:")}    ${flag.id}`);
    output_manager_default.log(`  ${import_chalk43.default.dim("Kind:")}  ${flag.kind}`);
    output_manager_default.log(`  ${import_chalk43.default.dim("Slug:")}  ${flag.slug}
`);
    output_manager_default.log(
      `View in dashboard: ${import_chalk43.default.cyan(getFlagDashboardUrl(link.org.slug, project.name, flag.slug))}`
    );
  } catch (err) {
    output_manager_default.stopSpinner();
    printError(err);
    return 1;
  }
  return 0;
}
function getDefaultVariants(kind) {
  switch (kind) {
    case "boolean":
      return [
        { id: variantId(), value: false, label: "Off", description: "" },
        { id: variantId(), value: true, label: "On", description: "" }
      ];
    case "string":
      return [
        {
          id: variantId(),
          value: "value-1",
          label: "Value 1",
          description: ""
        },
        {
          id: variantId(),
          value: "value-2",
          label: "Value 2",
          description: ""
        }
      ];
    case "number":
      return [
        { id: variantId(), value: 0, label: "Off", description: "" },
        { id: variantId(), value: 1, label: "On", description: "" }
      ];
  }
}

// src/commands/flags/rm.ts
var import_chalk44 = __toESM(require_source(), 1);

// src/util/flags/delete-flag.ts
async function deleteFlag(client, projectId, flagIdOrSlug) {
  output_manager_default.debug(
    `Deleting feature flag ${flagIdOrSlug} for project ${projectId}`
  );
  const url = `/v1/projects/${encodeURIComponent(projectId)}/feature-flags/flags/${encodeURIComponent(flagIdOrSlug)}`;
  await client.fetch(url, {
    method: "DELETE"
  });
}

// src/util/telemetry/commands/flags/rm.ts
var FlagsRmTelemetryClient = class extends TelemetryClient {
  trackCliArgumentFlag(flag) {
    if (flag) {
      this.trackCliArgument({
        arg: "flag",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
};

// src/commands/flags/rm.ts
async function rm5(client, argv) {
  const telemetryClient = new FlagsRmTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(removeSubcommand5.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags } = parsedArgs;
  const [flagArg] = args;
  const skipConfirmation = flags["--yes"];
  if (!flagArg) {
    output_manager_default.error("Please provide a flag slug or ID to delete");
    output_manager_default.log(`Example: ${getCommandName("flags rm my-feature")}`);
    return 1;
  }
  telemetryClient.trackCliArgumentFlag(flagArg);
  telemetryClient.trackCliFlagYes(skipConfirmation);
  const link = await getLinkedProject(client);
  if (link.status === "error") {
    return link.exitCode;
  } else if (link.status === "not_linked") {
    output_manager_default.error(
      `Your codebase isn't linked to a project on Vercel. Run ${getCommandName("link")} to begin.`
    );
    return 1;
  }
  client.config.currentTeam = link.org.type === "team" ? link.org.id : void 0;
  const { project } = link;
  try {
    output_manager_default.spinner("Fetching flag...");
    const flag = await getFlag(client, project.id, flagArg);
    output_manager_default.stopSpinner();
    if (flag.state !== "archived") {
      output_manager_default.error(
        `Flag ${import_chalk44.default.bold(flag.slug)} must be archived before it can be deleted. Run ${getCommandName(`flags archive ${flag.slug}`)} first.`
      );
      return 1;
    }
    if (!skipConfirmation) {
      const confirmed = await client.input.confirm(
        `Are you sure you want to delete ${import_chalk44.default.bold(flag.slug)}? This action cannot be undone.`,
        false
      );
      if (!confirmed) {
        output_manager_default.log("Aborted");
        return 0;
      }
    }
    output_manager_default.spinner("Deleting flag...");
    await deleteFlag(client, project.id, flagArg);
    output_manager_default.stopSpinner();
    output_manager_default.success(`Feature flag ${import_chalk44.default.bold(flag.slug)} has been deleted`);
  } catch (err) {
    output_manager_default.stopSpinner();
    printError(err);
    return 1;
  }
  return 0;
}

// src/commands/flags/archive.ts
var import_chalk45 = __toESM(require_source(), 1);

// src/util/flags/update-flag.ts
async function updateFlag(client, projectId, flagIdOrSlug, request) {
  output_manager_default.debug(
    `Updating feature flag ${flagIdOrSlug} for project ${projectId}`
  );
  const url = `/v1/projects/${encodeURIComponent(projectId)}/feature-flags/flags/${encodeURIComponent(flagIdOrSlug)}`;
  const response = await client.fetch(url, {
    method: "PATCH",
    body: request
  });
  return response;
}

// src/util/telemetry/commands/flags/archive.ts
var FlagsArchiveTelemetryClient = class extends TelemetryClient {
  trackCliArgumentFlag(flag) {
    if (flag) {
      this.trackCliArgument({
        arg: "flag",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
};

// src/commands/flags/archive.ts
async function archive(client, argv) {
  const telemetryClient = new FlagsArchiveTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(archiveSubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags } = parsedArgs;
  const [flagArg] = args;
  const skipConfirmation = flags["--yes"];
  if (!flagArg) {
    output_manager_default.error("Please provide a flag slug or ID to archive");
    output_manager_default.log(`Example: ${getCommandName("flags archive my-feature")}`);
    return 1;
  }
  telemetryClient.trackCliArgumentFlag(flagArg);
  telemetryClient.trackCliFlagYes(skipConfirmation);
  const link = await getLinkedProject(client);
  if (link.status === "error") {
    return link.exitCode;
  } else if (link.status === "not_linked") {
    output_manager_default.error(
      `Your codebase isn't linked to a project on Vercel. Run ${getCommandName("link")} to begin.`
    );
    return 1;
  }
  client.config.currentTeam = link.org.type === "team" ? link.org.id : void 0;
  const { project } = link;
  try {
    output_manager_default.spinner("Fetching flag...");
    const flag = await getFlag(client, project.id, flagArg);
    output_manager_default.stopSpinner();
    if (flag.state === "archived") {
      output_manager_default.warn(`Flag ${import_chalk45.default.bold(flag.slug)} is already archived`);
      return 0;
    }
    if (!skipConfirmation) {
      const confirmed = await client.input.confirm(
        `Are you sure you want to archive ${import_chalk45.default.bold(flag.slug)}?`,
        false
      );
      if (!confirmed) {
        output_manager_default.log("Aborted");
        return 0;
      }
    }
    output_manager_default.spinner("Archiving flag...");
    await updateFlag(client, project.id, flagArg, {
      state: "archived",
      message: "Archived via CLI"
    });
    output_manager_default.stopSpinner();
    output_manager_default.success(`Feature flag ${import_chalk45.default.bold(flag.slug)} has been archived`);
    output_manager_default.log(
      `
To restore this flag, visit the dashboard: ${import_chalk45.default.cyan(getFlagsDashboardUrl(link.org.slug, project.name) + "/archive")}`
    );
  } catch (err) {
    output_manager_default.stopSpinner();
    printError(err);
    return 1;
  }
  return 0;
}

// src/commands/flags/disable.ts
var import_chalk46 = __toESM(require_source(), 1);

// src/util/flags/resolve-variant.ts
function formatAvailableVariants(variants) {
  return variants.map((v) => {
    const label = v.label ? ` (${v.label})` : "";
    return `  - ${JSON.stringify(v.value)}${label}`;
  }).join("\n");
}
function resolveVariant(input, variants) {
  const byId = variants.find((v) => v.id === input);
  if (byId) {
    return { variant: byId, error: null };
  }
  const byExactValue = variants.find((v) => v.value === input);
  if (byExactValue) {
    return { variant: byExactValue, error: null };
  }
  const parsedInput = parseVariantValue(input);
  const byValue = variants.find((v) => valuesMatch(v.value, parsedInput));
  if (byValue) {
    return { variant: byValue, error: null };
  }
  const inputLower = input.toLowerCase();
  const byLabel = variants.find((v) => v.label?.toLowerCase() === inputLower);
  if (byLabel) {
    return { variant: byLabel, error: null };
  }
  const availableList = formatAvailableVariants(variants);
  const error = `Variant "${input}" not found.

Available variants:
${availableList}

You can specify a variant by its value (e.g., "true", "false") or label.`;
  return { variant: null, error };
}
function parseVariantValue(input) {
  const lowerInput = input.toLowerCase();
  if (lowerInput === "true") {
    return true;
  }
  if (lowerInput === "false") {
    return false;
  }
  const num = Number(input);
  if (!isNaN(num) && input.trim() !== "") {
    return num;
  }
  return input;
}
function valuesMatch(variantValue, inputValue) {
  if (variantValue === inputValue) {
    return true;
  }
  if (String(variantValue) === String(inputValue)) {
    return true;
  }
  return false;
}

// src/util/telemetry/commands/flags/disable.ts
var FlagsDisableTelemetryClient = class extends TelemetryClient {
  trackCliArgumentFlag(flag) {
    if (flag) {
      this.trackCliArgument({
        arg: "flag",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionEnvironment(environment) {
    if (environment) {
      this.trackCliOption({
        option: "environment",
        value: environment
      });
    }
  }
  trackCliOptionVariant(variant) {
    if (variant) {
      this.trackCliOption({
        option: "variant",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/flags/disable.ts
var VALID_ENVIRONMENTS = ["production", "preview", "development"];
async function disable(client, argv) {
  const telemetryClient = new FlagsDisableTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(disableSubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags } = parsedArgs;
  const [flagArg] = args;
  let environment = flags["--environment"];
  const variantId2 = flags["--variant"];
  if (!flagArg) {
    output_manager_default.error("Please provide a flag slug or ID to disable");
    output_manager_default.log(
      `Example: ${getCommandName("flags disable my-feature --environment production")}`
    );
    return 1;
  }
  telemetryClient.trackCliArgumentFlag(flagArg);
  telemetryClient.trackCliOptionEnvironment(environment);
  telemetryClient.trackCliOptionVariant(variantId2);
  const link = await getLinkedProject(client);
  if (link.status === "error") {
    return link.exitCode;
  } else if (link.status === "not_linked") {
    output_manager_default.error(
      `Your codebase isn't linked to a project on Vercel. Run ${getCommandName("link")} to begin.`
    );
    return 1;
  }
  client.config.currentTeam = link.org.type === "team" ? link.org.id : void 0;
  const { project } = link;
  try {
    output_manager_default.spinner("Fetching flag...");
    const flag = await getFlag(client, project.id, flagArg);
    output_manager_default.stopSpinner();
    if (flag.state === "archived") {
      output_manager_default.error(
        `Flag ${import_chalk46.default.bold(flag.slug)} is archived and cannot be disabled`
      );
      return 1;
    }
    if (flag.kind !== "boolean") {
      const dashboardUrl = getFlagDashboardUrl(
        link.org.slug,
        project.name,
        flag.slug
      );
      output_manager_default.warn(
        `The ${getCommandName("flags disable")} command only works with boolean flags.`
      );
      output_manager_default.log(
        `Flag ${import_chalk46.default.bold(flag.slug)} is a ${import_chalk46.default.cyan(flag.kind)} flag. You can update it on the dashboard:`
      );
      output_manager_default.log(`  ${import_chalk46.default.cyan(dashboardUrl)}`);
      return 0;
    }
    if (!environment) {
      const availableEnvs = Object.keys(flag.environments).filter(
        (env) => VALID_ENVIRONMENTS.includes(env)
      );
      if (availableEnvs.length === 0) {
        output_manager_default.error("No valid environments found for this flag");
        return 1;
      }
      environment = await client.input.select({
        message: "Select an environment to disable the flag in:",
        choices: availableEnvs.map((env) => {
          const config = flag.environments[env];
          const status3 = config?.active ? import_chalk46.default.green("active") : import_chalk46.default.yellow("paused");
          return {
            name: `${env} (${status3})`,
            value: env
          };
        })
      });
    }
    if (!VALID_ENVIRONMENTS.includes(environment)) {
      output_manager_default.error(
        `Invalid environment: ${environment}. Must be one of: ${VALID_ENVIRONMENTS.join(", ")}`
      );
      return 1;
    }
    const envConfig = flag.environments[environment];
    if (!envConfig) {
      output_manager_default.error(`Environment ${environment} not found for this flag`);
      return 1;
    }
    if (!envConfig.active) {
      output_manager_default.warn(
        `Flag ${import_chalk46.default.bold(flag.slug)} is already disabled in ${environment}`
      );
      return 0;
    }
    let selectedVariantId = variantId2;
    if (selectedVariantId) {
      const result = resolveVariant(selectedVariantId, flag.variants);
      if (result.error) {
        output_manager_default.error(result.error);
        return 1;
      }
      selectedVariantId = result.variant.id;
    } else if (flag.variants.length === 1) {
      selectedVariantId = flag.variants[0].id;
    } else if (flag.kind === "boolean") {
      const falseVariant = flag.variants.find((v) => v.value === false);
      selectedVariantId = falseVariant?.id ?? flag.variants[0].id;
    } else {
      selectedVariantId = await client.input.select({
        message: "Select which variant to serve while the flag is disabled:",
        choices: flag.variants.map((v) => ({
          name: `${v.id} (${import_chalk46.default.yellow(JSON.stringify(v.value))})${v.label ? ` - ${v.label}` : ""}`,
          value: v.id
        }))
      });
    }
    const updatedEnvConfig = {
      active: false,
      fallthrough: envConfig.fallthrough,
      rules: envConfig.rules,
      pausedOutcome: {
        type: "variant",
        variantId: selectedVariantId
      }
    };
    output_manager_default.spinner(`Disabling flag in ${environment}...`);
    await updateFlag(client, project.id, flagArg, {
      environments: {
        [environment]: updatedEnvConfig
      },
      message: `Disabled in ${environment} via CLI`
    });
    output_manager_default.stopSpinner();
    const variant = flag.variants.find((v) => v.id === selectedVariantId);
    const variantValue = variant ? JSON.stringify(variant.value) : selectedVariantId;
    output_manager_default.success(
      `Feature flag ${import_chalk46.default.bold(flag.slug)} has been disabled in ${import_chalk46.default.bold(environment)}`
    );
    output_manager_default.log(
      `  ${import_chalk46.default.dim("Serving variant:")} ${selectedVariantId} (${import_chalk46.default.yellow(variantValue)})`
    );
  } catch (err) {
    output_manager_default.stopSpinner();
    printError(err);
    return 1;
  }
  return 0;
}

// src/commands/flags/enable.ts
var import_chalk47 = __toESM(require_source(), 1);

// src/util/telemetry/commands/flags/enable.ts
var FlagsEnableTelemetryClient = class extends TelemetryClient {
  trackCliArgumentFlag(flag) {
    if (flag) {
      this.trackCliArgument({
        arg: "flag",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionEnvironment(environment) {
    if (environment) {
      this.trackCliOption({
        option: "environment",
        value: environment
      });
    }
  }
};

// src/commands/flags/enable.ts
var VALID_ENVIRONMENTS2 = ["production", "preview", "development"];
async function enable(client, argv) {
  const telemetryClient = new FlagsEnableTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(enableSubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags } = parsedArgs;
  const [flagArg] = args;
  let environment = flags["--environment"];
  if (!flagArg) {
    output_manager_default.error("Please provide a flag slug or ID to enable");
    output_manager_default.log(
      `Example: ${getCommandName("flags enable my-feature --environment production")}`
    );
    return 1;
  }
  telemetryClient.trackCliArgumentFlag(flagArg);
  telemetryClient.trackCliOptionEnvironment(environment);
  const link = await getLinkedProject(client);
  if (link.status === "error") {
    return link.exitCode;
  } else if (link.status === "not_linked") {
    output_manager_default.error(
      `Your codebase isn't linked to a project on Vercel. Run ${getCommandName("link")} to begin.`
    );
    return 1;
  }
  client.config.currentTeam = link.org.type === "team" ? link.org.id : void 0;
  const { project } = link;
  try {
    output_manager_default.spinner("Fetching flag...");
    const flag = await getFlag(client, project.id, flagArg);
    output_manager_default.stopSpinner();
    if (flag.state === "archived") {
      output_manager_default.error(
        `Flag ${import_chalk47.default.bold(flag.slug)} is archived and cannot be enabled`
      );
      return 1;
    }
    if (flag.kind !== "boolean") {
      const dashboardUrl = getFlagDashboardUrl(
        link.org.slug,
        project.name,
        flag.slug
      );
      output_manager_default.warn(
        `The ${getCommandName("flags enable")} command only works with boolean flags.`
      );
      output_manager_default.log(
        `Flag ${import_chalk47.default.bold(flag.slug)} is a ${import_chalk47.default.cyan(flag.kind)} flag. You can update it on the dashboard:`
      );
      output_manager_default.log(`  ${import_chalk47.default.cyan(dashboardUrl)}`);
      return 0;
    }
    if (!environment) {
      const availableEnvs = Object.keys(flag.environments).filter(
        (env) => VALID_ENVIRONMENTS2.includes(env)
      );
      if (availableEnvs.length === 0) {
        output_manager_default.error("No valid environments found for this flag");
        return 1;
      }
      environment = await client.input.select({
        message: "Select an environment to enable the flag in:",
        choices: availableEnvs.map((env) => {
          const config = flag.environments[env];
          const status3 = config?.active ? import_chalk47.default.green("active") : import_chalk47.default.yellow("paused");
          return {
            name: `${env} (${status3})`,
            value: env
          };
        })
      });
    }
    if (!VALID_ENVIRONMENTS2.includes(environment)) {
      output_manager_default.error(
        `Invalid environment: ${environment}. Must be one of: ${VALID_ENVIRONMENTS2.join(", ")}`
      );
      return 1;
    }
    const envConfig = flag.environments[environment];
    if (!envConfig) {
      output_manager_default.error(`Environment ${environment} not found for this flag`);
      return 1;
    }
    if (envConfig.active) {
      output_manager_default.warn(
        `Flag ${import_chalk47.default.bold(flag.slug)} is already enabled in ${environment}`
      );
      return 0;
    }
    const updatedEnvConfig = {
      ...envConfig,
      active: true
    };
    output_manager_default.spinner(`Enabling flag in ${environment}...`);
    await updateFlag(client, project.id, flagArg, {
      environments: {
        [environment]: updatedEnvConfig
      },
      message: `Enabled in ${environment} via CLI`
    });
    output_manager_default.stopSpinner();
    output_manager_default.success(
      `Feature flag ${import_chalk47.default.bold(flag.slug)} has been enabled in ${import_chalk47.default.bold(environment)}`
    );
    output_manager_default.log(
      `  ${import_chalk47.default.dim("The flag will now evaluate rules and serve variants based on its configuration.")}`
    );
  } catch (err) {
    output_manager_default.stopSpinner();
    printError(err);
    return 1;
  }
  return 0;
}

// src/util/telemetry/commands/flags/sdk-keys.ts
var FlagsSdkKeysTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandList(actual) {
    this.trackCliSubcommand({
      subcommand: "ls",
      value: actual
    });
  }
  trackCliSubcommandAdd(actual) {
    this.trackCliSubcommand({
      subcommand: "add",
      value: actual
    });
  }
  trackCliSubcommandRemove(actual) {
    this.trackCliSubcommand({
      subcommand: "rm",
      value: actual
    });
  }
};
var FlagsSdkKeysLsTelemetryClient = class extends TelemetryClient {
  trackCliFlagJson(json) {
    if (json) {
      this.trackCliFlag("json");
    }
  }
};
var FlagsSdkKeysAddTelemetryClient = class extends TelemetryClient {
  trackCliOptionType(type) {
    if (type) {
      this.trackCliOption({
        option: "type",
        value: type
      });
    }
  }
  trackCliOptionEnvironment(environment) {
    if (environment) {
      this.trackCliOption({
        option: "environment",
        value: environment
      });
    }
  }
  trackCliOptionLabel(label) {
    if (label) {
      this.trackCliOption({
        option: "label",
        value: this.redactedValue
      });
    }
  }
};
var FlagsSdkKeysRmTelemetryClient = class extends TelemetryClient {
  trackCliArgumentKey(key) {
    if (key) {
      this.trackCliArgument({
        arg: "key",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
};

// src/commands/flags/sdk-keys-ls.ts
var import_chalk48 = __toESM(require_source(), 1);
var import_ms12 = __toESM(require_ms(), 1);

// src/util/flags/sdk-keys.ts
async function getSdkKeys(client, projectId) {
  output_manager_default.debug(`Fetching SDK keys for project ${projectId}`);
  const url = `/v1/projects/${encodeURIComponent(projectId)}/feature-flags/sdk-keys`;
  const response = await client.fetch(url);
  return response.data;
}
async function createSdkKey(client, projectId, request) {
  output_manager_default.debug(`Creating SDK key for project ${projectId}`);
  const url = `/v1/projects/${encodeURIComponent(projectId)}/feature-flags/sdk-keys`;
  const response = await client.fetch(url, {
    method: "PUT",
    body: request
  });
  return response;
}
async function deleteSdkKey(client, projectId, hashKey) {
  output_manager_default.debug(`Deleting SDK key ${hashKey} for project ${projectId}`);
  const url = `/v1/projects/${encodeURIComponent(projectId)}/feature-flags/sdk-keys/${encodeURIComponent(hashKey)}`;
  await client.fetch(url, {
    method: "DELETE",
    json: false
  });
}

// src/commands/flags/sdk-keys-ls.ts
async function sdkKeysLs(client, argv) {
  const telemetryClient = new FlagsSdkKeysLsTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(
    sdkKeysListSubcommand.options
  );
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { flags } = parsedArgs;
  const json = flags["--json"];
  telemetryClient.trackCliFlagJson(json);
  const link = await getLinkedProject(client);
  if (link.status === "error") {
    return link.exitCode;
  } else if (link.status === "not_linked") {
    output_manager_default.error(
      `Your codebase isn't linked to a project on Vercel. Run ${getCommandName("link")} to begin.`
    );
    return 1;
  }
  client.config.currentTeam = link.org.type === "team" ? link.org.id : void 0;
  const { project, org } = link;
  const projectSlugLink = formatProject(org.slug, project.name);
  try {
    output_manager_default.spinner("Fetching SDK keys...");
    const keys = await getSdkKeys(client, project.id);
    output_manager_default.stopSpinner();
    const sortedKeys = keys.sort((a, b) => b.createdAt - a.createdAt);
    if (json) {
      outputSdkKeysJson(client, sortedKeys);
    } else if (keys.length === 0) {
      output_manager_default.log(`No SDK keys found for ${projectSlugLink}`);
      output_manager_default.log(
        `
Create one with: ${getCommandName("flags sdk-keys add --type server --environment production")}`
      );
    } else {
      output_manager_default.log(
        `${import_chalk48.default.bold(keys.length)} SDK key${keys.length === 1 ? "" : "s"} found for ${projectSlugLink}`
      );
      printSdkKeysTable(sortedKeys);
    }
  } catch (err) {
    output_manager_default.stopSpinner();
    printError(err);
    return 1;
  }
  return 0;
}
function outputSdkKeysJson(client, keys) {
  const jsonOutput = {
    sdkKeys: keys.map((key) => ({
      hashKey: key.hashKey,
      type: key.type,
      environment: key.environment,
      label: key.label ?? null,
      createdAt: key.createdAt,
      updatedAt: key.updatedAt
    }))
  };
  client.stdout.write(`${JSON.stringify(jsonOutput, null, 2)}
`);
}
function printSdkKeysTable(keys) {
  const headers = ["Hash Key", "Type", "Environment", "Label", "Created"];
  const now = Date.now();
  const rows = keys.map((key) => [
    import_chalk48.default.dim(key.hashKey.slice(0, 12) + "..."),
    getTypeLabel(key.type),
    key.environment,
    key.label || import_chalk48.default.dim("-"),
    (0, import_ms12.default)(now - key.createdAt) + " ago"
  ]);
  const table3 = formatTable(
    headers,
    ["l", "l", "l", "l", "l"],
    [{ name: "", rows }]
  );
  output_manager_default.print(`
${table3}
`);
}
function getTypeLabel(type) {
  switch (type) {
    case "server":
      return import_chalk48.default.blue("server");
    case "client":
      return import_chalk48.default.green("client");
    case "mobile":
      return import_chalk48.default.yellow("mobile");
    default:
      return type;
  }
}

// src/commands/flags/sdk-keys-add.ts
var import_chalk49 = __toESM(require_source(), 1);
var VALID_TYPES = ["server", "client", "mobile"];
var VALID_ENVIRONMENTS3 = ["production", "preview", "development"];
async function sdkKeysAdd(client, argv) {
  const telemetryClient = new FlagsSdkKeysAddTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(
    sdkKeysAddSubcommand.options
  );
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { flags } = parsedArgs;
  let sdkKeyType = flags["--type"];
  let environment = flags["--environment"];
  const label = flags["--label"];
  telemetryClient.trackCliOptionType(sdkKeyType);
  telemetryClient.trackCliOptionEnvironment(environment);
  telemetryClient.trackCliOptionLabel(label);
  const link = await getLinkedProject(client);
  if (link.status === "error") {
    return link.exitCode;
  } else if (link.status === "not_linked") {
    output_manager_default.error(
      `Your codebase isn't linked to a project on Vercel. Run ${getCommandName("link")} to begin.`
    );
    return 1;
  }
  client.config.currentTeam = link.org.type === "team" ? link.org.id : void 0;
  const { project } = link;
  if (!sdkKeyType) {
    sdkKeyType = await client.input.select({
      message: "Select the SDK key type:",
      choices: [
        {
          name: "Server (for backend/server-side usage)",
          value: "server"
        },
        {
          name: "Client (for browser/frontend usage)",
          value: "client"
        },
        { name: "Mobile (for mobile app usage)", value: "mobile" }
      ]
    });
  }
  if (!VALID_TYPES.includes(sdkKeyType)) {
    output_manager_default.error(
      `Invalid type: ${sdkKeyType}. Must be one of: ${VALID_TYPES.join(", ")}`
    );
    return 1;
  }
  if (!environment) {
    environment = await client.input.select({
      message: "Select the environment:",
      choices: VALID_ENVIRONMENTS3.map((env) => ({
        name: env,
        value: env
      }))
    });
  }
  if (!VALID_ENVIRONMENTS3.includes(environment)) {
    output_manager_default.error(
      `Invalid environment: ${environment}. Must be one of: ${VALID_ENVIRONMENTS3.join(", ")}`
    );
    return 1;
  }
  let finalLabel = label;
  if (!finalLabel && client.stdin.isTTY) {
    finalLabel = await client.input.text({
      message: "Enter an optional label for this SDK key (press Enter to skip):"
    });
    if (finalLabel === "") {
      finalLabel = void 0;
    }
  }
  const request = {
    sdkKeyType,
    environment,
    label: finalLabel
  };
  try {
    output_manager_default.spinner("Creating SDK key...");
    const key = await createSdkKey(client, project.id, request);
    output_manager_default.stopSpinner();
    output_manager_default.success("SDK key created successfully");
    output_manager_default.print("\n");
    output_manager_default.print(`  ${import_chalk49.default.dim("Hash Key:")}     ${key.hashKey}
`);
    output_manager_default.print(`  ${import_chalk49.default.dim("Type:")}         ${key.type}
`);
    output_manager_default.print(`  ${import_chalk49.default.dim("Environment:")}  ${key.environment}
`);
    if (key.label) {
      output_manager_default.print(`  ${import_chalk49.default.dim("Label:")}        ${key.label}
`);
    }
    if (key.keyValue) {
      output_manager_default.print("\n");
      output_manager_default.warn("Save this key - it will not be shown again:");
      output_manager_default.print(`
  ${import_chalk49.default.cyan(key.keyValue)}
`);
    }
    if (key.connectionString) {
      output_manager_default.print("\n");
      output_manager_default.log(`${import_chalk49.default.dim("Connection string:")}`);
      output_manager_default.print(`  ${import_chalk49.default.cyan(key.connectionString)}
`);
    }
  } catch (err) {
    output_manager_default.stopSpinner();
    printError(err);
    return 1;
  }
  return 0;
}

// src/commands/flags/sdk-keys-rm.ts
var import_chalk50 = __toESM(require_source(), 1);
async function sdkKeysRm(client, argv) {
  const telemetryClient = new FlagsSdkKeysRmTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(
    sdkKeysRemoveSubcommand.options
  );
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags } = parsedArgs;
  let [hashKey] = args;
  const skipConfirmation = flags["--yes"];
  telemetryClient.trackCliArgumentKey(hashKey);
  telemetryClient.trackCliFlagYes(skipConfirmation);
  const link = await getLinkedProject(client);
  if (link.status === "error") {
    return link.exitCode;
  } else if (link.status === "not_linked") {
    output_manager_default.error(
      `Your codebase isn't linked to a project on Vercel. Run ${getCommandName("link")} to begin.`
    );
    return 1;
  }
  client.config.currentTeam = link.org.type === "team" ? link.org.id : void 0;
  const { project } = link;
  try {
    if (!hashKey) {
      output_manager_default.spinner("Fetching SDK keys...");
      const keys = await getSdkKeys(client, project.id);
      output_manager_default.stopSpinner();
      if (keys.length === 0) {
        output_manager_default.log("No SDK keys found");
        return 0;
      }
      hashKey = await client.input.select({
        message: "Select an SDK key to delete:",
        choices: keys.map((key) => ({
          name: `${key.hashKey.slice(0, 12)}... (${key.type}, ${key.environment}${key.label ? `, ${key.label}` : ""})`,
          value: key.hashKey
        }))
      });
    }
    if (!skipConfirmation) {
      const confirmed = await client.input.confirm(
        `Are you sure you want to delete SDK key ${import_chalk50.default.bold(hashKey.slice(0, 12) + "...")}?`,
        false
      );
      if (!confirmed) {
        output_manager_default.log("Aborted");
        return 0;
      }
    }
    output_manager_default.spinner("Deleting SDK key...");
    await deleteSdkKey(client, project.id, hashKey);
    output_manager_default.stopSpinner();
    output_manager_default.success(
      `SDK key ${import_chalk50.default.bold(hashKey.slice(0, 12) + "...")} has been deleted`
    );
  } catch (err) {
    output_manager_default.stopSpinner();
    printError(err);
    return 1;
  }
  return 0;
}

// src/commands/flags/sdk-keys.ts
var COMMAND_CONFIG8 = {
  ls: getCommandAliases(sdkKeysListSubcommand),
  add: getCommandAliases(sdkKeysAddSubcommand),
  rm: getCommandAliases(sdkKeysRemoveSubcommand)
};
async function sdkKeys(client) {
  const telemetry2 = new FlagsSdkKeysTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const flagsSpecification = getFlagsSpecification(sdkKeysSubcommand.options);
  let parsedArgs;
  try {
    parsedArgs = parseArguments(client.argv.slice(4), flagsSpecification, {
      // eslint-disable-next-line no-restricted-syntax -- this is a routing file, not a leaf command
      permissive: true
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  const subArgs = parsedArgs.args.slice(0);
  const { subcommand, args, subcommandOriginal } = getSubcommand2(
    subArgs,
    COMMAND_CONFIG8
  );
  const needHelp = parsedArgs.flags["--help"];
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp("flags sdk-keys", subcommand);
    output_manager_default.print(
      help(sdkKeysSubcommand, {
        parent: flagsCommand,
        columns: client.stderr.columns
      })
    );
    return 2;
  }
  function printHelp(command) {
    output_manager_default.print(
      help(command, {
        parent: sdkKeysSubcommand,
        columns: client.stderr.columns
      })
    );
  }
  switch (subcommand) {
    case "ls":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("flags sdk-keys", subcommandOriginal);
        printHelp(sdkKeysListSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandList(subcommandOriginal);
      return sdkKeysLs(client, args);
    case "add":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("flags sdk-keys", subcommandOriginal);
        printHelp(sdkKeysAddSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandAdd(subcommandOriginal);
      return sdkKeysAdd(client, args);
    case "rm":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("flags sdk-keys", subcommandOriginal);
        printHelp(sdkKeysRemoveSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandRemove(subcommandOriginal);
      return sdkKeysRm(client, args);
    default:
      output_manager_default.error(getInvalidSubcommand(COMMAND_CONFIG8));
      output_manager_default.print(
        help(sdkKeysSubcommand, {
          parent: flagsCommand,
          columns: client.stderr.columns
        })
      );
      return 2;
  }
}

// src/commands/flags/index.ts
var COMMAND_CONFIG9 = {
  ls: getCommandAliases(listSubcommand6),
  inspect: getCommandAliases(inspectSubcommand2),
  add: getCommandAliases(addSubcommand4),
  rm: getCommandAliases(removeSubcommand5),
  archive: getCommandAliases(archiveSubcommand),
  disable: getCommandAliases(disableSubcommand),
  enable: getCommandAliases(enableSubcommand),
  "sdk-keys": getCommandAliases(sdkKeysSubcommand)
};
async function main6(client) {
  const telemetry2 = new FlagsTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const flagsSpecification = getFlagsSpecification(flagsCommand.options);
  let parsedArgs;
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification, {
      permissive: true
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  const subArgs = parsedArgs.args.slice(1);
  const { subcommand, args, subcommandOriginal } = getSubcommand2(
    subArgs,
    COMMAND_CONFIG9
  );
  const needHelp = parsedArgs.flags["--help"];
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp("flags", subcommand);
    output_manager_default.print(help(flagsCommand, { columns: client.stderr.columns }));
    return 2;
  }
  function printHelp(command) {
    output_manager_default.print(
      help(command, { parent: flagsCommand, columns: client.stderr.columns })
    );
  }
  switch (subcommand) {
    case "ls":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("flags", subcommandOriginal);
        printHelp(listSubcommand6);
        return 2;
      }
      telemetry2.trackCliSubcommandList(subcommandOriginal);
      return ls5(client, args);
    case "inspect":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("flags", subcommandOriginal);
        printHelp(inspectSubcommand2);
        return 2;
      }
      telemetry2.trackCliSubcommandInspect(subcommandOriginal);
      return inspect2(client, args);
    case "add":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("flags", subcommandOriginal);
        printHelp(addSubcommand4);
        return 2;
      }
      telemetry2.trackCliSubcommandAdd(subcommandOriginal);
      return add4(client, args);
    case "rm":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("flags", subcommandOriginal);
        printHelp(removeSubcommand5);
        return 2;
      }
      telemetry2.trackCliSubcommandRemove(subcommandOriginal);
      return rm5(client, args);
    case "archive":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("flags", subcommandOriginal);
        printHelp(archiveSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandArchive(subcommandOriginal);
      return archive(client, args);
    case "disable":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("flags", subcommandOriginal);
        printHelp(disableSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandDisable(subcommandOriginal);
      return disable(client, args);
    case "enable":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("flags", subcommandOriginal);
        printHelp(enableSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandEnable(subcommandOriginal);
      return enable(client, args);
    case "sdk-keys":
      telemetry2.trackCliSubcommandSdkKeys(subcommandOriginal);
      return sdkKeys(client);
    default:
      if (needHelp) {
        telemetry2.trackCliFlagHelp("flags", subcommandOriginal);
        printHelp(listSubcommand6);
        return 2;
      }
      telemetry2.trackCliSubcommandList(subcommandOriginal);
      return ls5(client, args);
  }
}

// src/commands/git/connect.ts
var import_chalk51 = __toESM(require_source(), 1);
import { join as join2 } from "path";

// src/util/telemetry/commands/git/connect.ts
var GitConnectTelemetryClient = class extends TelemetryClient {
  trackCliArgumentGitUrl(name) {
    if (name) {
      this.trackCliArgument({
        arg: "gitUrl",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagConfirm(confirm) {
    if (confirm) {
      this.trackCliFlag("confirm");
    }
  }
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
};

// src/commands/git/connect.ts
async function connect(client, argv) {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(connectSubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  const { cwd } = client;
  const telemetry2 = new GitConnectTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  telemetry2.trackCliFlagConfirm(opts["--confirm"]);
  telemetry2.trackCliFlagYes(opts["--yes"]);
  if ("--confirm" in opts) {
    output_manager_default.warn("`--confirm` is deprecated, please use `--yes` instead");
    opts["--yes"] = opts["--confirm"];
  }
  const confirm = Boolean(opts["--yes"]);
  if (args.length > 1) {
    output_manager_default.error(
      `Invalid number of arguments. Usage: ${import_chalk51.default.cyan(
        `${getCommandName("project connect")}`
      )}`
    );
    return 2;
  }
  const repoArg = args[0];
  telemetry2.trackCliArgumentGitUrl(repoArg);
  const linkedProject = await ensureLink("git", client, client.cwd, {
    autoConfirm: confirm
  });
  if (typeof linkedProject === "number") {
    return linkedProject;
  }
  const { project, org } = linkedProject;
  const gitProviderLink = project.link;
  client.config.currentTeam = org.type === "team" ? org.id : void 0;
  const gitConfigPath = join2(cwd, ".git/config");
  const gitConfig = await parseGitConfig(gitConfigPath);
  if (repoArg) {
    const parsedUrlArg = parseRepoUrl(repoArg);
    if (!parsedUrlArg) {
      output_manager_default.error(
        `Failed to parse URL "${repoArg}". Please ensure the URL is valid.`
      );
      return 1;
    }
    if (gitConfig) {
      return await connectArgWithLocalGit({
        client,
        org,
        project,
        confirm,
        gitConfig,
        repoInfo: parsedUrlArg
      });
    }
    return await connectArg({
      client,
      confirm,
      org,
      project,
      repoInfo: parsedUrlArg
    });
  }
  if (!gitConfig) {
    output_manager_default.error(
      `No local Git repository found. Run ${import_chalk51.default.cyan(
        "`git clone <url>`"
      )} to clone a remote Git repository first.`
    );
    return 1;
  }
  const remoteUrls = pluckRemoteUrls(gitConfig);
  if (!remoteUrls) {
    output_manager_default.error(
      `No remote URLs found in your Git config. Make sure you've configured a remote repo in your local Git config. Run ${import_chalk51.default.cyan(
        "`git remote --help`"
      )} for more details.`
    );
    return 1;
  }
  const repoInfo = await selectAndParseRemoteUrl(client, remoteUrls);
  if (!repoInfo) {
    return Object.keys(remoteUrls).length > 1 ? 0 : 1;
  }
  const result = await checkExistsAndConnect({
    client,
    confirm,
    gitProviderLink,
    org,
    gitOrg: repoInfo.org,
    project,
    provider: repoInfo.provider,
    repo: repoInfo.repo,
    repoPath: `${repoInfo.org}/${repoInfo.repo}`
  });
  if (typeof result === "number") {
    return result;
  }
  return 0;
}
async function connectArg({
  client,
  confirm,
  org,
  project,
  repoInfo
}) {
  const { url: repoUrl } = repoInfo;
  const parsedRepoArg = parseRepoUrl(repoUrl);
  if (!parsedRepoArg) {
    output_manager_default.error(
      `Failed to parse URL "${repoUrl}". Please ensure the URL is valid.`
    );
    return 1;
  }
  const result = await checkExistsAndConnect({
    client,
    confirm,
    gitProviderLink: project.link,
    org,
    gitOrg: parsedRepoArg.org,
    project,
    provider: parsedRepoArg.provider,
    repo: parsedRepoArg.repo,
    repoPath: `${parsedRepoArg.org}/${parsedRepoArg.repo}`
  });
  if (typeof result === "number") {
    return result;
  }
  return 0;
}
async function connectArgWithLocalGit({
  client,
  org,
  project,
  confirm,
  gitConfig,
  repoInfo
}) {
  const remoteUrls = pluckRemoteUrls(gitConfig);
  if (remoteUrls) {
    const shouldConnect = await promptConnectArg({
      client,
      yes: confirm,
      repoInfo,
      remoteUrls
    });
    if (!shouldConnect) {
      return 1;
    }
    if (shouldConnect) {
      const result = await checkExistsAndConnect({
        client,
        confirm,
        gitProviderLink: project.link,
        org,
        gitOrg: repoInfo.org,
        project,
        provider: repoInfo.provider,
        repo: repoInfo.repo,
        repoPath: `${repoInfo.org}/${repoInfo.repo}`
      });
      if (typeof result === "number") {
        return result;
      }
    }
    return 0;
  }
  return await connectArg({ client, confirm, org, project, repoInfo });
}
async function promptConnectArg({
  client,
  yes,
  repoInfo: repoInfoFromArg,
  remoteUrls
}) {
  if (Object.keys(remoteUrls).length > 1) {
    output_manager_default.log("Found multiple Git repositories in your local Git config:");
    printRemoteUrls(remoteUrls);
  } else {
    const url = Object.values(remoteUrls)[0];
    const repoInfoFromGitConfig = parseRepoUrl(url);
    if (!repoInfoFromGitConfig) {
      output_manager_default.error(
        `Failed to parse URL "${url}". Please ensure the URL is valid.`
      );
      return false;
    }
    if (JSON.stringify(repoInfoFromGitConfig) === JSON.stringify(repoInfoFromArg)) {
      return true;
    }
    output_manager_default.log(
      `Found a repository in your local Git Config: ${import_chalk51.default.cyan(
        Object.values(remoteUrls)[0]
      )}`
    );
  }
  let shouldConnect = yes;
  if (!shouldConnect) {
    const { url: repoUrlFromArg } = repoInfoFromArg;
    shouldConnect = await client.input.confirm(
      `Do you still want to connect ${link_default(repoUrlFromArg)}?`,
      false
    );
    if (!shouldConnect) {
      output_manager_default.log("Canceled. Repo not connected.");
    }
  }
  return shouldConnect;
}

// src/commands/git/disconnect.ts
var import_chalk52 = __toESM(require_source(), 1);

// src/util/telemetry/commands/git/disconnect.ts
var GitDisconnectTelemetryClient = class extends TelemetryClient {
  trackCliFlagConfirm(confirm) {
    if (confirm) {
      this.trackCliFlag("confirm");
    }
  }
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
};

// src/commands/git/disconnect.ts
async function disconnect(client, argv) {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(
    disconnectSubcommand.options
  );
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  const telemetry2 = new GitDisconnectTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  telemetry2.trackCliFlagConfirm(opts["--confirm"]);
  telemetry2.trackCliFlagYes(opts["--yes"]);
  if ("--confirm" in opts) {
    output_manager_default.warn("`--confirm` is deprecated, please use `--yes` instead");
    opts["--yes"] = opts["--confirm"];
  }
  if (args.length !== 0) {
    output_manager_default.error(
      `Invalid number of arguments. Usage: ${import_chalk52.default.cyan(
        `${getCommandName("project disconnect")}`
      )}`
    );
    return 2;
  }
  const autoConfirm = Boolean(parsedArgs.flags["--yes"]);
  const linkedProject = await ensureLink("git", client, client.cwd, {
    autoConfirm
  });
  if (typeof linkedProject === "number") {
    return linkedProject;
  }
  const { org, project } = linkedProject;
  client.config.currentTeam = org.type === "team" ? org.id : void 0;
  if (project.link) {
    const { org: linkOrg, repo } = project.link;
    output_manager_default.print(
      `Your Vercel project will no longer create deployments when you push to this repository.
`
    );
    const confirmDisconnect = autoConfirm || await client.input.confirm(
      `Are you sure you want to disconnect ${import_chalk52.default.cyan(
        `${linkOrg}/${repo}`
      )} from your project?`,
      false
    );
    if (confirmDisconnect) {
      await disconnectGitProvider(client, org, project.id);
      output_manager_default.log(`Disconnected ${import_chalk52.default.cyan(`${linkOrg}/${repo}`)}.`);
    } else {
      output_manager_default.log("Canceled");
    }
  } else {
    output_manager_default.error(
      `No Git repository connected. Run ${getCommandName(
        "project connect"
      )} to connect one.`
    );
    return 1;
  }
  return 0;
}

// src/util/telemetry/commands/git/index.ts
var GitTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandConnect(actual) {
    this.trackCliSubcommand({
      subcommand: "connect",
      value: actual
    });
  }
  trackCliSubcommandDisconnect(actual) {
    this.trackCliSubcommand({
      subcommand: "disconnect",
      value: actual
    });
  }
};

// src/commands/git/index.ts
var COMMAND_CONFIG10 = {
  connect: ["connect"],
  disconnect: ["disconnect"]
};
async function main7(client) {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(gitCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification, {
      permissive: true
    });
  } catch (error) {
    printError(error);
    return 1;
  }
  const telemetry2 = new GitTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const { subcommand, args, subcommandOriginal } = getSubcommand2(
    parsedArgs.args.slice(1),
    COMMAND_CONFIG10
  );
  if (parsedArgs.flags["--help"]) {
    telemetry2.trackCliFlagHelp("git", subcommand);
    output_manager_default.print(help(gitCommand, { columns: client.stderr.columns }));
    return 2;
  }
  switch (subcommand) {
    case "connect":
      telemetry2.trackCliSubcommandConnect(subcommandOriginal);
      return connect(client, args);
    case "disconnect":
      telemetry2.trackCliSubcommandDisconnect(subcommandOriginal);
      return disconnect(client, args);
    default:
      output_manager_default.error(getInvalidSubcommand(COMMAND_CONFIG10));
      output_manager_default.print(help(gitCommand, { columns: client.stderr.columns }));
      return 2;
  }
}

// src/commands/guidance/status.ts
var import_chalk53 = __toESM(require_source(), 1);
async function status(client) {
  const enabled = client.config.guidance?.enabled !== false;
  const status3 = enabled ? import_chalk53.default.green("Enabled") : import_chalk53.default.red("Disabled");
  output_manager_default.print("\n");
  output_manager_default.log(`${import_chalk53.default.bold("Guidance status")}: ${status3}`);
  output_manager_default.print("\n");
  return 0;
}

// src/commands/guidance/enable.ts
async function enable2(client) {
  client.config = {
    ...client.config,
    guidance: {
      ...client.config.guidance,
      enabled: true
    }
  };
  writeToConfigFile(client.config);
  await status(client);
  return 0;
}

// src/commands/guidance/disable.ts
async function disable2(client) {
  client.config = {
    ...client.config,
    guidance: {
      ...client.config.guidance,
      enabled: false
    }
  };
  writeToConfigFile(client.config);
  await status(client);
  return 0;
}

// src/util/telemetry/commands/guidance/index.ts
var GuidanceTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandStatus(actual) {
    this.trackCliSubcommand({
      subcommand: "status",
      value: actual
    });
  }
  trackCliSubcommandEnable(actual) {
    this.trackCliSubcommand({
      subcommand: "enable",
      value: actual
    });
  }
  trackCliSubcommandDisable(actual) {
    this.trackCliSubcommand({
      subcommand: "disable",
      value: actual
    });
  }
};

// src/commands/guidance/index.ts
var COMMAND_CONFIG11 = {
  status: getCommandAliases(statusSubcommand),
  enable: getCommandAliases(enableSubcommand2),
  disable: getCommandAliases(disableSubcommand2)
};
async function guidance(client) {
  if (!process.env.FF_GUIDANCE_MODE) {
    output_manager_default.error("The guidance subcommand does not exist");
    return 1;
  }
  const telemetryClient = new GuidanceTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArguments;
  const flagsSpecification = getFlagsSpecification(guidanceCommand.options);
  try {
    parsedArguments = parseArguments(client.argv.slice(2), flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { subcommand, subcommandOriginal } = getSubcommand2(
    parsedArguments.args.slice(1),
    COMMAND_CONFIG11
  );
  const needHelp = parsedArguments.flags["--help"];
  function printHelp(command) {
    output_manager_default.print(
      help(command, {
        columns: client.stderr.columns,
        parent: guidanceCommand
      })
    );
  }
  if (!subcommand && needHelp) {
    telemetryClient.trackCliFlagHelp("guidance", subcommand);
    output_manager_default.print(help(guidanceCommand, { columns: client.stderr.columns }));
    return 2;
  }
  switch (subcommand) {
    case "status":
      if (needHelp) {
        telemetryClient.trackCliFlagHelp("guidance", subcommandOriginal);
        printHelp(statusSubcommand);
        return 2;
      }
      telemetryClient.trackCliSubcommandStatus(subcommandOriginal);
      return status(client);
    case "enable":
      if (needHelp) {
        telemetryClient.trackCliFlagHelp("guidance", subcommandOriginal);
        printHelp(enableSubcommand2);
        return 2;
      }
      telemetryClient.trackCliSubcommandEnable(subcommandOriginal);
      return enable2(client);
    case "disable":
      if (needHelp) {
        telemetryClient.trackCliFlagHelp("guidance", subcommandOriginal);
        printHelp(disableSubcommand2);
        return 2;
      }
      return disable2(client);
    default: {
      output_manager_default.print(help(guidanceCommand, { columns: client.stderr.columns }));
      return 2;
    }
  }
}

// src/commands/httpstat/index.ts
import { spawn as spawn2 } from "child_process";

// src/util/telemetry/commands/httpstat/index.ts
var HttpstatTelemetryClient = class extends TelemetryClient {
  trackCliArgumentPath(path3) {
    if (path3) {
      const value = path3.startsWith("/") ? "slash" : "no-slash";
      this.trackCliArgument({
        arg: "path",
        value
      });
    }
  }
  trackCliOptionDeployment(deploymentId) {
    if (deploymentId) {
      const value = deploymentId.startsWith("http://") || deploymentId.startsWith("https://") ? "url" : deploymentId.startsWith("dpl_") ? "dpl_" : "no-prefix";
      this.trackCliOption({
        option: "deployment",
        value
      });
    }
  }
  trackCliOptionProtectionBypass(secret) {
    if (secret) {
      this.trackCliOption({
        option: "protection-bypass",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/httpstat/index.ts
async function httpstat(client) {
  const telemetryClient = new HttpstatTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const setup = setupCurlLikeCommand(client, httpstatCommand, telemetryClient);
  if (typeof setup === "number") {
    return setup;
  }
  const { path: path3, deploymentFlag, protectionBypassFlag, toolFlags } = setup;
  const result = await getDeploymentUrlAndToken(client, "httpstat", path3, {
    deploymentFlag,
    protectionBypassFlag
  });
  if (typeof result === "number") {
    return result;
  }
  const { fullUrl, deploymentProtectionToken } = result;
  const httpstatFlags = [...toolFlags];
  if (deploymentProtectionToken) {
    httpstatFlags.unshift(
      "-H",
      `x-vercel-protection-bypass: ${deploymentProtectionToken}`
    );
  }
  httpstatFlags.unshift(fullUrl);
  output_manager_default.debug(
    `Executing: httpstat ${httpstatFlags.map(requoteArgs).join(" ")}`
  );
  return new Promise((resolve6) => {
    const httpstatProcess = spawn2("httpstat", httpstatFlags, {
      stdio: "inherit",
      shell: false
    });
    httpstatProcess.on("error", (err) => {
      if ("code" in err && err.code === "ENOENT") {
        output_manager_default.error("httpstat command not found. Please install httpstat.");
        output_manager_default.log("");
        output_manager_default.log("Installation instructions:");
        output_manager_default.log("  macOS: brew install httpstat");
        output_manager_default.log("  pip: pip install httpstat");
        output_manager_default.log("  npm: npm install -g httpstat");
        output_manager_default.log("");
        output_manager_default.log(
          "Or visit: https://github.com/reorx/httpstat for more details"
        );
        resolve6(1);
      } else {
        output_manager_default.error(`Failed to execute httpstat: ${err.message}`);
        resolve6(1);
      }
    });
    httpstatProcess.on("close", (code2) => {
      resolve6(code2 ?? 1);
    });
  });
}

// src/commands/init/init.ts
var import_tar_fs = __toESM(require_tar_fs(), 1);
var import_chalk54 = __toESM(require_source(), 1);
import fs from "fs";
import path2 from "path";
var EXAMPLE_API = "https://examples.vercel.sh";
async function init(client, opts, args, telemetry2) {
  const [name, dir] = args;
  const force = opts["--force"];
  const examples = await fetchExampleList(client);
  if (!examples) {
    throw new Error("Could not fetch example list.");
  }
  const exampleList = examples.filter((x) => x.visible).map((x) => x.name);
  if (!name) {
    if (client.stdin.isTTY !== true) {
      output_manager_default.print("No framework provided");
      return 0;
    }
    const chosen = await chooseFromDropdown(
      client,
      "Select example:",
      exampleList
    );
    if (!chosen) {
      output_manager_default.log("Canceled");
      return 0;
    }
    return extractExample(client, chosen, dir, force);
  }
  if (exampleList.includes(name)) {
    telemetry2.trackCliArgumentExample(name, true);
    return extractExample(client, name, dir, force);
  }
  const oldExample = examples.find((x) => !x.visible && x.name === name);
  if (oldExample) {
    telemetry2.trackCliArgumentExample(name, true);
    return extractExample(client, name, dir, force, "v1");
  }
  telemetry2.trackCliArgumentExample(name, false);
  const found = await guess(client, exampleList, name);
  if (typeof found === "string") {
    return extractExample(client, found, dir, force);
  }
  output_manager_default.log("No changes made.");
  return 0;
}
async function fetchExampleList(client) {
  output_manager_default.spinner("Fetching examples");
  const url = `${EXAMPLE_API}/v2/list.json`;
  const body = await client.fetch(url);
  output_manager_default.stopSpinner();
  return body;
}
async function chooseFromDropdown(client, message, exampleList) {
  const choices = exampleList.map((name) => ({
    name,
    value: name,
    short: name
  }));
  return list(client, {
    message,
    choices
  });
}
async function extractExample(client, name, dir, force, ver = "v2") {
  const folder = prepareFolder(client.cwd, dir || name, force);
  output_manager_default.spinner(`Fetching ${name}`);
  const url = `${EXAMPLE_API}/${ver}/download/${name}.tar.gz`;
  return client.fetch(url, { json: false }).then(async (res) => {
    output_manager_default.stopSpinner();
    if (res.status !== 200) {
      throw new Error(`Could not get ${name}.tar.gz`);
    }
    await new Promise((resolve6, reject) => {
      const extractor = import_tar_fs.default.extract(folder);
      res.body.on("error", reject);
      extractor.on("error", reject);
      extractor.on("finish", resolve6);
      res.body.pipe(extractor);
    });
    const successLog = `Initialized "${import_chalk54.default.bold(
      name
    )}" example in ${import_chalk54.default.bold(humanizePath(folder))}.`;
    const folderRel = path2.relative(client.cwd, folder);
    const deployHint = folderRel === "" ? list_item_default(`To deploy, run ${getCommandName()}.`) : list_item_default(
      `To deploy, ${cmd(
        `cd ${folderRel}`
      )} and run ${getCommandName()}.`
    );
    output_manager_default.success(`${successLog}
${deployHint}`);
    return 0;
  }).catch((e2) => {
    output_manager_default.stopSpinner();
    throw e2;
  });
}
function prepareFolder(cwd, folder, force) {
  const dest = path2.join(cwd, folder);
  if (fs.existsSync(dest)) {
    if (!fs.lstatSync(dest).isDirectory()) {
      throw new Error(
        `Destination path "${import_chalk54.default.bold(
          folder
        )}" already exists and is not a directory.`
      );
    }
    if (!force && fs.readdirSync(dest).length !== 0) {
      throw new Error(
        `Destination path "${import_chalk54.default.bold(
          folder
        )}" already exists and is not an empty directory. You may use ${cmd(
          "--force"
        )} or ${cmd("-f")} to override it.`
      );
    }
  } else if (dest !== cwd) {
    try {
      fs.mkdirSync(dest);
    } catch (e2) {
      throw new Error(`Could not create directory "${import_chalk54.default.bold(folder)}".`);
    }
  }
  return dest;
}
async function guess(client, exampleList, name) {
  const GuessError = new Error(
    `No example found for ${import_chalk54.default.bold(name)}, run ${getCommandName(
      "init"
    )} to see the list of available examples.`
  );
  if (client.stdin.isTTY !== true) {
    throw GuessError;
  }
  const found = did_you_mean_default(name, exampleList, 0.7);
  if (typeof found === "string") {
    if (await client.input.confirm(`Did you mean ${import_chalk54.default.bold(found)}?`, false)) {
      return found;
    }
  } else {
    throw GuessError;
  }
}

// src/commands/init/index.ts
var import_error_utils5 = __toESM(require_dist(), 1);

// src/util/telemetry/commands/init/index.ts
var InitTelemetryClient = class extends TelemetryClient {
  trackCliArgumentExample(v, knownValue) {
    if (v) {
      this.trackCliArgument({
        arg: "example",
        value: knownValue ? v : this.redactedValue
      });
    }
  }
  trackCliArgumentDir(v) {
    if (v) {
      this.trackCliArgument({
        arg: "dir",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagForce(v) {
    if (v) {
      this.trackCliFlag("force");
    }
  }
};

// src/commands/init/index.ts
var COMMAND_CONFIG12 = {
  init: ["init"]
};
async function main8(client) {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(initCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const telemetry2 = new InitTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  if (parsedArgs.flags["--help"]) {
    telemetry2.trackCliFlagHelp("init");
    output_manager_default.print(help(initCommand, { columns: client.stderr.columns }));
    return 2;
  }
  const args = getSubcommand2(parsedArgs.args.slice(1), COMMAND_CONFIG12).args;
  if (parsedArgs.args.length > 3) {
    output_manager_default.error("Too many arguments.");
    return 1;
  }
  telemetry2.trackCliArgumentDir(parsedArgs.args[2]);
  telemetry2.trackCliFlagForce(parsedArgs.flags["--force"]);
  try {
    return await init(client, parsedArgs.flags, args, telemetry2);
  } catch (err) {
    output_manager_default.prettyError(err);
    if ((0, import_error_utils5.isError)(err) && typeof err.stack === "string") {
      output_manager_default.debug(err.stack);
    }
    return 1;
  }
}

// src/commands/inspect/index.ts
var import_error_utils6 = __toESM(require_dist(), 1);
var import_chalk57 = __toESM(require_source(), 1);
var import_ms13 = __toESM(require_ms(), 1);
var import_title = __toESM(require_lib2(), 1);
import { URL as URL2 } from "url";

// src/util/output/builds.ts
var import_chalk55 = __toESM(require_source(), 1);
var import_bytes2 = __toESM(require_bytes(), 1);

// src/util/build-state.ts
var isReady = ({ readyState }) => readyState === "READY";
var isFailed = ({ readyState }) => readyState.endsWith("_ERROR") || readyState === "ERROR";

// src/util/output/builds.ts
var padding = 8;
var MAX_BUILD_GROUPS = 5;
var MAX_OUTPUTS_PER_GROUP = 5;
var hasOutput = (b) => Array.isArray(b.output) && b.output.length > 0;
var getCommonPath = (buildGroup) => {
  const commonPath = [];
  const splits = buildGroup.map(
    (build) => getDirPath(build.entrypoint).split("/")
  );
  const shortest = splits.reduce(
    (prevValue, currentValue) => Math.min(prevValue, currentValue.length),
    Infinity
  );
  for (let i = 0; i <= shortest; i++) {
    const first = splits[0][i];
    if (splits.every((pathParts) => pathParts[i] === first)) {
      commonPath.push(first);
      continue;
    }
    break;
  }
  return commonPath.join("/") || "/";
};
var styleBuild = (build, times, longestSource) => {
  const { entrypoint, id } = build;
  const time = typeof times[id] === "string" ? times[id] : "";
  let pathColor = import_chalk55.default.cyan;
  if (isFailed(build)) {
    pathColor = import_chalk55.default.red;
  }
  const entry = entrypoint.padEnd(longestSource + padding);
  const prefix = hasOutput(build) ? "\u250C" : "\u2576";
  return `${import_chalk55.default.grey(prefix)} ${pathColor(entry)}${time}`;
};
var styleHiddenBuilds = (commonPath, buildGroup, times, longestSource, isHidden2 = false) => {
  const { id } = buildGroup[0];
  const entry = commonPath.padEnd(longestSource + padding);
  const time = typeof times[id] === "string" ? times[id] : "";
  const prefix = isHidden2 === false && buildGroup.some(hasOutput) ? "\u250C" : "\u2576";
  let pathColor = import_chalk55.default.cyan;
  if (buildGroup.every(isFailed)) {
    pathColor = import_chalk55.default.red;
  }
  if (isHidden2) {
    pathColor = import_chalk55.default.grey;
  }
  return `${import_chalk55.default.grey(prefix)} ${pathColor(entry)}${time}`;
};
var styleOutput = (output, readyState, isLast) => {
  const { type, path: path3, size, lambda } = output;
  const prefix = type === "lambda" ? "\u03BB " : "";
  const finalSize = size ? ` ${import_chalk55.default.grey(`(${(0, import_bytes2.default)(size)})`)}` : "";
  let color = import_chalk55.default.grey;
  let finalRegion = "";
  if (isReady({ readyState })) {
    color = import_chalk55.default;
  } else if (isFailed({ readyState })) {
    color = import_chalk55.default.red;
  }
  if (lambda) {
    const { deployedTo } = lambda;
    if (deployedTo && deployedTo.length > 0) {
      finalRegion = ` ${import_chalk55.default.grey(`[${deployedTo.join(", ")}]`)}`;
    }
  }
  const corner = isLast ? "\u2514\u2500\u2500" : "\u251C\u2500\u2500";
  const main17 = prefix + path3 + finalSize + finalRegion;
  return `${import_chalk55.default.grey(corner)} ${color(main17)}`;
};
var getDirPath = (path3, level = 0, highestLevel = null) => {
  const parts = path3.split("/").slice(0, -1);
  if (highestLevel === null || level === 0) {
    return parts.join("/");
  }
  const reverseLevel = highestLevel - level;
  return parts.slice(0, reverseLevel).join("/");
};
var sortByEntrypoint = (a, b) => {
  const aPath = getDirPath(a.entrypoint);
  const bPath = getDirPath(b.entrypoint);
  if (aPath === "") {
    return 1;
  }
  if (bPath === "") {
    return -1;
  }
  if (aPath > bPath) {
    return 1;
  }
  if (bPath > aPath) {
    return -1;
  }
  return 0;
};
var groupBuilds = (buildList, highestLevel, counter) => {
  const currentIndex = counter % buildList.length;
  const __level = Math.ceil(counter / buildList.length);
  const _level = (__level === 0 ? 1 : __level) - 1;
  const level = _level > highestLevel ? highestLevel : _level;
  const currentPath = getDirPath(
    buildList[currentIndex][0].entrypoint,
    level,
    highestLevel
  );
  const nextList = [];
  const currentGroup = [];
  for (let i = 0; i < buildList.length; i++) {
    const group = buildList[i];
    const path3 = getDirPath(group[0].entrypoint, level, highestLevel);
    if (path3 === currentPath) {
      currentGroup.push(...group);
    } else {
      nextList.push(group);
    }
  }
  if (currentIndex === 0) {
    nextList.unshift(currentGroup);
  } else {
    nextList.splice(currentIndex, 0, currentGroup);
  }
  return nextList;
};
var builds_default = (builds, times) => {
  let path3 = builds.sort(sortByEntrypoint).map((build) => [build]);
  const highestLevel = builds.reduce((prev, curr) => {
    const partCounter = curr.entrypoint.split("/").length - 1;
    return partCounter > prev ? partCounter : prev;
  }, 0);
  let counter = 0;
  while (path3.length > MAX_BUILD_GROUPS) {
    path3 = groupBuilds(path3, highestLevel, counter);
    counter++;
  }
  path3 = path3.reverse();
  const longestSource = builds.reduce((final2, current) => {
    const { length } = current.entrypoint;
    return length > final2 ? length : final2;
  }, 0);
  const final = [];
  let finalBuildsLength = path3.length;
  let lengthWithoutRootPaths = path3.length;
  const hiddenBuildGroup = [];
  path3 = (() => {
    const nextList = [];
    const rootList = [];
    for (const group of path3) {
      if (getCommonPath(group) === "/") {
        group.map((item) => rootList.push([item]));
      } else {
        nextList.push(group);
      }
    }
    lengthWithoutRootPaths = nextList.length;
    rootList.map((group) => nextList.push(group));
    return nextList;
  })();
  for (const buildGroup of path3) {
    const commonPath = getCommonPath(buildGroup);
    if (commonPath === "/") {
      if (lengthWithoutRootPaths <= MAX_BUILD_GROUPS && finalBuildsLength <= MAX_BUILD_GROUPS) {
        const item = buildGroup[0];
        final.push(`${styleBuild(item, times, longestSource)}
`);
        finalBuildsLength++;
      } else {
        hiddenBuildGroup.push(buildGroup[0]);
        continue;
      }
    } else if (buildGroup.length === 1) {
      const item = buildGroup[0];
      final.push(`${styleBuild(item, times, longestSource)}
`);
      finalBuildsLength++;
    } else {
      final.push(
        `${styleHiddenBuilds(
          `${commonPath}/*`,
          buildGroup,
          times,
          longestSource
        )}
`
      );
      finalBuildsLength++;
    }
    const outputs = [];
    for (const build of buildGroup) {
      if (Array.isArray(build.output)) {
        outputs.push(...build.output);
      }
    }
    outputs.slice(0, MAX_OUTPUTS_PER_GROUP).forEach(
      (output, index) => final.push(
        `${styleOutput(output, "READY", outputs.length === index + 1)}
`
      )
    );
    if (outputs.length > MAX_OUTPUTS_PER_GROUP) {
      final.push(
        import_chalk55.default.grey(
          `\u2514\u2500\u2500 ${outputs.length - MAX_OUTPUTS_PER_GROUP} output items hidden
`
        )
      );
    }
  }
  if (hiddenBuildGroup.length) {
    final.push(
      `${styleHiddenBuilds(
        `${hiddenBuildGroup.length} builds hidden`,
        hiddenBuildGroup,
        times,
        longestSource,
        true
      )}
`
    );
  }
  return {
    lines: final.length + 1,
    toPrint: `${final.join("")}`
  };
};

// src/util/output/indent.ts
var indent_default = (input, level) => {
  const fill = " ".repeat(level);
  return `${fill}${input.replace(/\n/g, `
${fill}`)}`;
};

// src/util/output/routes.ts
var import_chalk56 = __toESM(require_source(), 1);
var longestProperty = (routes2, name) => {
  const longestItem = routes2.sort((a, b) => {
    const aName = a[name];
    const bName = b[name];
    const firstItem = typeof aName === "string" ? aName.length : 0;
    const secondItem = typeof bName === "string" ? bName.length : 0;
    return secondItem - firstItem;
  })[0];
  const val = longestItem[name];
  return typeof val === "string" ? val.length : 0;
};
function routes(routes2) {
  let toPrint = "";
  const longestSrc = longestProperty(routes2, "src");
  const longestDest = longestProperty(routes2, "dest");
  const padding2 = 6;
  const space = " ".repeat(padding2);
  const destSpace = " ".repeat(longestDest || 10);
  const arrow = import_chalk56.default.grey("->");
  for (const item of routes2) {
    if ("handle" in item) {
      toPrint += `${import_chalk56.default.grey("\u2576")} ${import_chalk56.default.cyan(item.handle)}`;
      continue;
    }
    const { src, dest, status: status3, headers } = item;
    const last = routes2.indexOf(item) === routes2.length - 1;
    const suffix = last ? "" : `
`;
    const finalSrc = import_chalk56.default.cyan(src.padEnd(longestSrc + padding2));
    const finalDest = dest ? `${arrow}${space}${dest}` : `  ${space}${destSpace}`;
    const finalStatus = status3 ? import_chalk56.default.grey(`[${status3}]`) : "";
    let finalHeaders = null;
    if (headers) {
      finalHeaders = `
`;
      const headerKeys = Object.keys(headers);
      for (const header of headerKeys) {
        const value = headers[header];
        const last2 = headerKeys.indexOf(header) === headerKeys.length - 1;
        const suffix2 = last2 ? "" : `
`;
        const prefix2 = import_chalk56.default.grey(last2 ? "\u2514\u2500\u2500" : "\u251C\u2500\u2500");
        finalHeaders += `${prefix2} ${header}: ${value}${suffix2}`;
      }
    }
    const prefix = import_chalk56.default.grey(finalHeaders ? "\u250C" : "\u2576");
    const fill = `${finalSrc}${finalDest}${space}${finalStatus}`;
    toPrint += `${prefix} ${fill}${finalHeaders || ""}${suffix}`;
  }
  return toPrint;
}

// src/util/telemetry/commands/inspect/index.ts
var InspectTelemetryClient = class extends TelemetryClient {
  trackCliArgumentUrlOrDeploymentId(idOrHost) {
    if (idOrHost) {
      this.trackCliArgument({
        arg: "deploymentIdOrHost",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionTimeout(timeout) {
    if (timeout) {
      this.trackCliOption({
        option: "timeout",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagLogs(logs2) {
    if (logs2) {
      this.trackCliFlag("logs");
    }
  }
  trackCliFlagWait(wait) {
    if (wait) {
      this.trackCliFlag("wait");
    }
  }
  trackCliFlagJson(json) {
    if (json) {
      this.trackCliFlag("json");
    }
  }
};

// src/commands/inspect/index.ts
async function inspect3(client) {
  const { print, error, warn } = output_manager_default;
  const telemetry2 = new InspectTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArguments;
  const flagsSpecification = getFlagsSpecification(inspectCommand.options);
  try {
    parsedArguments = parseArguments(client.argv.slice(2), flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  if (parsedArguments.flags["--help"]) {
    telemetry2.trackCliFlagHelp("inspect");
    print(help(inspectCommand, { columns: client.stderr.columns }));
    return 2;
  }
  if (parsedArguments.args[0] === inspectCommand.name) {
    parsedArguments.args.shift();
  }
  let [deploymentIdOrHost] = parsedArguments.args;
  if (!deploymentIdOrHost) {
    const stdInput = await readStandardInput(client.stdin);
    if (stdInput) {
      deploymentIdOrHost = stdInput;
    }
  }
  if (!deploymentIdOrHost) {
    error(`${getCommandName("inspect <url>")} expects exactly one argument`);
    print(help(inspectCommand, { columns: client.stderr.columns }));
    return 1;
  }
  telemetry2.trackCliArgumentUrlOrDeploymentId(deploymentIdOrHost);
  telemetry2.trackCliOptionTimeout(parsedArguments.flags["--timeout"]);
  telemetry2.trackCliFlagLogs(parsedArguments.flags["--logs"]);
  telemetry2.trackCliFlagWait(parsedArguments.flags["--wait"]);
  telemetry2.trackCliOptionFormat(parsedArguments.flags["--format"]);
  telemetry2.trackCliFlagJson(parsedArguments.flags["--json"]);
  const timeout = (0, import_ms13.default)(parsedArguments.flags["--timeout"] ?? "3m");
  if (timeout === void 0) {
    error(`Invalid timeout "${parsedArguments.flags["--timeout"]}"`);
    return 1;
  }
  let contextName = null;
  try {
    ({ contextName } = await getScope(client));
  } catch (err) {
    if ((0, import_error_utils6.isErrnoException)(err) && (err.code === "NOT_AUTHORIZED" || err.code === "TEAM_DELETED")) {
      error(err.message);
      return 1;
    }
    throw err;
  }
  const until = Date.now() + timeout;
  const wait = parsedArguments.flags["--wait"] ?? false;
  const withLogs = parsedArguments.flags["--logs"];
  const formatResult = validateJsonOutput(parsedArguments.flags);
  if (!formatResult.valid) {
    error(formatResult.error);
    return 1;
  }
  const asJson = formatResult.jsonOutput;
  const startTimestamp = Date.now();
  try {
    deploymentIdOrHost = new URL2(deploymentIdOrHost).hostname;
  } catch {
  }
  output_manager_default.spinner(
    `Fetching deployment "${deploymentIdOrHost}" in ${import_chalk57.default.bold(contextName)}`
  );
  let deployment = await getDeployment(client, contextName, deploymentIdOrHost);
  let abortController;
  if (withLogs && !asJson) {
    let promise;
    ({ abortController, promise } = displayBuildLogs(client, deployment, wait));
    if (wait) {
      promise.catch((error2) => warn(`Failed to read build logs: ${error2}`));
    } else {
      await promise;
    }
  }
  while (wait) {
    await sleep(250);
    deployment = await getDeployment(client, contextName, deploymentIdOrHost);
    if (!isDeploying(deployment.readyState)) {
      abortController?.abort();
      break;
    }
    if (Date.now() > until) {
      warn(`stopped waiting after ${(0, import_ms13.default)(timeout, { long: true })}`);
      abortController?.abort();
      break;
    }
  }
  if (asJson) {
    output_manager_default.stopSpinner();
    await printJson({ deployment, contextName, client });
  } else if (withLogs) {
    print(`${import_chalk57.default.cyan("status")}	${stateString(deployment.readyState)}
`);
  } else {
    await printDetails({ deployment, contextName, client, startTimestamp });
  }
  return exitCode(deployment.readyState);
}
function stateString(s) {
  const CIRCLE = "\u25CF ";
  const sTitle = s && (0, import_title.default)(s);
  switch (s) {
    case "INITIALIZING":
    case "BUILDING":
      return import_chalk57.default.yellow(CIRCLE) + sTitle;
    case "ERROR":
      return import_chalk57.default.red(CIRCLE) + sTitle;
    case "READY":
      return import_chalk57.default.green(CIRCLE) + sTitle;
    case "QUEUED":
      return import_chalk57.default.gray(CIRCLE) + sTitle;
    case "CANCELED":
      return import_chalk57.default.gray(CIRCLE) + sTitle;
    default:
      return import_chalk57.default.gray("UNKNOWN");
  }
}
async function printDetails({
  deployment,
  contextName,
  client,
  startTimestamp
}) {
  output_manager_default.log(
    `Fetched deployment "${import_chalk57.default.bold(deployment.url)}" in ${import_chalk57.default.bold(
      contextName
    )} ${elapsed(Date.now() - startTimestamp)}`
  );
  const {
    id,
    name,
    url,
    createdAt,
    routes: routes2,
    readyState,
    alias: aliases
  } = deployment;
  const { print, link } = output_manager_default;
  const { builds } = deployment.version === 2 ? await client.fetch(`/v11/deployments/${id}/builds`) : { builds: [] };
  print("\n");
  print(import_chalk57.default.bold("  General\n\n"));
  print(`    ${import_chalk57.default.cyan("id")}		${id}
`);
  print(`    ${import_chalk57.default.cyan("name")}	${name}
`);
  const customEnvironmentSlug = deployment.customEnvironment?.slug;
  const target = customEnvironmentSlug ?? deployment.target ?? "preview";
  print(`    ${import_chalk57.default.cyan("target")}	`);
  print(
    deployment.customEnvironment && deployment.team?.slug ? `${link(
      `${target}`,
      `https://vercel.com/${deployment.team.slug}/${name}/settings/environments/${deployment.customEnvironment.id}`,
      { fallback: () => target, color: false }
    )}
` : `${target}
`
  );
  print(`    ${import_chalk57.default.cyan("status")}	${stateString(readyState)}
`);
  print(`    ${import_chalk57.default.cyan("url")}		https://${url}
`);
  if (createdAt) {
    print(
      `    ${import_chalk57.default.cyan("created")}	${new Date(createdAt)} ${elapsed(
        Date.now() - createdAt,
        true
      )}
`
    );
  }
  print("\n\n");
  if (aliases !== void 0 && aliases.length > 0) {
    print(import_chalk57.default.bold("  Aliases\n\n"));
    let aliasList = "";
    for (const alias2 of aliases) {
      aliasList += `${import_chalk57.default.gray("\u2576")} https://${alias2}
`;
    }
    print(indent_default(aliasList, 4));
    print("\n\n");
  }
  if (builds.length > 0) {
    const times = {};
    for (const build of builds) {
      const { id: id2, createdAt: createdAt2, readyStateAt } = build;
      times[id2] = createdAt2 && readyStateAt ? elapsed(readyStateAt - createdAt2) : null;
    }
    print(import_chalk57.default.bold("  Builds\n\n"));
    print(indent_default(builds_default(builds, times).toPrint, 4));
    print("\n\n");
  }
  if (Array.isArray(routes2) && routes2.length > 0) {
    print(import_chalk57.default.bold("  Routes\n\n"));
    print(indent_default(routes(routes2), 4));
    print(`

`);
  }
}
async function printJson({
  deployment,
  contextName,
  client
}) {
  const {
    id,
    name,
    url,
    createdAt,
    routes: routes2,
    readyState,
    alias: aliases,
    target,
    customEnvironment
  } = deployment;
  const { builds } = deployment.version === 2 ? await client.fetch(`/v11/deployments/${id}/builds`) : { builds: [] };
  const jsonOutput = {
    id,
    name,
    url,
    target: customEnvironment?.slug ?? target ?? "preview",
    readyState,
    createdAt,
    ...aliases && aliases.length > 0 && { aliases },
    ...builds.length > 0 && { builds },
    ...Array.isArray(routes2) && routes2.length > 0 && { routes: routes2 },
    ...contextName && { contextName }
  };
  client.stdout.write(`${JSON.stringify(jsonOutput, null, 2)}
`);
}
function exitCode(state) {
  if (state === "ERROR" || state === "CANCELED") {
    return 1;
  }
  return 0;
}

// src/commands/integration/add.ts
var import_chalk61 = __toESM(require_source(), 1);
var import_open3 = __toESM(require_open(), 1);

// src/util/integration/post-provision-setup.ts
var import_chalk58 = __toESM(require_source(), 1);
async function postProvisionSetup(client, resourceName, resourceId, contextName, options = {}) {
  const dashboardUrl = `https://vercel.com/${contextName}/~/stores/integration/${resourceId}`;
  output_manager_default.log(
    indent_default(`Dashboard: ${output_manager_default.link(dashboardUrl, dashboardUrl)}`, 4)
  );
  if (options.noConnect) {
    return 0;
  }
  const linkedProject = await getLinkedProject(client);
  if (linkedProject.status === "error") {
    return linkedProject.exitCode;
  }
  if (linkedProject.status === "not_linked") {
    return 0;
  }
  const { project } = linkedProject;
  const environments = ["production", "preview", "development"];
  output_manager_default.debug(`Selected environments: ${JSON.stringify(environments)}`);
  output_manager_default.spinner(
    `Connecting ${import_chalk58.default.bold(resourceName)} to ${import_chalk58.default.bold(project.name)}...`
  );
  output_manager_default.debug(`Connecting resource ${resourceId} to project ${project.id}`);
  try {
    await connectResourceToProject(
      client,
      project.id,
      resourceId,
      environments
    );
  } catch (error) {
    output_manager_default.stopSpinner();
    output_manager_default.error(`Failed to connect: ${error.message}`);
    return 1;
  }
  output_manager_default.stopSpinner();
  output_manager_default.log(
    `${import_chalk58.default.bold(resourceName)} successfully connected to ${import_chalk58.default.bold(project.name)}`
  );
  if (!options.noEnvPull) {
    const pullExitCode = await pull(
      client,
      ["--yes"],
      "vercel-cli:integration:add"
    );
    if (pullExitCode !== 0) {
      output_manager_default.warn(
        "Failed to pull environment variables. You can run `vercel env pull` manually."
      );
    }
  }
  return 0;
}
async function getLinkedProjectField(client, noConnect, field = "name") {
  if (noConnect) {
    return { value: void 0 };
  }
  const linkedProject = await getLinkedProject(client);
  if (linkedProject.status === "error") {
    return { value: void 0, exitCode: linkedProject.exitCode };
  }
  if (linkedProject.status === "linked") {
    return { value: linkedProject.project[field] };
  }
  return { value: void 0 };
}

// src/commands/integration/wizard.ts
var supportedUIControls = /* @__PURE__ */ new Set([
  "input",
  "select",
  "region",
  "vercel-region"
]);
function createHiddenStep(key, schema) {
  if (schema["ui:hidden"] !== true && schema["ui:hidden"] !== "create") {
    throw new Error(
      `HiddenStep: Expected "ui:hidden" to have value 'true' or '"create"' for key "${key}", but was "${schema["ui:hidden"]}"`
    );
  }
  return {
    key,
    run: async () => {
      const value = schema.default;
      return [key, value];
    }
  };
}
function createInputStep(key, schema) {
  if (schema["ui:control"] !== "input") {
    throw new Error(
      `InputStep: Expected control "input" for key "${key}", but was "${schema["ui:control"]}"`
    );
  }
  switch (schema.type) {
    case "string": {
      return {
        key,
        run: async (client) => {
          const value = await client.input.text({
            message: schema["ui:placeholder"] || schema["ui:label"] || key,
            default: schema.default
          });
          return [key, value];
        }
      };
    }
    case "number": {
      return {
        key,
        run: async (client) => {
          const value = await client.input.text({
            message: schema["ui:placeholder"] || schema["ui:label"] || key,
            default: schema.default,
            validate: (value2) => {
              const number = Number(value2);
              if (Number.isNaN(number)) {
                return `Value "${value2}" must be a number.`;
              }
              if (schema.minimum !== void 0 && schema.minimum > number) {
                return `Value "${value2}" must be greater or equal ${schema.minimum}.`;
              }
              if (schema.maximum !== void 0 && schema.maximum < number) {
                return `Value "${value2}" must be smaller or equal ${schema.maximum}.`;
              }
              return true;
            }
          });
          return [key, value];
        }
      };
    }
    default: {
      throw new Error(
        `[Input Step] Unsupported schema type for input control of key "${key}": ${schema.type}`
      );
    }
  }
}
function createSelectStep(key, schema) {
  if (!["select", "region", "vercel-region"].includes(schema["ui:control"])) {
    throw new Error(
      `SelectStep: Expected control "select", "region" or "vercel-region", but was "${schema["ui:control"]}"`
    );
  }
  if (!schema["ui:options"]?.length) {
    throw new Error(
      `SelectStep: Expected control for key "${key}" to have options, but was ${JSON.stringify(schema["ui:options"])}`
    );
  }
  const options = schema["ui:options"];
  const choices = [];
  const defaultValue = schema.default;
  for (const option of options) {
    if (typeof option === "string") {
      choices.push({
        name: option,
        value: option,
        short: option,
        selected: Boolean(defaultValue && option === defaultValue)
      });
    } else {
      if (option.hidden) {
        continue;
      }
      choices.push({
        name: option.label,
        value: option.value,
        short: option.label,
        selected: Boolean(defaultValue && option.value === defaultValue)
      });
    }
  }
  return {
    key,
    run: async (client) => {
      const value = await list(client, {
        message: schema["ui:placeholder"] || schema["ui:label"] || key,
        choices
      });
      return [key, value];
    }
  };
}
function createMetadataWizard(metadataSchema) {
  const properties = metadataSchema.properties;
  let isSupported = true;
  let allFieldsAreReadonly = true;
  const steps = [];
  for (const [key, schema] of Object.entries(properties)) {
    try {
      if (isHidden(schema)) {
        steps.push(createHiddenStep(key, schema));
        continue;
      }
      if (isDisabled(schema)) {
        continue;
      }
      if (!supportedUIControls.has(schema["ui:control"])) {
        isSupported = false;
        break;
      }
      if (!isReadOnly(schema)) {
        allFieldsAreReadonly = false;
      }
    } catch (error) {
      if (error instanceof ExpressionError) {
        isSupported = false;
        break;
      }
      throw error;
    }
    switch (schema["ui:control"]) {
      case "input": {
        steps.push(createInputStep(key, schema));
        break;
      }
      case "region":
      case "vercel-region":
      case "select": {
        steps.push(createSelectStep(key, schema));
        break;
      }
      default: {
        throw new Error(
          `Unsupported metadata control: ${schema["ui:control"]}`
        );
      }
    }
  }
  return {
    isSupported,
    run: async (client, initialValues) => allFieldsAreReadonly ? getMetadataFromReadOnlyFields(metadataSchema) : getMetadataFromSteps(client, steps, initialValues)
  };
}
function getMetadataFromReadOnlyFields(metadataSchema) {
  const metadata = {};
  for (const [key, schema] of Object.entries(metadataSchema.properties)) {
    if (isHidden(schema)) {
      continue;
    }
    if (!isReadOnly(schema)) {
      throw new Error(`Field "${key}" must be read-only.`);
    }
    metadata[key] = schema.default;
  }
  return metadata;
}
async function getMetadataFromSteps(client, steps, initialValues) {
  const metadataEntries = [];
  for (const step of steps) {
    if (initialValues && initialValues[step.key] !== void 0) {
      metadataEntries.push([step.key, initialValues[step.key]]);
    } else {
      metadataEntries.push(await step.run(client));
    }
  }
  return Object.fromEntries(metadataEntries);
}
function isHidden(schema) {
  if (instanceOfExpression(schema["ui:hidden"])) {
    throw new ExpressionError("Expression found in schema");
  }
  return Boolean(
    schema["ui:hidden"] === true || schema["ui:hidden"] === "create"
  );
}
function isReadOnly(schema) {
  if (instanceOfExpression(schema["ui:read-only"])) {
    throw new ExpressionError("Expression found in schema");
  }
  return Boolean(
    schema["ui:read-only"] === true || schema["ui:read-only"] === "create"
  );
}
function isDisabled(schema) {
  if (instanceOfExpression(schema["ui:disabled"])) {
    throw new ExpressionError("Expression found in schema");
  }
  return Boolean(
    schema["ui:disabled"] === true || schema["ui:disabled"] === "create"
  );
}
function instanceOfExpression(obj) {
  const checkedAsObject = Object(obj);
  if (obj !== checkedAsObject) {
    return false;
  }
  return "expr" in checkedAsObject;
}
var ExpressionError = class extends Error {
};

// src/util/integration/provision-store-resource.ts
async function provisionStoreResource(client, installationId, productId, billingPlanId, name, metadata, authorizationId) {
  return await client.fetch(
    "/v1/storage/stores/integration",
    {
      method: "POST",
      json: true,
      body: {
        billingPlanId,
        integrationConfigurationId: installationId,
        integrationProductIdOrSlug: productId,
        metadata,
        name,
        authorizationId,
        source: "cli"
      }
    }
  );
}

// src/util/integration/generate-resource-name.ts
var COLORS = [
  "gray",
  "red",
  "rose",
  "yellow",
  "amber",
  "green",
  "lime",
  "emerald",
  "blue",
  "lightblue",
  "cyan",
  "purple",
  "violet",
  "fuchsia",
  "orange",
  "pink",
  "indigo",
  "teal",
  "sky"
];
var NOUNS = [
  "apple",
  "ball",
  "car",
  "dog",
  "elephant",
  "flower",
  "garden",
  "house",
  "island",
  "jacket",
  "kite",
  "lamp",
  "mountain",
  "notebook",
  "ocean",
  "park",
  "queen",
  "river",
  "school",
  "tree",
  "umbrella",
  "village",
  "window",
  "xylophone",
  "yacht",
  "zebra",
  "book",
  "chair",
  "door",
  "grass"
];
function randomElement(arr) {
  return arr[Math.floor(arr.length * Math.random())];
}
function generateRandomNameSuffix() {
  return `${randomElement(COLORS)}-${randomElement(NOUNS)}`;
}
function generateDefaultResourceName(productSlug, maxLength = 128) {
  const suffix = generateRandomNameSuffix();
  const fullName = `${productSlug}-${suffix}`;
  if (fullName.length <= maxLength) {
    return fullName;
  }
  return fullName.slice(0, maxLength).replace(/-+$/, "");
}
var DEFAULT_VALIDATION_RULE = {
  minLength: 1,
  maxLength: 128,
  pattern: /^[a-zA-Z0-9_-]*$/,
  patternErrorMessage: "Resource name can only contain letters, numbers, underscores, and hyphens"
};
var VALIDATION_RULES = {
  "aws-dsql": {
    minLength: 1,
    maxLength: 128,
    pattern: /^[a-zA-Z0-9_-]*$/,
    patternErrorMessage: "Resource name can only contain letters, numbers, underscores, and hyphens"
  },
  "aws-apg": {
    minLength: 1,
    maxLength: 50,
    pattern: /^[a-zA-Z][a-zA-Z0-9-]*$/,
    patternErrorMessage: "Resource name must start with a letter and can only contain letters, numbers, and hyphens",
    customValidation: (name) => {
      if (name.endsWith("-")) {
        return "Resource name cannot end with a hyphen";
      }
      if (name.includes("--")) {
        return "Resource name cannot contain consecutive hyphens";
      }
      return void 0;
    }
  },
  "aws-dynamodb": {
    minLength: 3,
    maxLength: 128,
    pattern: /^[a-zA-Z0-9_-]*$/,
    patternErrorMessage: "Resource name can only contain letters, numbers, underscores, and hyphens"
  }
};
function getValidationRuleForProduct(productSlug) {
  if (!productSlug) {
    return DEFAULT_VALIDATION_RULE;
  }
  return VALIDATION_RULES[productSlug.toLowerCase()] ?? DEFAULT_VALIDATION_RULE;
}
function validateResourceName(name, productSlug) {
  const rule = getValidationRuleForProduct(productSlug);
  if (!name || name.trim().length === 0) {
    return "Resource name cannot be empty";
  }
  if (name.length < rule.minLength) {
    return `Resource name must be at least ${rule.minLength} character${rule.minLength === 1 ? "" : "s"}`;
  }
  if (name.length > rule.maxLength) {
    return `Resource name cannot exceed ${rule.maxLength} characters`;
  }
  if (!rule.pattern.test(name)) {
    return rule.patternErrorMessage;
  }
  if (rule.customValidation) {
    const customError = rule.customValidation(name);
    if (customError) {
      return customError;
    }
  }
  return void 0;
}
function resolveResourceName(productSlug, resourceNameArg) {
  const rule = getValidationRuleForProduct(productSlug);
  const resourceName = resourceNameArg ?? generateDefaultResourceName(productSlug, rule.maxLength);
  if (resourceNameArg !== void 0) {
    const validationError = validateResourceName(resourceNameArg, productSlug);
    if (validationError) {
      return { error: validationError };
    }
  }
  return { resourceName };
}

// src/util/integration/format-schema-help.ts
var import_chalk59 = __toESM(require_source(), 1);
function isHiddenOnCreate(prop) {
  return prop["ui:hidden"] === true || prop["ui:hidden"] === "create";
}
function getAllOptionValues(prop) {
  const raw = prop["ui:options"];
  if (!raw)
    return void 0;
  const values = raw.map(
    (opt) => typeof opt === "string" ? opt : opt.value
  );
  return values.length > 0 ? values : void 0;
}
function getVisibleOptions(prop) {
  const raw = prop["ui:options"];
  if (!raw)
    return void 0;
  const options = [];
  for (const opt of raw) {
    if (typeof opt === "string") {
      if (opt)
        options.push(opt);
    } else if (!opt.hidden && opt.value) {
      options.push(opt.value);
    }
  }
  return options.length > 0 ? options : void 0;
}
function generateExample(key, prop) {
  if (prop.type === "boolean") {
    return `-m ${key}=true`;
  }
  if (prop.type === "array") {
    const options2 = getVisibleOptions(prop);
    if (options2 && options2.length >= 2) {
      return `-m "${key}=${options2[0]},${options2[1]}"`;
    }
    if (options2 && options2.length === 1) {
      return `-m "${key}=${options2[0]}"`;
    }
    if (prop.items?.type === "number") {
      if (prop.default !== void 0) {
        return `-m ${key}=${prop.default}`;
      }
      return `-m ${key}=N,N`;
    }
    return `-m "${key}=value1,value2"`;
  }
  if (prop.type === "number") {
    if (prop.default !== void 0) {
      return `-m ${key}=${prop.default}`;
    }
    if (prop.minimum !== void 0) {
      return `-m ${key}=${prop.minimum}`;
    }
    return `-m ${key}=N`;
  }
  const options = getVisibleOptions(prop);
  if (options && options.length > 0) {
    return `-m ${key}=${options[0]}`;
  }
  return `-m ${key}=<value>`;
}
function formatMetadataSchemaHelp(schema, integrationName, productSlug) {
  const lines = [];
  lines.push("");
  const header = productSlug ? `  Metadata options for "${integrationName}/${productSlug}":` : `  Metadata options for "${integrationName}":`;
  lines.push(import_chalk59.default.bold(header));
  lines.push("");
  const required = new Set(schema.required ?? []);
  const entries = Object.entries(schema.properties);
  if (entries.length === 0) {
    lines.push("    No metadata options available.");
    return lines.join("\n");
  }
  for (const [key, prop] of entries) {
    if (isHiddenOnCreate(prop)) {
      continue;
    }
    const isRequired = required.has(key);
    const requiredSuffix = isRequired ? import_chalk59.default.red(" (required)") : "";
    const typeHint = prop.type === "boolean" ? import_chalk59.default.dim(" (true/false)") : prop.type === "array" ? import_chalk59.default.dim(" (comma-separated)") : "";
    lines.push(`    ${import_chalk59.default.cyan(key)}${requiredSuffix}${typeHint}`);
    if (prop.description) {
      lines.push(`      ${prop.description}`);
    }
    const visibleOptions = getVisibleOptions(prop);
    if (visibleOptions) {
      lines.push(`      Options: ${visibleOptions.join(", ")}`);
    }
    if (prop.minimum !== void 0 || prop.maximum !== void 0) {
      const range = [];
      if (prop.minimum !== void 0)
        range.push(`min: ${prop.minimum}`);
      if (prop.maximum !== void 0)
        range.push(`max: ${prop.maximum}`);
      lines.push(`      Range: ${range.join(", ")}`);
    }
    if (prop.default !== void 0) {
      lines.push(`      Default: ${prop.default}`);
    }
    const example = generateExample(key, prop);
    if (example) {
      lines.push(`      Example: ${import_chalk59.default.dim(example)}`);
    }
    lines.push("");
  }
  return lines.join("\n");
}

// src/util/integration/parse-metadata.ts
function parseMetadataFlags(rawMetadata, schema) {
  const metadata = {};
  const errors = [];
  if (!rawMetadata?.length) {
    return { metadata, errors };
  }
  for (const item of rawMetadata) {
    const eqIndex = item.indexOf("=");
    if (eqIndex === -1) {
      errors.push(`Invalid metadata format: "${item}". Expected KEY=VALUE`);
      continue;
    }
    const key = item.slice(0, eqIndex);
    const value = item.slice(eqIndex + 1);
    const propSchema = schema.properties[key];
    if (!propSchema) {
      errors.push(`Unknown metadata key: "${key}"`);
      continue;
    }
    if (propSchema.type === "boolean") {
      if (value === "true") {
        metadata[key] = true;
      } else if (value === "false") {
        metadata[key] = false;
      } else {
        errors.push(
          `Metadata "${key}" must be "true" or "false", got: "${value}"`
        );
        continue;
      }
    } else if (propSchema.type === "number") {
      if (value === "") {
        errors.push(`Metadata "${key}" must be a number, got: ""`);
        continue;
      }
      const num = Number(value);
      if (Number.isNaN(num) || !Number.isFinite(num)) {
        errors.push(`Metadata "${key}" must be a number, got: "${value}"`);
        continue;
      }
      if (propSchema.minimum !== void 0 && num < propSchema.minimum) {
        errors.push(`Metadata "${key}" must be >= ${propSchema.minimum}`);
        continue;
      }
      if (propSchema.maximum !== void 0 && num > propSchema.maximum) {
        errors.push(`Metadata "${key}" must be <= ${propSchema.maximum}`);
        continue;
      }
      metadata[key] = num;
    } else if (propSchema.type === "array") {
      const items = value.split(",").map((v) => v.trim());
      const itemType = propSchema.items?.type;
      if (itemType === "number") {
        const nums = [];
        let hasError = false;
        for (const item2 of items) {
          if (item2 === "") {
            errors.push(`Metadata "${key}" contains invalid number: ""`);
            hasError = true;
            break;
          }
          const num = Number(item2);
          if (Number.isNaN(num) || !Number.isFinite(num)) {
            errors.push(`Metadata "${key}" contains invalid number: "${item2}"`);
            hasError = true;
            break;
          }
          if (propSchema.minimum !== void 0 && num < propSchema.minimum) {
            errors.push(
              `Metadata "${key}" contains number ${num} below minimum ${propSchema.minimum}`
            );
            hasError = true;
            break;
          }
          if (propSchema.maximum !== void 0 && num > propSchema.maximum) {
            errors.push(
              `Metadata "${key}" contains number ${num} above maximum ${propSchema.maximum}`
            );
            hasError = true;
            break;
          }
          nums.push(num);
        }
        if (!hasError) {
          metadata[key] = nums;
        }
      } else {
        const validValues = getAllOptionValues(propSchema);
        if (validValues) {
          const prevErrorCount = errors.length;
          for (const item2 of items) {
            if (!validValues.includes(item2)) {
              errors.push(
                `Metadata "${key}" contains invalid value: "${item2}". Must be one of: ${validValues.join(", ")}`
              );
            }
          }
          if (errors.length > prevErrorCount) {
            continue;
          }
        }
        metadata[key] = items;
      }
    } else {
      const validValues = getAllOptionValues(propSchema);
      if (validValues) {
        if (!validValues.includes(value)) {
          errors.push(
            `Metadata "${key}" must be one of: ${validValues.join(", ")}`
          );
          continue;
        }
      }
      metadata[key] = value;
    }
  }
  return { metadata, errors };
}
function validateRequiredMetadata(metadata, schema) {
  const errors = [];
  const required = schema.required ?? [];
  for (const key of required) {
    const propSchema = schema.properties[key];
    if (propSchema && isHiddenOnCreate(propSchema)) {
      continue;
    }
    if (metadata[key] === void 0 && propSchema?.default === void 0) {
      errors.push(`Required metadata missing: "${key}"`);
    }
  }
  return errors;
}
function validateAndPrintRequiredMetadata(metadata, schema) {
  const errors = validateRequiredMetadata(metadata, schema);
  for (const error of errors) {
    output_manager_default.error(error);
  }
  return errors.length === 0;
}

// src/commands/integration/add-auto-provision.ts
var import_chalk60 = __toESM(require_source(), 1);
var import_open2 = __toESM(require_open(), 1);

// src/util/integration/auto-provision-resource.ts
function isAutoProvisionFallback(error) {
  return typeof error === "object" && error !== null && "kind" in error && ["install", "metadata", "unknown"].includes(
    error.kind
  ) && "url" in error && "integration" in error && "product" in error;
}
async function autoProvisionResource(client, integrationSlug, productSlug, name, metadata, acceptedPolicies) {
  const endpoint = `/v1/integrations/integration/${encodeURIComponent(integrationSlug)}/marketplace/auto-provision/${encodeURIComponent(productSlug)}`;
  const body = {
    name,
    metadata,
    acceptedPolicies,
    source: "cli"
  };
  output_manager_default.debug(`Auto-provision request: POST ${endpoint}`);
  output_manager_default.debug(`Auto-provision body: ${JSON.stringify(body, null, 2)}`);
  try {
    const res = await client.fetch(endpoint, {
      method: "POST",
      json: false,
      body
    });
    if (res.ok) {
      return res.json();
    }
    throw new Error(`Auto-provision failed: ${res.status}`);
  } catch (error) {
    if (error instanceof APIError && error.status === 422 && isAutoProvisionFallback(error)) {
      output_manager_default.debug(`Auto-provision returned 422 fallback response`);
      return error;
    }
    output_manager_default.debug(`Auto-provision error: ${error}`);
    throw error;
  }
}

// src/util/integration/fetch-integration.ts
async function fetchIntegration(client, slug) {
  return client.fetch(`/v2/integrations/integration/${slug}`, {
    json: true
  });
}
async function fetchIntegrationWithTelemetry(client, integrationSlug, telemetry2) {
  let knownIntegrationSlug = false;
  try {
    const integration = await fetchIntegration(client, integrationSlug);
    knownIntegrationSlug = true;
    return integration;
  } catch (error) {
    output_manager_default.error(
      `Failed to get integration "${integrationSlug}": ${error.message}`
    );
    return null;
  } finally {
    telemetry2.trackCliArgumentIntegration(
      integrationSlug,
      knownIntegrationSlug
    );
  }
}

// src/util/integration/select-product.ts
async function selectProduct(client, products, productSlug) {
  if (productSlug) {
    const match = products.find((p) => p.slug === productSlug);
    if (!match) {
      const available = products.map((p) => p.slug).join(", ");
      output_manager_default.error(
        `Product "${productSlug}" not found. Available products: ${available}`
      );
      return;
    }
    return match;
  }
  if (products.length === 1) {
    return products[0];
  }
  return client.input.select({
    message: "Select a product",
    choices: products.map((p) => ({
      name: p.name,
      value: p,
      description: p.shortDescription
    }))
  });
}

// src/util/telemetry/commands/integration/add.ts
var IntegrationAddTelemetryClient = class extends TelemetryClient {
  trackCliArgumentIntegration(v, known) {
    if (v) {
      this.trackCliArgument({
        arg: "integration",
        value: known ? v : this.redactedValue
      });
    }
  }
  trackCliOptionName(v) {
    if (v) {
      this.trackCliOption({
        option: "name",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionMetadata(v) {
    if (v?.length) {
      this.trackCliOption({
        option: "metadata",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagNoConnect(v) {
    if (v) {
      this.trackCliFlag("no-connect");
    }
  }
  trackCliFlagNoEnvPull(v) {
    if (v) {
      this.trackCliFlag("no-env-pull");
    }
  }
};

// src/commands/integration/add-auto-provision.ts
async function addAutoProvision(client, integrationSlug, resourceNameArg, options = {}) {
  const telemetry2 = new IntegrationAddTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  telemetry2.trackCliOptionName(resourceNameArg);
  telemetry2.trackCliOptionMetadata(options.metadata);
  telemetry2.trackCliFlagNoConnect(options.noConnect);
  telemetry2.trackCliFlagNoEnvPull(options.noEnvPull);
  const { contextName, team } = await getScope(client);
  if (!team) {
    output_manager_default.error("Team not found");
    return 1;
  }
  const integration = await fetchIntegrationWithTelemetry(
    client,
    integrationSlug,
    telemetry2
  );
  if (!integration) {
    return 1;
  }
  if (!integration.products?.length) {
    output_manager_default.error(
      `Integration "${integrationSlug}" is not a Marketplace integration`
    );
    return 1;
  }
  const product = await selectProduct(
    client,
    integration.products,
    options.productSlug
  );
  if (!product) {
    return 1;
  }
  output_manager_default.log(
    `Installing ${import_chalk60.default.bold(product.name)} by ${import_chalk60.default.bold(integration.name)} under ${import_chalk60.default.bold(contextName)}`
  );
  output_manager_default.debug(`Selected product: ${product.slug} (id: ${product.id})`);
  output_manager_default.debug(
    `Product metadataSchema: ${JSON.stringify(product.metadataSchema, null, 2)}`
  );
  let metadata;
  if (options.metadata?.length) {
    output_manager_default.debug(
      `Parsing metadata from flags: ${JSON.stringify(options.metadata)}`
    );
    const { metadata: parsed, errors } = parseMetadataFlags(
      options.metadata,
      product.metadataSchema
    );
    if (errors.length) {
      for (const error of errors) {
        output_manager_default.error(error);
      }
      return 1;
    }
    if (!validateAndPrintRequiredMetadata(parsed, product.metadataSchema)) {
      return 1;
    }
    metadata = parsed;
  } else {
    metadata = {};
  }
  const nameResult = resolveResourceName(product.slug, resourceNameArg);
  if ("error" in nameResult) {
    output_manager_default.error(nameResult.error);
    return 1;
  }
  const { resourceName } = nameResult;
  output_manager_default.debug(`Collected metadata: ${JSON.stringify(metadata)}`);
  output_manager_default.debug(`Resource name: ${resourceName}`);
  output_manager_default.spinner("Provisioning resource...");
  let result;
  try {
    result = await autoProvisionResource(
      client,
      integration.slug,
      product.slug,
      resourceName,
      metadata,
      {}
      // Start with empty policies
    );
  } catch (error) {
    output_manager_default.stopSpinner();
    output_manager_default.error(error.message);
    return 1;
  }
  output_manager_default.stopSpinner();
  output_manager_default.debug(`Auto-provision result: ${JSON.stringify(result, null, 2)}`);
  if (result.kind === "install") {
    output_manager_default.debug(`Policy acceptance required`);
    const policies = result.integration.policies ?? {};
    output_manager_default.debug(`Policies to accept: ${JSON.stringify(policies)}`);
    const acceptedPolicies = {};
    if (policies.privacy) {
      const accepted = await client.input.confirm(
        `Accept privacy policy? (${policies.privacy})`,
        false
      );
      if (!accepted) {
        output_manager_default.error("Privacy policy must be accepted to continue.");
        return 1;
      }
      acceptedPolicies.privacy = (/* @__PURE__ */ new Date()).toISOString();
    }
    if (policies.eula) {
      const accepted = await client.input.confirm(
        `Accept terms of service? (${policies.eula})`,
        false
      );
      if (!accepted) {
        output_manager_default.error("Terms of service must be accepted to continue.");
        return 1;
      }
      acceptedPolicies.eula = (/* @__PURE__ */ new Date()).toISOString();
    }
    output_manager_default.debug(`Accepted policies: ${JSON.stringify(acceptedPolicies)}`);
    output_manager_default.spinner("Provisioning resource...");
    try {
      result = await autoProvisionResource(
        client,
        integration.slug,
        product.slug,
        resourceName,
        metadata,
        acceptedPolicies
      );
    } catch (error) {
      output_manager_default.stopSpinner();
      output_manager_default.error(error.message);
      return 1;
    }
    output_manager_default.stopSpinner();
    output_manager_default.debug(
      `Auto-provision retry result: ${JSON.stringify(result, null, 2)}`
    );
  }
  if (result.kind !== "provisioned") {
    output_manager_default.debug(`Fallback required - kind: ${result.kind}`);
    output_manager_default.debug(`Fallback URL from API: ${result.url}`);
    const projectLink = await getLinkedProjectField(
      client,
      options.noConnect,
      "name"
    );
    if (projectLink.exitCode !== void 0) {
      return projectLink.exitCode;
    }
    output_manager_default.log("Additional setup required. Opening browser...");
    const url = new URL(result.url);
    url.searchParams.set("defaultResourceName", resourceName);
    url.searchParams.set("source", "cli");
    if (Object.keys(metadata).length > 0) {
      url.searchParams.set("metadata", JSON.stringify(metadata));
    }
    if (projectLink.value) {
      url.searchParams.set("projectSlug", projectLink.value);
    }
    output_manager_default.debug(`Opening URL: ${url.href}`);
    (0, import_open2.default)(url.href);
    return 0;
  }
  output_manager_default.debug(
    `Provisioned resource: ${JSON.stringify(result.resource, null, 2)}`
  );
  output_manager_default.debug(`Installation: ${JSON.stringify(result.installation, null, 2)}`);
  output_manager_default.debug(`Billing plan: ${JSON.stringify(result.billingPlan, null, 2)}`);
  output_manager_default.success(
    `${product.name} successfully provisioned: ${import_chalk60.default.bold(resourceName)}`
  );
  return postProvisionSetup(
    client,
    resourceName,
    result.resource.id,
    contextName,
    options
  );
}

// src/util/integration/fetch-billing-plans.ts
async function fetchBillingPlans(client, integration, product, metadata) {
  const searchParams = new URLSearchParams();
  searchParams.set("metadata", JSON.stringify(metadata));
  return client.fetch(
    `/v1/integrations/integration/${integration.id}/products/${product.id}/plans?${searchParams}`,
    {
      json: true
    }
  );
}

// src/util/integration/fetch-installations.ts
async function fetchInstallations(client, integration) {
  const searchParams = new URLSearchParams();
  searchParams.set("view", "account");
  searchParams.set("installationType", "marketplace");
  searchParams.set("integrationIdOrSlug", integration.id);
  return client.fetch(
    `/v2/integrations/configurations?${searchParams}`,
    {
      json: true
    }
  );
}

// src/util/integration/create-authorization.ts
async function createAuthorization(client, integrationIdOrSlug, installationId, productId, billingPlanId, metadata, prepaymentAmountCents) {
  return await client.fetch("/v1/integrations/billing/authorization", {
    method: "POST",
    json: true,
    body: {
      billingPlanId,
      integrationIdOrSlug,
      integrationConfigurationId: installationId,
      productId,
      metadata: JSON.stringify(metadata),
      prepaymentAmountCents
    }
  });
}

// src/util/integration/fetch-authorization.ts
async function fetchAuthorization(client, authorizationId) {
  return client.fetch(
    `/v1/integrations/billing/authorization/${authorizationId}`,
    {
      json: true
    }
  );
}

// src/commands/integration/add.ts
async function add5(client, args, resourceNameArg, metadataFlags, options = {}) {
  if (args.length > 1) {
    output_manager_default.error("Cannot install more than one integration at a time");
    return 1;
  }
  const rawArg = args[0];
  if (!rawArg) {
    output_manager_default.error("You must pass an integration slug");
    return 1;
  }
  let integrationSlug;
  let productSlug;
  const slashIndex = rawArg.indexOf("/");
  if (slashIndex !== -1) {
    integrationSlug = rawArg.substring(0, slashIndex);
    productSlug = rawArg.substring(slashIndex + 1);
    if (!integrationSlug || !productSlug) {
      output_manager_default.error(
        "Invalid format. Expected: <integration-name>/<product-slug>"
      );
      return 1;
    }
  } else {
    integrationSlug = rawArg;
  }
  if (process.env.FF_AUTO_PROVISION_INSTALL === "1") {
    return await addAutoProvision(client, integrationSlug, resourceNameArg, {
      productSlug,
      metadata: metadataFlags,
      noConnect: options.noConnect,
      noEnvPull: options.noEnvPull
    });
  }
  const telemetry2 = new IntegrationAddTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  telemetry2.trackCliOptionName(resourceNameArg);
  telemetry2.trackCliOptionMetadata(metadataFlags);
  telemetry2.trackCliFlagNoConnect(options.noConnect);
  telemetry2.trackCliFlagNoEnvPull(options.noEnvPull);
  const { contextName, team } = await getScope(client);
  if (!team) {
    output_manager_default.error("Team not found");
    return 1;
  }
  const integration = await fetchIntegrationWithTelemetry(
    client,
    integrationSlug,
    telemetry2
  );
  if (!integration) {
    return 1;
  }
  if (!integration.products?.length) {
    output_manager_default.error(
      `Integration "${integrationSlug}" is not a Marketplace integration`
    );
    return 1;
  }
  const [productResult, installationsResult] = await Promise.allSettled([
    selectProduct(client, integration.products, productSlug),
    fetchInstallations(client, integration)
  ]);
  if (productResult.status === "rejected") {
    output_manager_default.error(
      `Failed to select product: ${productResult.reason.message}`
    );
    return 1;
  }
  if (!productResult.value) {
    if (!productSlug) {
      output_manager_default.error("Product not found");
    }
    return 1;
  }
  if (installationsResult.status === "rejected") {
    output_manager_default.error(
      `Failed to get integration installations: ${installationsResult.reason}`
    );
    return 1;
  }
  const product = productResult.value;
  const installations = installationsResult.value;
  const teamInstallations = installations.filter(
    (install2) => install2.ownerId === team.id && install2.installationType === "marketplace"
  );
  if (teamInstallations.length > 1) {
    output_manager_default.error(
      `Found more than one existing installation of ${integration.name}. Please contact Vercel Support at https://vercel.com/help`
    );
    return 1;
  }
  const installation = teamInstallations[0];
  output_manager_default.log(
    `Installing ${import_chalk61.default.bold(product.name)} by ${import_chalk61.default.bold(integration.name)} under ${import_chalk61.default.bold(contextName)}`
  );
  const metadataSchema = product.metadataSchema;
  const metadataWizard = createMetadataWizard(metadataSchema);
  const nameResult = resolveResourceName(product.slug, resourceNameArg);
  if ("error" in nameResult) {
    output_manager_default.error(nameResult.error);
    return 1;
  }
  const { resourceName } = nameResult;
  let parsedMetadata;
  if (metadataFlags?.length) {
    const { metadata: parsed, errors } = parseMetadataFlags(
      metadataFlags,
      metadataSchema
    );
    if (errors.length) {
      for (const error of errors) {
        output_manager_default.error(error);
      }
      return 1;
    }
    parsedMetadata = parsed;
  }
  const provisionResourceViaCLIIsSupported = installation && (parsedMetadata || metadataWizard.isSupported);
  if (!provisionResourceViaCLIIsSupported) {
    const projectLink = await getLinkedProjectField(
      client,
      options.noConnect,
      "id"
    );
    if (projectLink.exitCode) {
      return projectLink.exitCode;
    }
    const openInWeb = await client.input.confirm(
      !installation ? "Terms have not been accepted. Open Vercel Dashboard?" : "This resource must be provisioned through the Web UI. Open Vercel Dashboard?",
      true
    );
    if (openInWeb) {
      provisionResourceViaWebUI(
        team.id,
        integration.id,
        product.id,
        projectLink.value,
        resourceName,
        parsedMetadata
      );
    }
    return 0;
  }
  return await provisionResourceViaCLI(
    client,
    team.id,
    contextName,
    integration,
    installation,
    product,
    metadataWizard,
    resourceName,
    parsedMetadata,
    options
  );
}
function provisionResourceViaWebUI(teamId, integrationId, productId, projectId, resourceName, metadata) {
  const url = new URL("/api/marketplace/cli", "https://vercel.com");
  url.searchParams.set("teamId", teamId);
  url.searchParams.set("integrationId", integrationId);
  url.searchParams.set("productId", productId);
  url.searchParams.set("source", "cli");
  if (projectId) {
    url.searchParams.set("projectId", projectId);
  }
  if (resourceName) {
    url.searchParams.set("defaultResourceName", resourceName);
  }
  if (metadata && Object.keys(metadata).length > 0) {
    url.searchParams.set("metadata", JSON.stringify(metadata));
  }
  url.searchParams.set("cmd", "add");
  output_manager_default.print("Opening the Vercel Dashboard to continue the installation...");
  output_manager_default.debug(`Opening URL: ${url.href}`);
  (0, import_open3.default)(url.href);
}
async function provisionResourceViaCLI(client, teamId, contextName, integration, installation, product, metadataWizard, name, parsedMetadata, options = {}) {
  let metadata;
  if (parsedMetadata) {
    if (client.stdin.isTTY && metadataWizard.isSupported) {
      metadata = await metadataWizard.run(client, parsedMetadata);
    } else {
      if (!validateAndPrintRequiredMetadata(
        parsedMetadata,
        product.metadataSchema
      )) {
        return 1;
      }
      metadata = parsedMetadata;
    }
  } else if (!client.stdin.isTTY) {
    if (validateRequiredMetadata({}, product.metadataSchema).length > 0) {
      output_manager_default.error(
        "Metadata is required in non-interactive mode. Use --metadata KEY=VALUE flags. Run 'vercel integration add <name> --help' to see available keys."
      );
      return 1;
    }
    metadata = {};
  } else {
    metadata = await metadataWizard.run(client);
  }
  let billingPlans;
  try {
    const billingPlansResponse = await fetchBillingPlans(
      client,
      integration,
      product,
      metadata
    );
    billingPlans = billingPlansResponse.plans;
  } catch (error) {
    output_manager_default.error(`Failed to get billing plans: ${error.message}`);
    return 1;
  }
  const enabledBillingPlans = billingPlans.filter((plan) => !plan.disabled);
  if (!enabledBillingPlans.length) {
    output_manager_default.error("No billing plans available");
    return 1;
  }
  const billingPlan = await selectBillingPlan(client, enabledBillingPlans);
  if (!billingPlan) {
    output_manager_default.error("No billing plan selected");
    return 1;
  }
  if (billingPlan.type !== "subscription") {
    const projectLink = await getLinkedProjectField(
      client,
      options.noConnect,
      "id"
    );
    if (projectLink.exitCode) {
      return projectLink.exitCode;
    }
    const openInWeb = await client.input.confirm(
      "You have selected a plan that cannot be provisioned through the CLI. Open Vercel Dashboard?",
      true
    );
    if (openInWeb) {
      provisionResourceViaWebUI(
        teamId,
        integration.id,
        product.id,
        projectLink.value,
        name,
        metadata
      );
    }
    return 0;
  }
  const confirmed = await confirmProductSelection(
    client,
    product,
    name,
    metadata,
    billingPlan
  );
  if (!confirmed) {
    return 1;
  }
  try {
    const authorizationId = await getAuthorizationId(
      client,
      teamId,
      installation,
      product,
      metadata,
      billingPlan
    );
    return await provisionStorageProduct(
      client,
      product,
      installation,
      name,
      metadata,
      billingPlan,
      authorizationId,
      contextName,
      options
    );
  } catch (error) {
    output_manager_default.error(error.message);
    return 1;
  }
}
async function selectBillingPlan(client, billingPlans) {
  const billingPlanId = await list(client, {
    message: "Choose a billing plan",
    separator: true,
    choices: billingPlans.map((plan) => {
      const body = [plan.description];
      if (plan.type !== "subscription") {
        body.push(
          "This plan is not subscription-based. Selecting it will prompt you to use the Vercel Dashboard."
        );
      }
      if (plan.details?.length) {
        const detailsTable = formatTable(
          ["", ""],
          ["l", "r"],
          [
            {
              name: "Details",
              rows: plan.details.map((detail) => [
                detail.label,
                detail.value || "-"
              ])
            }
          ]
        );
        body.push(detailsTable);
      }
      if (plan.highlightedDetails?.length) {
        const hightlightedDetailsTable = formatTable(
          ["", ""],
          ["l", "r"],
          [
            {
              name: "More Details",
              rows: plan.highlightedDetails.map((detail) => [
                detail.label,
                detail.value || "-"
              ])
            }
          ]
        );
        body.push(hightlightedDetailsTable);
      }
      let planName = plan.name;
      if (plan.cost) {
        planName += ` ${plan.cost}`;
      }
      return {
        name: [planName, "", indent_default(body.join("\n"), 4)].join("\n"),
        value: plan.id,
        short: planName,
        disabled: plan.disabled
      };
    }),
    pageSize: 1e3
  });
  return billingPlans.find((plan) => plan.id === billingPlanId);
}
async function confirmProductSelection(client, product, name, metadata, billingPlan) {
  output_manager_default.print("Selected product:\n");
  output_manager_default.print(`${import_chalk61.default.dim(`- ${import_chalk61.default.bold("Name:")} ${name}`)}
`);
  for (const [key, value] of Object.entries(metadata)) {
    output_manager_default.print(
      `${import_chalk61.default.dim(`- ${import_chalk61.default.bold(`${product.metadataSchema.properties[key]["ui:label"]}:`)} ${value}`)}
`
    );
  }
  output_manager_default.print(
    `${import_chalk61.default.dim(`- ${import_chalk61.default.bold("Plan:")} ${billingPlan.name}`)}
`
  );
  return client.input.confirm("Confirm selection?", true);
}
async function getAuthorizationId(client, teamId, installation, product, metadata, billingPlan) {
  output_manager_default.spinner("Validating payment...", 250);
  const originalAuthorizationState = await createAuthorization(
    client,
    installation.integrationId,
    installation.id,
    product.id,
    billingPlan.id,
    metadata
  );
  if (!originalAuthorizationState.authorization) {
    output_manager_default.stopSpinner();
    throw new Error(
      "Failed to get an authorization state. If the problem persists, please contact support."
    );
  }
  let authorization = originalAuthorizationState.authorization;
  while (authorization.status === "pending") {
    await sleep(200);
    authorization = await fetchAuthorization(
      client,
      originalAuthorizationState.authorization.id
    );
  }
  output_manager_default.stopSpinner();
  if (authorization.status === "succeeded") {
    output_manager_default.log("Validation complete.");
    return authorization.id;
  }
  if (authorization.status === "failed") {
    throw new Error(
      "Payment validation failed. Please change your payment method via the web UI and try again."
    );
  }
  output_manager_default.spinner(
    "Payment validation requires manual action. Please complete the steps in your browser..."
  );
  handleManualVerificationAction(
    teamId,
    originalAuthorizationState.authorization.id
  );
  while (authorization.status !== "succeeded") {
    await sleep(200);
    authorization = await fetchAuthorization(
      client,
      originalAuthorizationState.authorization.id
    );
    if (authorization.status === "failed") {
      throw new Error(
        "Payment validation failed. Please change your payment method via the web UI and try again."
      );
    }
  }
  output_manager_default.stopSpinner();
  output_manager_default.log("Validation complete.");
  return authorization.id;
}
function handleManualVerificationAction(teamId, authorizationId) {
  const url = new URL("/api/marketplace/cli", "https://vercel.com");
  url.searchParams.set("teamId", teamId);
  url.searchParams.set("authorizationId", authorizationId);
  url.searchParams.set("source", "cli");
  url.searchParams.set("cmd", "authorize");
  output_manager_default.print("Opening the Vercel Dashboard to continue the installation...");
  output_manager_default.debug(`Opening URL: ${url.href}`);
  (0, import_open3.default)(url.href);
}
async function provisionStorageProduct(client, product, installation, name, metadata, billingPlan, authorizationId, contextName, options = {}) {
  output_manager_default.spinner("Provisioning resource...");
  let storeId;
  try {
    const result = await provisionStoreResource(
      client,
      installation.id,
      product.id,
      billingPlan.id,
      name,
      metadata,
      authorizationId
    );
    storeId = result.store.id;
  } catch (error) {
    output_manager_default.error(
      `Failed to provision ${product.name}: ${error.message}`
    );
    return 1;
  } finally {
    output_manager_default.stopSpinner();
  }
  output_manager_default.log(`${product.name} successfully provisioned: ${import_chalk61.default.bold(name)}`);
  return postProvisionSetup(client, name, storeId, contextName, options);
}

// src/util/telemetry/commands/install/index.ts
var InstallTelemetryClient = class extends TelemetryClient {
};

// src/commands/install/index.ts
async function install(client) {
  const { args, flags } = parseArguments(client.argv.slice(2));
  const telemetry2 = new InstallTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  if (flags["--help"]) {
    telemetry2.trackCliFlagHelp("install");
    output_manager_default.print(help(installCommand, { columns: client.stderr.columns }));
    return 0;
  }
  await add5(client, args.slice(1));
}

// src/util/telemetry/commands/integration/index.ts
var IntegrationTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandAdd(actual) {
    this.trackCliSubcommand({
      subcommand: "add",
      value: actual
    });
  }
  trackCliSubcommandList(actual) {
    this.trackCliSubcommand({
      subcommand: "list",
      value: actual
    });
  }
  trackCliSubcommandDiscover(actual) {
    this.trackCliSubcommand({
      subcommand: "discover",
      value: actual
    });
  }
  trackCliSubcommandOpen(actual) {
    this.trackCliSubcommand({
      subcommand: "open",
      value: actual
    });
  }
  trackCliSubcommandBalance(actual) {
    this.trackCliSubcommand({
      subcommand: "balance",
      value: actual
    });
  }
  trackCliSubcommandRemove(actual) {
    this.trackCliSubcommand({
      subcommand: "remove",
      value: actual
    });
  }
};

// src/commands/integration/balance.ts
var import_chalk62 = __toESM(require_source(), 1);

// src/util/integration/fetch-installation-prepayment-info.ts
async function fetchInstallationPrepaymentInfo(client, teamId, installationId) {
  const searchParams = new URLSearchParams();
  searchParams.set("teamId", teamId);
  return await client.fetch(
    `/v1/integrations/installations/${installationId}/billing/balance?${searchParams}`,
    {
      json: true
    }
  );
}
async function getBalanceInformation(client, installationId, team) {
  output_manager_default.spinner("Retrieving balance info\u2026", 500);
  try {
    const prepaymentInfo = await fetchInstallationPrepaymentInfo(
      client,
      team.id,
      installationId
    );
    output_manager_default.stopSpinner();
    if (!prepaymentInfo) {
      output_manager_default.error("No balance information found for this integration");
      return;
    }
    return prepaymentInfo;
  } catch (error) {
    output_manager_default.stopSpinner();
    output_manager_default.error(`Failed to fetch balance info: ${error.message}`);
    return;
  }
}

// src/util/integration/fetch-marketplace-integrations.ts
async function fetchMarketplaceIntegrations(client, slug) {
  const searchParams = new URLSearchParams();
  searchParams.set("view", "account");
  searchParams.set("installationType", "marketplace");
  searchParams.set("integrationIdOrSlug", slug);
  return await client.fetch(
    `/v2/integrations/configurations?${searchParams}`,
    {
      json: true
    }
  );
}
async function getFirstConfiguration(client, integrationSlug) {
  const configurations = await fetchMarketplaceIntegrations(
    client,
    integrationSlug
  );
  return configurations.length > 0 ? configurations[0] : void 0;
}

// src/util/telemetry/commands/integration/balance.ts
var IntegrationBalanceTelemetryClient = class extends TelemetryClient {
  trackCliArgumentIntegration(v, known) {
    if (v) {
      this.trackCliArgument({
        arg: "name",
        value: known ? v : this.redactedValue
      });
    }
  }
};

// src/util/integration-resource/get-resources.ts
async function getResources(client, teamId) {
  const searchParams = new URLSearchParams();
  searchParams.set("teamId", teamId);
  const storesResponse = await client.fetch(
    `/v1/storage/stores?${searchParams}`,
    {
      json: true
    }
  );
  return storesResponse.stores;
}

// src/commands/integration/balance.ts
async function balance(client, args) {
  const telemetry2 = new IntegrationBalanceTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  if (args.length > 1) {
    output_manager_default.error("Cannot specify more than one integration at a time");
    return 1;
  }
  const integrationSlug = args[0];
  if (!integrationSlug) {
    output_manager_default.error("You must pass an integration slug");
    return 1;
  }
  const { team } = await getScope(client);
  if (!team) {
    output_manager_default.error("Team not found.");
    return 1;
  }
  const installation = await getBalanceInstallationId(
    client,
    integrationSlug,
    telemetry2
  );
  if (installation === void 0) {
    return 1;
  }
  const installationId = installation.id;
  const resources = await getResourcesForInstallation(
    client,
    installationId,
    team
  );
  if (resources === void 0) {
    return 1;
  }
  const prepaymentInfo = await getBalanceInformation(
    client,
    installationId,
    team
  );
  if (prepaymentInfo === void 0) {
    return 1;
  }
  outputBalanceInformation(prepaymentInfo, resources, integrationSlug);
  return 0;
}
async function getBalanceInstallationId(client, integrationSlug, telemetry2) {
  let knownIntegrationSlug = false;
  output_manager_default.spinner("Retrieving installation\u2026", 500);
  try {
    const installation = await getFirstConfiguration(client, integrationSlug);
    if (!installation) {
      output_manager_default.stopSpinner();
      output_manager_default.error("No installations found for this integration");
      return;
    }
    knownIntegrationSlug = true;
    return installation;
  } catch (error) {
    output_manager_default.stopSpinner();
    output_manager_default.error(`Failed to fetch installations: ${error.message}`);
    return;
  } finally {
    telemetry2.trackCliArgumentIntegration(
      integrationSlug,
      knownIntegrationSlug
    );
  }
}
async function getResourcesForInstallation(client, installationId, team) {
  output_manager_default.spinner("Retrieving resources\u2026", 500);
  try {
    const resources = (await getResources(client, team.id)).filter(
      (resource) => resource.product?.integrationConfigurationId === installationId
    );
    output_manager_default.stopSpinner();
    return resources;
  } catch (error) {
    output_manager_default.stopSpinner();
    output_manager_default.error(`Failed to fetch resources: ${error.message}`);
    return;
  }
}
function outputBalanceInformation(prepaymentInfo, resources, integrationSlug) {
  const hasBalances = prepaymentInfo.balances.length > 0;
  const hasThresholds = prepaymentInfo.thresholds.length > 0;
  if (!hasBalances) {
    output_manager_default.log("No balances found for this integration");
  }
  if (!hasThresholds) {
    output_manager_default.log("No thresholds found for this integration");
  }
  if (!hasBalances && !hasThresholds) {
    return 0;
  }
  const mappings = {};
  for (const balance2 of prepaymentInfo.balances) {
    const resourceName = balance2.resourceId ? resources.find((r) => r.externalResourceId === balance2.resourceId)?.name ?? balance2.resourceId : "installation";
    mappings[balance2.resourceId ?? "installation"] = { balance: balance2, resourceName };
  }
  for (const threshold of prepaymentInfo.thresholds) {
    const mapping = mappings[threshold.resourceId ?? "installation"];
    if (mapping) {
      mapping.threshold = threshold;
    } else {
      const resourceName = threshold.resourceId ? resources.find((r) => r.externalResourceId === threshold.resourceId)?.name ?? threshold.resourceId : "installation";
      mappings[resourceName] = { threshold, resourceName };
    }
  }
  output_manager_default.log(
    `${import_chalk62.default.bold(`Balances and thresholds for ${integrationSlug}`)}:`
  );
  for (const key in mappings) {
    const mapping = mappings[key];
    const name = mapping.resourceName;
    const balance2 = mapping.balance;
    const threshold = mapping.threshold;
    output_manager_default.log(`\u25CF ${name}`);
    if (balance2) {
      output_manager_default.log(
        `    Balance: ${formattedCurrency(balance2.currencyValueInCents)}`
      );
    }
    if (threshold) {
      output_manager_default.log(
        `    Threshold: Spend ${formattedCurrency(threshold.purchaseAmountInCents)} if balance goes below ${formattedCurrency(threshold.minimumAmountInCents)}`
      );
    }
  }
}
function formattedCurrency(amountInCents) {
  return Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD"
  }).format(amountInCents / 100);
}

// src/commands/integration/list.ts
var import_chalk63 = __toESM(require_source(), 1);
var import_title2 = __toESM(require_lib2(), 1);

// src/util/integration/build-sso-link.ts
function buildSSOLink(team, configurationId) {
  const url = new URL("/api/marketplace/sso", "https://vercel.com");
  url.searchParams.set("teamId", team.id);
  url.searchParams.set("integrationConfigurationId", configurationId);
  return url.href;
}

// src/util/telemetry/commands/integration/list.ts
var IntegrationListTelemetryClient = class extends TelemetryClient {
  trackCliArgumentProject(v) {
    if (v) {
      this.trackCliArgument({
        arg: "project",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionIntegration(v, known) {
    if (v) {
      this.trackCliOption({
        option: "integration",
        value: known ? v : this.redactedValue
      });
    }
  }
  trackCliFlagAll(v) {
    if (v) {
      this.trackCliFlag("all");
    }
  }
};

// src/commands/integration/list.ts
async function list4(client) {
  let parsedArguments = null;
  const flagsSpecification = getFlagsSpecification(listSubcommand7.options);
  try {
    parsedArguments = parseArguments(client.argv.slice(3), flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const telemetry2 = new IntegrationListTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  telemetry2.trackCliArgumentProject(parsedArguments.args[1]);
  telemetry2.trackCliFlagAll(parsedArguments.flags["--all"]);
  const validationResult = validateLsArgs({
    commandName: "integration list [project]",
    args: parsedArguments.args,
    maxArgs: 2,
    exitCode: 1
  });
  if (validationResult !== 0) {
    return validationResult;
  }
  let project;
  if (parsedArguments.args.length === 2) {
    if (parsedArguments.flags["--all"]) {
      output_manager_default.error("Cannot specify a project when using the `--all` flag.");
      return 1;
    }
    project = { name: parsedArguments.args[1] };
  }
  const { contextName, team } = await getScope(client);
  if (!team) {
    output_manager_default.error("Team not found.");
    return 1;
  }
  if (!project && !parsedArguments.flags["--all"]) {
    project = await getLinkedProject(client).then((result) => {
      if (result.status === "linked") {
        return result.project;
      }
      return;
    });
    if (!project) {
      output_manager_default.error(
        "No project linked. Either use `vc link` to link a project, or the `--all` flag to list all resources."
      );
      return 1;
    }
  }
  let resources;
  try {
    output_manager_default.spinner("Retrieving resources\u2026", 500);
    resources = await getResources(client, team.id);
  } catch (error) {
    output_manager_default.error(`Failed to fetch resources: ${error.message}`);
    return 1;
  }
  const filterIntegration = parsedArguments.flags["--integration"]?.toLocaleLowerCase();
  function resourceIsFromMarketplace(resource) {
    return resource.type === "integration";
  }
  let knownIntegration = false;
  function filterOnIntegration(resource) {
    if (!filterIntegration)
      return true;
    const match = filterIntegration === resource.product?.slug;
    if (match)
      knownIntegration = true;
    return match;
  }
  function filterOnProject(resource) {
    return !project || !!resource.projectsMetadata?.find(
      (metadata) => metadata.projectId === project?.id || metadata.name === project?.name
    );
  }
  function filterOnFlags(resource) {
    return filterOnIntegration(resource) && filterOnProject(resource);
  }
  const results = resources.filter(resourceIsFromMarketplace).filter(filterOnFlags).map((resource) => {
    return {
      id: resource.id,
      name: resource.name,
      status: resource.status,
      product: resource.product?.name,
      integration: resource.product?.slug,
      configurationId: resource.product?.integrationConfigurationId,
      projects: resource.projectsMetadata?.map((metadata) => metadata.name).join(", ")
    };
  });
  telemetry2.trackCliOptionIntegration(
    parsedArguments.flags["--integration"],
    knownIntegration
  );
  if (results.length === 0) {
    output_manager_default.log("No resources found.");
    return 0;
  }
  output_manager_default.log(
    `Integrations in ${import_chalk63.default.bold(contextName)}:
${table(
      [
        ["Name", "Status", "Product", "Integration", "Projects"].map(
          (header) => import_chalk63.default.bold(import_chalk63.default.cyan(header))
        ),
        ...results.map((result) => [
          resourceLink(contextName, result) ?? import_chalk63.default.gray("\u2013"),
          resourceStatus(result.status ?? "\u2013"),
          result.product ?? import_chalk63.default.gray("\u2013"),
          integrationLink(result, team) ?? import_chalk63.default.gray("\u2013"),
          import_chalk63.default.grey(result.projects ? result.projects : "\u2013")
        ])
      ],
      { hsep: 8 }
    )}`
  );
  return 0;
}
function resourceStatus(status3) {
  const CIRCLE = "\u25CF ";
  const statusTitleCase = (0, import_title2.default)(status3);
  switch (status3) {
    case "initializing":
      return import_chalk63.default.yellow(CIRCLE) + statusTitleCase;
    case "error":
      return import_chalk63.default.red(CIRCLE) + statusTitleCase;
    case "available":
      return import_chalk63.default.green(CIRCLE) + statusTitleCase;
    case "suspended":
      return import_chalk63.default.white(CIRCLE) + statusTitleCase;
    case "limits-exceeded-suspended":
      return `${import_chalk63.default.white(CIRCLE)}Limits exceeded`;
    default:
      return import_chalk63.default.gray(statusTitleCase);
  }
}
function resourceLink(orgSlug, resource) {
  if (!resource.name) {
    return;
  }
  const projectUrl = `https://vercel.com/${orgSlug}/~`;
  return output_manager_default.link(
    resource.name,
    `${projectUrl}/stores/integration/${resource.id}`,
    { fallback: () => resource.name ?? "\u2013", color: false }
  );
}
function integrationLink(integration, team) {
  if (!integration.integration) {
    return;
  }
  if (!integration.configurationId) {
    return integration.integration;
  }
  const boldName = import_chalk63.default.bold(integration.integration);
  const integrationDeepLink = buildSSOLink(team, integration.configurationId);
  return output_manager_default.link(boldName, integrationDeepLink, {
    fallback: () => boldName,
    color: false
  });
}

// src/commands/integration/open-integration.ts
var import_chalk64 = __toESM(require_source(), 1);
var import_open4 = __toESM(require_open(), 1);

// src/util/telemetry/commands/integration/open.ts
var IntegrationOpenTelemetryClient = class extends TelemetryClient {
  trackCliArgumentName(v, known) {
    this.trackCliArgument({
      arg: "name",
      value: known ? v : this.redactedValue
    });
  }
};

// src/commands/integration/open-integration.ts
async function openIntegration(client, args) {
  const telemetry2 = new IntegrationOpenTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  if (args.length > 1) {
    output_manager_default.error("Cannot open more than one dashboard at a time");
    return 1;
  }
  const integrationSlug = args[0];
  if (!integrationSlug) {
    output_manager_default.error("You must pass an integration slug");
    return 1;
  }
  const { team } = await getScope(client);
  if (!team) {
    output_manager_default.error("Team not found");
    return 1;
  }
  let configuration;
  let knownIntegrationSlug = false;
  try {
    configuration = await getFirstConfiguration(client, integrationSlug);
    knownIntegrationSlug = !!configuration;
  } catch (error) {
    output_manager_default.error(
      `Failed to fetch configuration for ${import_chalk64.default.bold(`"${integrationSlug}"`)}: ${error.message}`
    );
    return 1;
  } finally {
    telemetry2.trackCliArgumentName(integrationSlug, knownIntegrationSlug);
  }
  if (!configuration) {
    output_manager_default.error(
      `No configuration found for ${import_chalk64.default.bold(`"${integrationSlug}"`)}.`
    );
    return 1;
  }
  output_manager_default.print(`Opening the ${import_chalk64.default.bold(integrationSlug)} dashboard...`);
  (0, import_open4.default)(buildSSOLink(team, configuration.id));
  return 0;
}

// src/commands/integration/remove-integration.ts
var import_chalk65 = __toESM(require_source(), 1);

// src/util/integration/remove-integration.ts
async function removeIntegration(client, configuration, team) {
  const params = new URLSearchParams();
  params.set("teamId", team.id);
  return client.fetch(
    `/v2/integrations/installations/${configuration.id}/uninstall?${params}`,
    {
      json: true,
      body: {},
      method: "POST"
    }
  );
}

// src/util/telemetry/commands/integration/remove.ts
var IntegrationRemoveTelemetryClient = class extends TelemetryClient {
  trackCliArgumentIntegration(v, known) {
    if (v) {
      this.trackCliArgument({
        arg: "integration",
        value: known ? v : this.redactedValue
      });
    }
  }
  trackCliFlagYes(v) {
    if (v) {
      this.trackCliFlag("yes");
    }
  }
};

// src/commands/integration/remove-integration.ts
async function remove(client) {
  const telemetry2 = new IntegrationRemoveTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArguments = null;
  const flagsSpecification = getFlagsSpecification(removeSubcommand7.options);
  try {
    parsedArguments = parseArguments(client.argv.slice(3), flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { team } = await getScope(client);
  if (!team) {
    output_manager_default.error("Team not found.");
    return 1;
  }
  const isMissingResourceOrIntegration = parsedArguments.args.length < 2;
  if (isMissingResourceOrIntegration) {
    output_manager_default.error("You must specify an integration. See `--help` for details.");
    return 1;
  }
  const hasTooManyArguments = parsedArguments.args.length > 2;
  if (hasTooManyArguments) {
    output_manager_default.error("Cannot specify more than one integration at a time.");
    return 1;
  }
  const integrationName = parsedArguments.args[1];
  const skipConfirmation = !!parsedArguments.flags["--yes"];
  telemetry2.trackCliFlagYes(skipConfirmation);
  output_manager_default.spinner("Retrieving integration\u2026", 500);
  const integrationConfiguration = await getFirstConfiguration(
    client,
    integrationName
  );
  output_manager_default.stopSpinner();
  if (!integrationConfiguration) {
    output_manager_default.error(`No integration ${import_chalk65.default.bold(integrationName)} found.`);
    telemetry2.trackCliArgumentIntegration(integrationName, false);
    return 0;
  }
  telemetry2.trackCliArgumentIntegration(integrationName, true);
  const userDidNotConfirm = !skipConfirmation && !await confirmIntegrationRemoval(
    client,
    integrationConfiguration.slug,
    team
  );
  if (userDidNotConfirm) {
    output_manager_default.log("Canceled");
    return 0;
  }
  try {
    output_manager_default.spinner("Uninstalling integration\u2026", 1e3);
    await removeIntegration(client, integrationConfiguration, team);
  } catch (error) {
    output_manager_default.error(
      import_chalk65.default.red(
        `Failed to remove ${import_chalk65.default.bold(integrationName)}: ${error.message}`
      )
    );
    return 1;
  }
  output_manager_default.success(`${import_chalk65.default.bold(integrationName)} successfully removed.`);
  return 0;
}
async function confirmIntegrationRemoval(client, integration, team) {
  output_manager_default.log(
    `The ${import_chalk65.default.bold(integration)} integration will be removed permanently from team ${import_chalk65.default.bold(team.name)}.`
  );
  return client.input.confirm(`${import_chalk65.default.red("Are you sure?")}`, false);
}

// src/commands/integration/discover.ts
var import_chalk66 = __toESM(require_source(), 1);

// src/util/telemetry/commands/integration/discover.ts
var IntegrationDiscoverTelemetryClient = class extends TelemetryClient {
  trackCliFlagJson(v) {
    if (v) {
      this.trackCliFlag("json");
    }
  }
};

// src/util/integration/fetch-marketplace-integrations-list.ts
async function fetchMarketplaceIntegrationsList(client) {
  return client.fetch(
    "/v2/integrations/integrations?integrationType=marketplace",
    {
      json: true
    }
  );
}

// src/util/integration/fetch-integration-categories.ts
async function fetchIntegrationCategories(client) {
  return client.fetch("/v2/integrations/categories", {
    json: true
  });
}

// src/commands/integration/discover.ts
var KNOWN_PROTOCOL_TYPES = /* @__PURE__ */ new Set([
  "storage",
  "ai",
  "observability",
  "messaging",
  "compute"
]);
function resolveTags(productTags, integrationTagIds, categoryTitleById) {
  const result = /* @__PURE__ */ new Set();
  const allTags = [...integrationTagIds ?? [], ...productTags ?? []];
  for (const tag of allTags) {
    if (tag.startsWith("tag_")) {
      const title3 = categoryTitleById.get(tag);
      result.add(title3 ?? tag.substring(4));
    } else if (!KNOWN_PROTOCOL_TYPES.has(tag)) {
      result.add(tag.charAt(0).toUpperCase() + tag.slice(1));
    }
  }
  return [...result];
}
async function discover(client, args) {
  let parsedArguments = null;
  const flagsSpecification = getFlagsSpecification(discoverSubcommand.options);
  try {
    parsedArguments = parseArguments(args, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const telemetry2 = new IntegrationDiscoverTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  if (parsedArguments.args.length > 0) {
    output_manager_default.error(
      "Invalid number of arguments. Usage: `vercel integration discover`"
    );
    return 1;
  }
  const formatResult = validateJsonOutput(parsedArguments.flags);
  if (!formatResult.valid) {
    output_manager_default.error(formatResult.error);
    return 1;
  }
  const asJson = formatResult.jsonOutput;
  telemetry2.trackCliFlagJson(parsedArguments.flags["--json"]);
  output_manager_default.spinner("Fetching marketplace integrations...", 500);
  let integrations;
  let categories = [];
  try {
    const [integrationsResult, categoriesResult] = await Promise.allSettled([
      fetchMarketplaceIntegrationsList(client),
      fetchIntegrationCategories(client)
    ]);
    if (integrationsResult.status === "rejected") {
      throw integrationsResult.reason;
    }
    integrations = integrationsResult.value;
    if (categoriesResult.status === "fulfilled") {
      categories = categoriesResult.value;
    } else {
      output_manager_default.warn(
        `Failed to fetch integration categories. Continuing without categories: ${categoriesResult.reason instanceof Error ? categoriesResult.reason.message : String(categoriesResult.reason)}`
      );
    }
  } catch (error) {
    output_manager_default.error(
      `Failed to fetch marketplace integrations: ${error.message}`
    );
    return 1;
  }
  const categoryTitleById = new Map(
    categories.map((category) => [category.id, category.title])
  );
  const results = [];
  for (const integration of integrations) {
    if (!integration.isMarketplace || !integration.canInstall) {
      continue;
    }
    const products = integration.products ?? [];
    if (products.length === 0) {
      results.push({
        name: integration.name,
        slug: integration.slug,
        provider: integration.name,
        description: integration.shortDescription ?? "",
        tags: resolveTags(void 0, integration.tagIds, categoryTitleById)
      });
    } else {
      for (const product of products) {
        const needsCompoundSlug = products.length > 1 || product.slug !== integration.slug;
        results.push({
          name: product.name,
          slug: needsCompoundSlug ? `${integration.slug}/${product.slug}` : integration.slug,
          provider: integration.name,
          description: product.shortDescription ?? integration.shortDescription ?? "",
          tags: resolveTags(
            product.tags,
            integration.tagIds,
            categoryTitleById
          )
        });
      }
    }
  }
  output_manager_default.stopSpinner();
  if (asJson) {
    client.stdout.write(
      `${JSON.stringify(
        {
          products: results
        },
        null,
        2
      )}
`
    );
    return 0;
  }
  if (results.length === 0) {
    output_manager_default.log("No marketplace products found.");
    return 0;
  }
  const useCompactFormat = client.stderr.columns > 0 && client.stderr.columns < 120;
  const formattedOutput = useCompactFormat ? formatCompactList(results) : formatTable2(results);
  output_manager_default.log("Available marketplace products:\n" + formattedOutput);
  return 0;
}
function formatTable2(products) {
  return table(
    [
      ["Product Name", "Slug", "Provider", "Description", "Tags"].map(
        (header) => import_chalk66.default.bold(import_chalk66.default.cyan(header))
      ),
      ...products.map((product) => [
        product.name,
        product.slug,
        product.provider,
        product.description || import_chalk66.default.gray("-"),
        product.tags.length > 0 ? product.tags.join(", ") : import_chalk66.default.gray("-")
      ])
    ],
    { hsep: 4 }
  );
}
function formatCompactList(products) {
  return products.map((product) => {
    return [
      `${import_chalk66.default.bold(product.name)} (${product.slug})`,
      `  Provider: ${product.provider}`,
      `  Description: ${product.description || "-"}`,
      `  Tags: ${product.tags.length > 0 ? product.tags.join(", ") : "-"}`
    ].join("\n");
  }).join("\n\n");
}

// src/util/integration/format-product-help.ts
var import_chalk67 = __toESM(require_source(), 1);
function formatProductHelp(integrationSlug, products) {
  const lines = [];
  lines.push("");
  lines.push(
    `  ${import_chalk67.default.dim("Available products for")} "${import_chalk67.default.bold(integrationSlug)}"${import_chalk67.default.dim(":")}`
  );
  lines.push("");
  const maxSlugLen = Math.max(...products.map((p) => p.slug.length));
  for (const product of products) {
    const paddedSlug = product.slug.padEnd(maxSlugLen);
    lines.push(`    ${import_chalk67.default.cyan(paddedSlug)}  ${product.name}`);
  }
  lines.push("");
  lines.push(`  ${import_chalk67.default.dim("Usage:")}`);
  lines.push("");
  lines.push(
    `    ${import_chalk67.default.cyan(`$ ${packageName} integration add ${integrationSlug}/<product-slug>`)}`
  );
  lines.push("");
  return lines.join("\n");
}

// src/util/integration/format-dynamic-examples.ts
var import_chalk68 = __toESM(require_source(), 1);
function formatDynamicExamples(integrationSlug, products) {
  const lines = [];
  lines.push("");
  lines.push(`  ${import_chalk68.default.dim("Examples:")}`);
  lines.push("");
  lines.push(`  ${import_chalk68.default.dim("-")} Install ${integrationSlug}`);
  lines.push("");
  lines.push(
    `    ${import_chalk68.default.cyan(`$ ${packageName} integration add ${integrationSlug}`)}`
  );
  if (products.length > 1) {
    const firstProduct = products[0];
    lines.push("");
    lines.push(`  ${import_chalk68.default.dim("-")} Install a specific product`);
    lines.push("");
    lines.push(
      `    ${import_chalk68.default.cyan(`$ ${packageName} integration add ${integrationSlug}/${firstProduct.slug}`)}`
    );
  }
  lines.push("");
  lines.push(`  ${import_chalk68.default.dim("-")} Install with a custom resource name`);
  lines.push("");
  lines.push(
    `    ${import_chalk68.default.cyan(`$ ${packageName} integration add ${integrationSlug} --name my-resource`)}`
  );
  const metadataExample = buildMetadataExample(integrationSlug, products);
  if (metadataExample) {
    lines.push("");
    lines.push(`  ${import_chalk68.default.dim("-")} Install with metadata`);
    lines.push("");
    lines.push(`    ${import_chalk68.default.cyan(`$ ${metadataExample}`)}`);
  }
  lines.push("");
  return lines.join("\n");
}
function buildMetadataExample(integrationSlug, products) {
  for (const product of products) {
    const schema = product.metadataSchema;
    if (!schema)
      continue;
    const flags = [];
    for (const [key, prop] of Object.entries(schema.properties)) {
      if (isHiddenOnCreate(prop)) {
        continue;
      }
      if (prop.type === "boolean") {
        flags.push(`-m ${key}=true`);
      } else if (prop.type === "array") {
        const visible = getVisibleOptions(prop);
        if (visible && visible.length > 0) {
          flags.push(`-m "${key}=${visible.slice(0, 2).join(",")}"`);
        }
      } else {
        const visible = getVisibleOptions(prop);
        if (visible && visible.length > 0) {
          flags.push(`-m ${key}=${visible[0]}`);
        }
      }
      if (flags.length >= 2)
        break;
    }
    if (flags.length > 0) {
      const slug = products.length > 1 ? `${integrationSlug}/${product.slug}` : integrationSlug;
      return `${packageName} integration add ${slug} ${flags.join(" ")}`;
    }
  }
  return void 0;
}

// src/commands/integration/index.ts
var COMMAND_CONFIG13 = {
  add: getCommandAliases(addSubcommand5),
  open: getCommandAliases(openSubcommand),
  list: getCommandAliases(listSubcommand7),
  discover: getCommandAliases(discoverSubcommand),
  balance: getCommandAliases(balanceSubcommand),
  remove: getCommandAliases(removeSubcommand7)
};
async function main9(client) {
  const telemetry2 = new IntegrationTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const { args, flags } = parseArguments(
    client.argv.slice(2),
    getFlagsSpecification(integrationCommand.options),
    { permissive: true }
  );
  const {
    subcommand,
    subcommandOriginal,
    args: subArgs
  } = getSubcommand2(args.slice(1), COMMAND_CONFIG13);
  const needHelp = flags["--help"];
  function printHelp(command) {
    output_manager_default.print(
      help(command, {
        columns: client.stderr.columns,
        parent: integrationCommand
      })
    );
  }
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp("integration");
    output_manager_default.print(
      help(integrationCommand, {
        columns: client.stderr.columns
      })
    );
    return 0;
  }
  switch (subcommand) {
    case "add": {
      if (needHelp) {
        telemetry2.trackCliFlagHelp("integration", subcommandOriginal);
        const rawArg = subArgs[0];
        if (rawArg) {
          const integrationSlug = rawArg.split("/")[0];
          try {
            const integration = await fetchIntegration(client, integrationSlug);
            const products = integration.products ?? [];
            printHelp({ ...addSubcommand5, examples: [] });
            output_manager_default.print(formatDynamicExamples(integrationSlug, products));
            if (products.length > 1) {
              output_manager_default.print(formatProductHelp(integrationSlug, products));
            }
            for (const product of products) {
              if (product.metadataSchema) {
                const productSlug = products.length > 1 ? product.slug : void 0;
                output_manager_default.print(
                  formatMetadataSchemaHelp(
                    product.metadataSchema,
                    integrationSlug,
                    productSlug
                  )
                );
              }
            }
            return 0;
          } catch (err) {
            output_manager_default.debug(
              `Failed to fetch integration for dynamic help: ${err}`
            );
          }
        }
        printHelp(addSubcommand5);
        return 0;
      }
      telemetry2.trackCliSubcommandAdd(subcommandOriginal);
      const addFlagsSpec = getFlagsSpecification(addSubcommand5.options);
      let addParsedArgs;
      try {
        addParsedArgs = parseArguments(subArgs, addFlagsSpec);
      } catch (error) {
        printError(error);
        return 1;
      }
      const resourceName = addParsedArgs.flags["--name"];
      const metadataFlags = addParsedArgs.flags["--metadata"];
      const noConnect = addParsedArgs.flags["--no-connect"];
      const noEnvPull = addParsedArgs.flags["--no-env-pull"];
      return add5(client, addParsedArgs.args, resourceName, metadataFlags, {
        noConnect,
        noEnvPull
      });
    }
    case "list": {
      if (needHelp) {
        telemetry2.trackCliFlagHelp("integration", subcommandOriginal);
        printHelp(listSubcommand7);
        return 0;
      }
      telemetry2.trackCliSubcommandList(subcommandOriginal);
      return list4(client);
    }
    case "discover": {
      if (needHelp) {
        telemetry2.trackCliFlagHelp("integration", subcommandOriginal);
        printHelp(discoverSubcommand);
        return 0;
      }
      telemetry2.trackCliSubcommandDiscover(subcommandOriginal);
      return discover(client, subArgs);
    }
    case "balance": {
      if (needHelp) {
        telemetry2.trackCliFlagHelp("integration", subcommandOriginal);
        printHelp(balanceSubcommand);
        return 0;
      }
      telemetry2.trackCliSubcommandBalance(subcommandOriginal);
      return balance(client, subArgs);
    }
    case "open": {
      if (needHelp) {
        telemetry2.trackCliFlagHelp("integration", subcommandOriginal);
        printHelp(openSubcommand);
        return 0;
      }
      telemetry2.trackCliSubcommandOpen(subcommandOriginal);
      return openIntegration(client, subArgs);
    }
    case "remove": {
      if (needHelp) {
        telemetry2.trackCliFlagHelp("integration", subcommandOriginal);
        printHelp(removeSubcommand7);
        return 0;
      }
      telemetry2.trackCliSubcommandRemove(subcommandOriginal);
      return remove(client);
    }
    default: {
      output_manager_default.error(getInvalidSubcommand(COMMAND_CONFIG13));
      return 2;
    }
  }
}

// src/util/telemetry/commands/integration-resource/index.ts
var IntegrationResourceTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandCreateThreshold(actual) {
    this.trackCliSubcommand({
      subcommand: "create-threshold",
      value: actual
    });
  }
  trackCliSubcommandRemove(actual) {
    this.trackCliSubcommand({
      subcommand: "remove",
      value: actual
    });
  }
  trackCliSubcommandDisconnect(actual) {
    this.trackCliSubcommand({
      subcommand: "disconnect",
      value: actual
    });
  }
};

// src/commands/integration-resource/create-threshold.ts
var import_chalk69 = __toESM(require_source(), 1);

// src/util/telemetry/commands/integration-resource/create-threshold.ts
var IntegrationResourceCreateThresholdTelemetryClient = class extends TelemetryClient {
  trackCliArgumentResource(v) {
    if (v) {
      this.trackCliArgument({
        arg: "resource",
        value: this.redactedValue
      });
    }
  }
  trackCliArgumentMinimum(v) {
    if (v) {
      this.trackCliArgument({
        arg: "minimum",
        value: this.redactedValue
      });
    }
  }
  trackCliArgumentSpend(v) {
    if (v) {
      this.trackCliArgument({
        arg: "spend",
        value: this.redactedValue
      });
    }
  }
  trackCliArgumentLimit(v) {
    if (v) {
      this.trackCliArgument({
        arg: "limit",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagYes(v) {
    if (v) {
      this.trackCliFlag("yes");
    }
  }
};

// src/util/integration-resource/update-threshold.ts
async function updateThreshold(client, installationId, resourceId, billingPlanId, minimumAmountInCents, purchaseAmountInCents, maximumAmountPerPeriodInCents, metadata) {
  return await client.fetch(
    `/v1/integrations/installations/${installationId}/resources/${resourceId}/billing/threshold`,
    {
      method: "POST",
      json: true,
      body: {
        billingPlanId,
        minimumAmountInCents,
        purchaseAmountInCents,
        maximumAmountPerPeriodInCents,
        metadata: JSON.stringify(metadata)
      }
    }
  );
}

// src/util/integration/update-installation-threshold.ts
async function updateInstallationThreshold(client, installationId, billingPlanId, minimumAmountInCents, purchaseAmountInCents, maximumAmountPerPeriodInCents, metadata) {
  return await client.fetch(
    `/v1/integrations/installations/${installationId}/billing/threshold/batch`,
    {
      method: "POST",
      json: true,
      body: {
        items: [
          {
            billingPlanId,
            minimumAmountInCents,
            purchaseAmountInCents,
            maximumAmountPerPeriodInCents,
            metadata: JSON.stringify(metadata)
          }
        ]
      }
    }
  );
}

// src/commands/integration-resource/create-threshold.ts
async function createThreshold(client) {
  const telemetry2 = new IntegrationResourceCreateThresholdTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArguments = null;
  const flagsSpecification = getFlagsSpecification(
    createThresholdSubcommand.options
  );
  try {
    parsedArguments = parseArguments(client.argv.slice(3), flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  let args;
  try {
    args = parseCreateThresholdArguments(parsedArguments.args, telemetry2);
  } catch (error) {
    output_manager_default.error(error.message);
    return 1;
  }
  const skipConfirmWithYes = parsedArguments.flags["--yes"];
  telemetry2.trackCliFlagYes(skipConfirmWithYes);
  const { resourceName, minimum, spend, limit } = args;
  const { team } = await getScope(client);
  if (!team) {
    output_manager_default.error("Team not found.");
    return 1;
  }
  output_manager_default.spinner("Retrieving resource\u2026", 500);
  const resources = await getResources(client, team.id);
  const targetedResource = resources.find(
    (resource) => resource.name === resourceName
  );
  output_manager_default.stopSpinner();
  if (!targetedResource) {
    output_manager_default.log(`The resource ${import_chalk69.default.bold(resourceName)} was not found.`);
    return 0;
  }
  if (!targetedResource.product?.integrationConfigurationId) {
    output_manager_default.error(
      `The resource ${import_chalk69.default.bold(resourceName)} does not have an integration configuration.`
    );
    return 1;
  }
  if (targetedResource.billingPlan?.type !== "prepayment") {
    output_manager_default.error(
      `The resource ${import_chalk69.default.bold(resourceName)} is not a prepayment-based resource.`
    );
    return 1;
  }
  const minimumSpend = parseFloat(targetedResource.billingPlan.minimumAmount ?? "0.50") * 100;
  if (minimumSpend > spend) {
    output_manager_default.error(
      `The spend amount $${spend / 100} is below your billing plan's minimum amount of $${minimumSpend / 100}.`
    );
    return 1;
  }
  const maximumSpend = parseFloat(targetedResource.billingPlan.maximumAmount ?? "1000000") * 100;
  if (targetedResource.billingPlan.maximumAmount !== void 0 && maximumSpend < spend) {
    output_manager_default.error(
      `The spend amount $${spend / 100} is above your billing plan's maximum amount of $${maximumSpend / 100}.`
    );
    return 1;
  }
  const prepaymentInfo = await getBalanceInformation(
    client,
    targetedResource.product.integrationConfigurationId,
    team
  );
  if (prepaymentInfo === void 0) {
    return 1;
  }
  if (targetedResource.billingPlan.scope !== "resource") {
    output_manager_default.log(
      `The resource ${import_chalk69.default.bold(resourceName)} uses an installation-level balance.`
    );
    return await updateThresholdForInstallation({
      client,
      resource: targetedResource,
      prepaymentInfo,
      minimum,
      spend,
      limit,
      skipConfirmWithYes: Boolean(skipConfirmWithYes)
    });
  }
  return await updateThresholdForResource({
    client,
    resource: targetedResource,
    prepaymentInfo,
    minimum,
    spend,
    limit,
    skipConfirmWithYes: Boolean(skipConfirmWithYes)
  });
}
function parseCreateThresholdArguments(passedArgs, telemetry2) {
  if (passedArgs.length < 5) {
    throw new Error("Missing arguments. See `--help` for details.");
  }
  if (passedArgs.length > 5) {
    throw new Error("Too many arguments. See `--help` for details.");
  }
  const args = passedArgs.slice(1, 5);
  telemetry2.trackCliArgumentResource(args[0]);
  telemetry2.trackCliArgumentMinimum(args[1]);
  telemetry2.trackCliArgumentSpend(args[2]);
  telemetry2.trackCliArgumentLimit(args[3]);
  const resourceName = args[0];
  const minimum = Number.parseFloat(args[1]) * 100;
  const spend = Number.parseInt(args[2]) * 100;
  const limit = Number.parseInt(args[3]) * 100;
  if (isNaN(minimum)) {
    throw new Error(
      'Minimum is an invalid number format. Spend must be a positive number (ex. "5.75")'
    );
  }
  if (isNaN(spend)) {
    throw new Error(
      'Spend is an invalid number format. Spend must be a positive number (ex. "10.99").'
    );
  }
  if (isNaN(limit)) {
    throw new Error(
      'Limit is an invalid number format. Limit must be a positive number (ex. "1000").'
    );
  }
  if (minimum < 0) {
    throw new Error("Minimum cannot be negative.");
  }
  if (spend < 0) {
    throw new Error("Spend cannot be negative.");
  }
  if (limit < 0) {
    throw new Error("Limit cannot be negative.");
  }
  if (minimum > spend) {
    throw new Error("Minimum cannot be greater than spend.");
  }
  if (minimum > limit) {
    throw new Error("Minimum cannot be greater than limit.");
  }
  if (limit < spend) {
    throw new Error("Limit cannot be less than spend.");
  }
  return { resourceName, minimum, spend, limit };
}
async function updateThresholdForResource(props) {
  const existingThreshold = props.prepaymentInfo.thresholds.find(
    (threshold) => threshold.resourceId === props.resource.externalResourceId
  );
  const existingBalance = props.prepaymentInfo.balances.find(
    (balance2) => balance2.resourceId === props.resource.externalResourceId
  );
  return handleUpdateThreshold({
    client: props.client,
    resource: props.resource,
    minimum: props.minimum,
    spend: props.spend,
    limit: props.limit,
    existingThreshold,
    existingBalance,
    skipConfirmWithYes: props.skipConfirmWithYes,
    isInstallationLevel: false
  });
}
async function updateThresholdForInstallation(props) {
  const existingThreshold = props.prepaymentInfo.thresholds.find(
    (threshold) => threshold.resourceId === void 0
  );
  const existingBalance = props.prepaymentInfo.balances.find(
    (balance2) => balance2.resourceId === void 0
  );
  return handleUpdateThreshold({
    client: props.client,
    resource: props.resource,
    minimum: props.minimum,
    spend: props.spend,
    limit: props.limit,
    existingThreshold,
    existingBalance,
    skipConfirmWithYes: props.skipConfirmWithYes,
    isInstallationLevel: true
  });
}
async function handleUpdateThreshold(props) {
  if (props.resource.billingPlan?.type !== "prepayment") {
    output_manager_default.log(
      `The resource ${import_chalk69.default.bold(props.resource.name)} is not a prepayment-based resource.`
    );
    return 0;
  }
  if (!props.resource.product?.integrationConfigurationId) {
    output_manager_default.log(
      `The resource ${import_chalk69.default.bold(props.resource.name)} does not have an integration configuration.`
    );
    return 0;
  }
  const entityTextReference = props.isInstallationLevel ? `installation ${import_chalk69.default.bold(props.resource.product?.name)}` : `resource ${import_chalk69.default.bold(props.resource.name)}`;
  if (props.existingThreshold) {
    const shouldOverwriteThreshold = props.skipConfirmWithYes || await props.client.input.confirm(
      `The ${entityTextReference} already has a threshold. (minimum: $${props.existingThreshold.minimumAmountInCents / 100}, spend: $${props.existingThreshold.purchaseAmountInCents / 100}, limit: ${props.existingThreshold.maximumAmountPerPeriodInCents ? `$${props.existingThreshold.maximumAmountPerPeriodInCents / 100}` : "none set"}). Do you want to overwrite it?`,
      true
    );
    if (!shouldOverwriteThreshold) {
      output_manager_default.log("Aborting\u2026");
      return 0;
    }
  }
  if (props.existingBalance && props.existingBalance.currencyValueInCents < props.minimum) {
    const shouldOverwriteBalance = props.skipConfirmWithYes || await props.client.input.confirm(
      `The minimum threshold is higher than the current balance of $${props.existingBalance.currencyValueInCents / 100}. Are you sure?`,
      true
    );
    if (!shouldOverwriteBalance) {
      output_manager_default.log("Aborting\u2026");
      return 0;
    }
  }
  const thresholdCreationConfirmed = props.skipConfirmWithYes || await props.client.input.confirm(
    `Are you sure you want to create a threshold for the ${entityTextReference} with minimum $${props.minimum / 100}, spend $${props.spend / 100}, and limit $${props.limit / 100}?`,
    true
  );
  if (!thresholdCreationConfirmed) {
    output_manager_default.log("Aborting\u2026");
    return 0;
  }
  const metadata = JSON.parse(props.existingThreshold?.metadata ?? "{}");
  output_manager_default.spinner("Creating threshold\u2026", 500);
  if (props.isInstallationLevel) {
    await updateInstallationThreshold(
      props.client,
      props.resource.product.integrationConfigurationId,
      props.resource.billingPlan.id,
      props.minimum,
      props.spend,
      props.limit,
      metadata
    );
  } else {
    await updateThreshold(
      props.client,
      props.resource.product.integrationConfigurationId,
      props.resource.id,
      props.resource.billingPlan.id,
      props.minimum,
      props.spend,
      props.limit,
      metadata
    );
  }
  output_manager_default.stopSpinner();
  output_manager_default.success(`Threshold for ${entityTextReference} created successfully.`);
  return 0;
}

// src/commands/integration-resource/disconnect.ts
var import_chalk70 = __toESM(require_source(), 1);

// src/util/integration-resource/disconnect-resource-from-project.ts
async function disconnectResourceFromProject(client, resource, connection) {
  return client.fetch(
    `/v1/storage/stores/${resource.id}/connections/${connection.id}`,
    {
      json: true,
      method: "DELETE"
    }
  );
}
async function disconnectResourceFromAllProjects(client, resource) {
  return client.fetch(`/v1/storage/stores/${resource.id}/connections`, {
    json: true,
    method: "DELETE"
  });
}

// src/util/telemetry/commands/integration-resource/disconnect.ts
var IntegrationResourceDisconnectTelemetryClient = class extends TelemetryClient {
  trackCliArgumentResource(v) {
    if (v) {
      this.trackCliArgument({
        arg: "resource",
        value: this.redactedValue
      });
    }
  }
  trackCliArgumentProject(v) {
    if (v) {
      this.trackCliArgument({
        arg: "project",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagAll(v) {
    if (v) {
      this.trackCliFlag("all");
    }
  }
  trackCliFlagYes(v) {
    if (v) {
      this.trackCliFlag("yes");
    }
  }
};

// src/util/integration-resource/types.ts
var CancelledError = class extends Error {
};
var FailedError = class extends Error {
};

// src/commands/integration-resource/disconnect.ts
async function disconnect2(client) {
  const telemetry2 = new IntegrationResourceDisconnectTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArguments = null;
  const flagsSpecification = getFlagsSpecification(
    disconnectSubcommand2.options
  );
  try {
    parsedArguments = parseArguments(client.argv.slice(3), flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { team } = await getScope(client);
  if (!team) {
    output_manager_default.error("Team not found.");
    return 1;
  }
  const isMissingResourceOrIntegration = parsedArguments.args.length < 2;
  if (isMissingResourceOrIntegration) {
    output_manager_default.error("You must specify a resource. See `--help` for details.");
    return 1;
  }
  const hasTooManyArguments = parsedArguments.args.length > 3;
  if (hasTooManyArguments) {
    output_manager_default.error(
      "Cannot specify more than one project at a time. Use `--all` to disconnect the specified resource from all projects."
    );
    return 1;
  }
  const skipConfirmation = !!parsedArguments.flags["--yes"];
  const shouldDisconnectAll = parsedArguments.flags["--all"];
  const isProjectSpecified = parsedArguments.args.length === 3;
  if (isProjectSpecified && shouldDisconnectAll) {
    output_manager_default.error("Cannot specify a project while using the `--all` flag.");
    return 1;
  }
  const resourceName = parsedArguments.args[1];
  let specifiedProject;
  if (isProjectSpecified) {
    specifiedProject = parsedArguments.args[2];
  }
  telemetry2.trackCliArgumentResource(resourceName);
  telemetry2.trackCliArgumentProject(specifiedProject);
  telemetry2.trackCliFlagYes(skipConfirmation);
  telemetry2.trackCliFlagAll(shouldDisconnectAll);
  output_manager_default.spinner("Retrieving resource\u2026", 500);
  const resources = await getResources(client, team.id);
  const targetedResource = resources.find(
    (resource) => resource.name === resourceName
  );
  output_manager_default.stopSpinner();
  if (!targetedResource) {
    output_manager_default.error(`No resource ${import_chalk70.default.bold(resourceName)} found.`);
    return 0;
  }
  if (parsedArguments.flags["--all"]) {
    try {
      await handleDisconnectAllProjects(
        client,
        targetedResource,
        !!parsedArguments.flags["--yes"]
      );
      return 0;
    } catch (error) {
      if (error instanceof CancelledError) {
        output_manager_default.log(error.message);
        return 0;
      }
      if (error instanceof FailedError) {
        output_manager_default.error(error.message);
        return 1;
      }
      throw error;
    }
  }
  if (!specifiedProject) {
    specifiedProject = await getLinkedProject(client).then((result) => {
      if (result.status === "linked") {
        return result.project.name;
      }
      return;
    });
    if (!specifiedProject) {
      output_manager_default.error(
        "No project linked. Either use `vc link` to link a project, or specify the project name."
      );
      return 1;
    }
  }
  return await handleDisconnectProject(
    client,
    targetedResource,
    specifiedProject,
    skipConfirmation
  );
}
async function handleDisconnectProject(client, resource, projectName, skipConfirmation) {
  const project = resource.projectsMetadata?.find(
    (project2) => projectName === project2.name
  );
  if (!project) {
    output_manager_default.log(
      `Could not find project ${import_chalk70.default.bold(projectName)} connected to resource ${import_chalk70.default.bold(resource.name)}.`
    );
    return 0;
  }
  if (!skipConfirmation && !await confirmDisconnectProject(client, resource, project)) {
    output_manager_default.log("Canceled");
    return 0;
  }
  try {
    output_manager_default.spinner("Disconnecting resource\u2026", 500);
    await disconnectResourceFromProject(client, resource, project);
    output_manager_default.success(
      `Disconnected ${import_chalk70.default.bold(project.name)} from ${import_chalk70.default.bold(resource.name)}`
    );
  } catch (error) {
    output_manager_default.error(
      `A problem occurred while disconnecting: ${error.message}`
    );
    return 1;
  }
  return 0;
}
async function handleDisconnectAllProjects(client, resource, skipConfirmation) {
  if (resource.projectsMetadata?.length === 0) {
    output_manager_default.log(`${import_chalk70.default.bold(resource.name)} has no projects to disconnect.`);
    return;
  }
  if (!skipConfirmation && !await confirmDisconnectAllProjects(client, resource)) {
    throw new CancelledError("Canceled");
  }
  try {
    output_manager_default.spinner("Disconnecting projects from resource\u2026", 500);
    await disconnectResourceFromAllProjects(client, resource);
    output_manager_default.success(
      `Disconnected all projects from ${import_chalk70.default.bold(resource.name)}`
    );
  } catch (error) {
    throw new FailedError(
      `A problem occurred while disconnecting all projects: ${error.message}`
    );
  }
  return;
}
async function confirmDisconnectProject(client, resource, project) {
  output_manager_default.log(
    `The resource ${import_chalk70.default.bold(resource.name)} will be disconnected from project ${import_chalk70.default.bold(project.name)}.`
  );
  return client.input.confirm(`${import_chalk70.default.red("Are you sure?")}`, false);
}
async function confirmDisconnectAllProjects(client, resource) {
  output_manager_default.log("The following projects will be disconnected:");
  if (!resource.projectsMetadata) {
    return false;
  }
  for (const project of resource.projectsMetadata) {
    output_manager_default.print(`  ${project.name}
`);
  }
  return client.input.confirm(import_chalk70.default.red("Are you sure?"), false);
}

// src/commands/integration-resource/remove-resource.ts
var import_chalk71 = __toESM(require_source(), 1);

// src/util/integration-resource/delete-resource.ts
async function deleteResource(client, resource, team) {
  const params = new URLSearchParams();
  params.set("teamId", team.id);
  return client.fetch(
    `/v1/storage/stores/integration/${resource.id}?${params}`,
    {
      json: true,
      method: "DELETE"
    }
  );
}

// src/util/telemetry/commands/integration-resource/remove.ts
var IntegrationResourceRemoveTelemetryClient = class extends TelemetryClient {
  trackCliArgumentResource(v) {
    if (v) {
      this.trackCliArgument({
        arg: "resource",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagDisconnectAll(v) {
    if (v) {
      this.trackCliFlag("disconnect-all");
    }
  }
  trackCliFlagYes(v) {
    if (v) {
      this.trackCliFlag("yes");
    }
  }
};

// src/commands/integration-resource/remove-resource.ts
async function remove2(client) {
  const telemetry2 = new IntegrationResourceRemoveTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArguments = null;
  const flagsSpecification = getFlagsSpecification(removeSubcommand6.options);
  try {
    parsedArguments = parseArguments(client.argv.slice(3), flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { team } = await getScope(client);
  if (!team) {
    output_manager_default.error("Team not found.");
    return 1;
  }
  const isMissingResourceOrIntegration = parsedArguments.args.length < 2;
  if (isMissingResourceOrIntegration) {
    output_manager_default.error("You must specify a resource. See `--help` for details.");
    return 1;
  }
  const hasTooManyArguments = parsedArguments.args.length > 2;
  if (hasTooManyArguments) {
    output_manager_default.error("Cannot specify more than one resource at a time.");
    return 1;
  }
  const skipConfirmation = !!parsedArguments.flags["--yes"];
  const disconnectAll = !!parsedArguments.flags["--disconnect-all"];
  const resourceName = parsedArguments.args[1];
  telemetry2.trackCliArgumentResource(resourceName);
  telemetry2.trackCliFlagDisconnectAll(disconnectAll);
  telemetry2.trackCliFlagYes(skipConfirmation);
  output_manager_default.spinner("Retrieving resource\u2026", 500);
  const resources = await getResources(client, team.id);
  const targetedResource = resources.find(
    (resource) => resource.name === resourceName
  );
  output_manager_default.stopSpinner();
  if (!targetedResource) {
    output_manager_default.error(`No resource ${import_chalk71.default.bold(resourceName)} found.`);
    return 0;
  }
  if (disconnectAll) {
    try {
      await handleDisconnectAllProjects(
        client,
        targetedResource,
        skipConfirmation
      );
    } catch (error) {
      if (error instanceof CancelledError) {
        output_manager_default.log(error.message);
        return 0;
      }
      if (error instanceof FailedError) {
        output_manager_default.error(error.message);
        return 1;
      }
      throw error;
    }
  }
  return await handleDeleteResource(client, team, targetedResource, {
    skipConfirmation,
    skipProjectCheck: disconnectAll
  });
}
async function handleDeleteResource(client, team, resource, options) {
  const hasProjects = resource.projectsMetadata && resource.projectsMetadata?.length > 0;
  if (!options?.skipProjectCheck && hasProjects) {
    output_manager_default.error(
      `Cannot delete resource ${import_chalk71.default.bold(resource.name)} while it has connected projects. Please disconnect any projects using this resource first or use the \`--disconnect-all\` flag.`
    );
    return 1;
  }
  if (!options?.skipConfirmation && !await confirmDeleteResource(client, resource)) {
    output_manager_default.log("Canceled");
    return 0;
  }
  try {
    output_manager_default.spinner("Deleting resource\u2026", 500);
    await deleteResource(client, resource, team);
    output_manager_default.success(`${import_chalk71.default.bold(resource.name)} successfully deleted.`);
  } catch (error) {
    output_manager_default.error(
      `A problem occurred when attempting to delete ${import_chalk71.default.bold(resource.name)}: ${error.message}`
    );
    return 1;
  }
  return 0;
}
async function confirmDeleteResource(client, resource) {
  output_manager_default.log(`${import_chalk71.default.bold(resource.name)} will be deleted permanently.`);
  return client.input.confirm(`${import_chalk71.default.red("Are you sure?")}`, false);
}

// src/commands/integration-resource/index.ts
var COMMAND_CONFIG14 = {
  remove: getCommandAliases(removeSubcommand6),
  disconnect: getCommandAliases(disconnectSubcommand2),
  "create-threshold": getCommandAliases(createThresholdSubcommand)
};
async function main10(client) {
  const telemetry2 = new IntegrationResourceTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const { args, flags } = parseArguments(
    client.argv.slice(2),
    getFlagsSpecification(integrationResourceCommand.options),
    { permissive: true }
  );
  const { subcommand, subcommandOriginal } = getSubcommand2(
    args.slice(1),
    COMMAND_CONFIG14
  );
  const needHelp = flags["--help"];
  if (!subcommand && needHelp) {
    output_manager_default.print(
      help(integrationResourceCommand, { columns: client.stderr.columns })
    );
    return 0;
  }
  function printHelp(command) {
    output_manager_default.print(
      help(command, {
        columns: client.stderr.columns,
        parent: integrationResourceCommand
      })
    );
  }
  switch (subcommand) {
    case "create-threshold": {
      if (needHelp) {
        telemetry2.trackCliFlagHelp("integration-resource", subcommandOriginal);
        printHelp(createThresholdSubcommand);
        return 0;
      }
      telemetry2.trackCliSubcommandCreateThreshold(subcommandOriginal);
      return createThreshold(client);
    }
    case "remove": {
      if (needHelp) {
        telemetry2.trackCliFlagHelp("integration-resource", subcommandOriginal);
        printHelp(removeSubcommand6);
        return 0;
      }
      telemetry2.trackCliSubcommandRemove(subcommandOriginal);
      return remove2(client);
    }
    case "disconnect": {
      if (needHelp) {
        telemetry2.trackCliFlagHelp("integration-resource", subcommandOriginal);
        printHelp(disconnectSubcommand2);
        return 0;
      }
      telemetry2.trackCliSubcommandDisconnect(subcommandOriginal);
      return disconnect2(client);
    }
    default: {
      output_manager_default.error(getInvalidSubcommand(COMMAND_CONFIG14));
      return 2;
    }
  }
}

// src/commands/logout/index.ts
var import_error_utils8 = __toESM(require_dist(), 1);

// src/util/telemetry/commands/logout/index.ts
var LogoutTelemetryClient = class extends TelemetryClient {
};

// src/commands/logout/future.ts
var import_error_utils7 = __toESM(require_dist(), 1);
async function logout(client) {
  const { authConfig } = client;
  if (!authConfig.token) {
    output_manager_default.note(
      `Not currently logged in, so ${getCommandName("logout")} did nothing`
    );
    return 0;
  }
  output_manager_default.spinner("Logging out\u2026", 200);
  const revocationResponse = await revocationRequest({
    token: authConfig.token
  });
  output_manager_default.debug(`'Revocation response:', ${await revocationResponse.clone().text()}`);
  const [revocationError] = await processRevocationResponse(revocationResponse);
  let logoutError = false;
  if (revocationError) {
    output_manager_default.error(revocationError.message);
    output_manager_default.debug(revocationError.cause);
    output_manager_default.error("Failed during logout");
    logoutError = true;
  }
  try {
    client.updateConfig({ currentTeam: void 0 });
    client.writeToConfigFile();
    client.emptyAuthConfig();
    client.writeToAuthConfigFile();
    output_manager_default.debug("Configuration has been deleted");
    if (!logoutError) {
      output_manager_default.success("Logged out!");
      return 0;
    }
  } catch (err) {
    output_manager_default.debug((0, import_error_utils7.errorToString)(err));
    output_manager_default.error("Failed during logout");
  }
  return 1;
}

// src/commands/logout/index.ts
async function logout2(client) {
  const { authConfig, config } = client;
  let parsedArgs = null;
  const flagsSpecification = getFlagsSpecification(logoutCommand.options);
  const telemetry2 = new LogoutTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  if (parsedArgs.flags["--help"]) {
    telemetry2.trackCliFlagHelp("logout");
    output_manager_default.print(help(logoutCommand, { columns: client.stderr.columns }));
    return 0;
  }
  if ("refreshToken" in authConfig) {
    return await logout(client);
  }
  output_manager_default.debug("Falling back to legacy logout");
  if (!authConfig.token) {
    output_manager_default.note(
      `Not currently logged in, so ${getCommandName("logout")} did nothing`
    );
    return 0;
  }
  output_manager_default.spinner("Logging out\u2026", 200);
  let exitCode2 = 0;
  try {
    await client.fetch("/v3/user/tokens/current", {
      method: "DELETE",
      useCurrentTeam: false
    });
  } catch (err) {
    if (isAPIError(err)) {
      if (err.status === 403) {
        output_manager_default.debug("Token is invalid so it cannot be revoked");
      } else if (err.status !== 200) {
        output_manager_default.debug(err?.message ?? "");
        exitCode2 = 1;
      }
    }
  }
  delete config.currentTeam;
  delete authConfig.token;
  try {
    writeToConfigFile(config);
    writeToAuthConfigFile(authConfig);
    output_manager_default.debug("Configuration has been deleted");
  } catch (err) {
    output_manager_default.debug((0, import_error_utils8.errorToString)(err));
    exitCode2 = 1;
  }
  if (exitCode2 === 0) {
    output_manager_default.log("Logged out!");
  } else {
    output_manager_default.error("Failed during logout");
  }
  return exitCode2;
}

// src/commands/logs/index.ts
var import_error_utils9 = __toESM(require_dist(), 1);
var import_chalk72 = __toESM(require_source(), 1);
var import_date_fns2 = __toESM(require_date_fns(), 1);

// src/util/logs-v2.ts
var import_ms14 = __toESM(require_ms(), 1);
function parseRelativeTime(input) {
  const now = Date.now();
  const msValue = (0, import_ms14.default)(input);
  if (typeof msValue === "number") {
    return now - msValue;
  }
  const date = new Date(input);
  if (!isNaN(date.getTime())) {
    return date.getTime();
  }
  throw new Error(`Invalid time format: ${input}`);
}
async function fetchRequestLogs(client, options) {
  const {
    projectId,
    ownerId,
    deploymentId,
    environment,
    level,
    statusCode,
    source,
    since,
    until,
    search,
    requestId,
    branch,
    page = 0
  } = options;
  const now = Date.now();
  const defaultStartDate = now - 24 * 60 * 60 * 1e3;
  const query = new URLSearchParams();
  query.set("projectId", projectId);
  query.set("ownerId", ownerId);
  query.set("page", String(page));
  query.set(
    "startDate",
    String(since ? parseRelativeTime(since) : defaultStartDate)
  );
  query.set("endDate", String(until ? parseRelativeTime(until) : now));
  if (deploymentId) {
    query.set("deploymentId", deploymentId);
  }
  if (environment) {
    query.set("environment", environment);
  }
  if (level && level.length > 0) {
    query.set("level", level.join(","));
  }
  if (statusCode) {
    query.set("statusCode", statusCode);
  }
  if (source && source.length > 0) {
    query.set("source", source.join(","));
  }
  if (search) {
    query.set("search", search);
  }
  if (requestId) {
    query.set("requestId", requestId);
  }
  if (branch) {
    query.set("branch", branch);
  }
  const baseUrl = client.apiUrl === "https://api.vercel.com" ? "https://vercel.com" : client.apiUrl;
  const url = `${baseUrl}/api/logs/request-logs?${query.toString()}`;
  const data = await client.fetch(url);
  const logs2 = (data.rows || []).map((row) => {
    const firstLog = row.logs?.[0];
    const firstEvent = row.events?.[0];
    return {
      id: row.requestId || "",
      timestamp: row.timestamp ? new Date(row.timestamp).getTime() : Date.now(),
      deploymentId: row.deploymentId || "",
      projectId: options.projectId,
      level: firstLog?.level || "info",
      message: firstLog?.message || "",
      messageTruncated: firstLog?.messageTruncated,
      source: firstEvent?.source || "static",
      domain: row.domain || "",
      requestMethod: row.requestMethod || "",
      requestPath: row.requestPath || "",
      responseStatusCode: row.statusCode || 0,
      environment: row.environment || "production",
      branch: row.branch,
      cache: row.cache,
      traceId: row.traceId
    };
  });
  return {
    logs: logs2,
    pagination: {
      hasMore: data.hasMoreRows ?? false
    }
  };
}
async function* fetchAllRequestLogs(client, options) {
  let page = 0;
  let remaining = options.limit ?? 100;
  let hasMore = true;
  while (hasMore && remaining > 0) {
    const response = await fetchRequestLogs(client, {
      ...options,
      page
    });
    if (!response.logs || response.logs.length === 0) {
      break;
    }
    for (const log of response.logs) {
      yield log;
      remaining--;
      if (remaining <= 0) {
        return;
      }
    }
    hasMore = response.pagination?.hasMore ?? false;
    page++;
  }
}

// src/util/telemetry/commands/logs/index.ts
var LogsTelemetryClient = class extends TelemetryClient {
  trackCliArgumentUrlOrDeploymentId(v) {
    if (v) {
      this.trackCliArgument({
        arg: "urlOrDeploymentId",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionProject(v) {
    if (v) {
      this.trackCliOption({
        option: "project",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionDeployment(v) {
    if (v) {
      this.trackCliOption({
        option: "deployment",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionEnvironment(v) {
    if (v) {
      const allowed = ["production", "preview"].includes(v) ? v : this.redactedValue;
      this.trackCliOption({
        option: "environment",
        value: allowed
      });
    }
  }
  trackCliOptionLevel(v) {
    if (v && v.length > 0) {
      const allowedLevels = ["error", "warning", "info", "fatal"];
      const sanitized = v.every((l) => allowedLevels.includes(l)) ? v.join(",") : this.redactedValue;
      this.trackCliOption({
        option: "level",
        value: sanitized
      });
    }
  }
  trackCliOptionStatusCode(v) {
    if (v) {
      this.trackCliOption({
        option: "status-code",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionSource(v) {
    if (v && v.length > 0) {
      const allowedSources = [
        "serverless",
        "edge-function",
        "edge-middleware",
        "static"
      ];
      const sanitized = v.every((s) => allowedSources.includes(s)) ? v.join(",") : this.redactedValue;
      this.trackCliOption({
        option: "source",
        value: sanitized
      });
    }
  }
  trackCliOptionSince(v) {
    if (v) {
      this.trackCliOption({
        option: "since",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionUntil(v) {
    if (v) {
      this.trackCliOption({
        option: "until",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionLimit(v) {
    if (typeof v === "number") {
      this.trackCliOption({
        option: "limit",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagJson(v) {
    if (v) {
      this.trackCliFlag("json");
    }
  }
  trackCliFlagFollow(v) {
    if (v) {
      this.trackCliFlag("follow");
    }
  }
  trackCliFlagNoFollow(v) {
    if (v) {
      this.trackCliFlag("no-follow");
    }
  }
  trackCliOptionQuery(v) {
    if (v) {
      this.trackCliOption({
        option: "query",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionRequestId(v) {
    if (v) {
      this.trackCliOption({
        option: "request-id",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagExpand(v) {
    if (v) {
      this.trackCliFlag("expand");
    }
  }
  trackCliOptionBranch(v) {
    if (v) {
      this.trackCliOption({
        option: "branch",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagNoBranch(v) {
    if (v) {
      this.trackCliFlag("no-branch");
    }
  }
};

// src/commands/logs/index.ts
async function getLatestDeploymentByBranch(client, projectId, branch) {
  const branchMetaKeys = [
    "githubCommitRef",
    "gitlabCommitRef",
    "bitbucketCommitRef"
  ];
  for (const metaKey of branchMetaKeys) {
    const query = new URLSearchParams();
    query.set("projectId", projectId);
    query.set("limit", "1");
    query.set("state", "READY");
    query.set(`meta-${metaKey}`, branch);
    const { deployments } = await client.fetch(
      `/v6/deployments?${query}`
    );
    if (deployments.length > 0) {
      return {
        id: deployments[0].uid,
        url: deployments[0].url
      };
    }
  }
  return null;
}
var TIME_ONLY_FORMAT = "HH:mm:ss.SS";
var DATE_TIME_FORMAT = "MMM DD HH:mm:ss.SS";
function table2({
  columns,
  rows,
  tableWidth,
  formatHeader,
  formatRow
}) {
  const zeroPad = [0, 0];
  const maxWidths = columns.map((col) => {
    const headerWidth = col.label.length;
    const maxContent = Math.max(
      headerWidth,
      ...rows.map((row) => col.getValue(row).length)
    );
    return maxContent;
  });
  const colPaddings = columns.map(
    (col) => col.padding ?? zeroPad
  );
  const finalWidths = [];
  let usedWidth = 0;
  let stretchIndex = -1;
  for (let i = 0; i < columns.length; i++) {
    const col = columns[i];
    const padding2 = colPaddings[i][0] + colPaddings[i][1];
    if (col.width === "stretch") {
      stretchIndex = i;
      finalWidths.push(0);
    } else if (typeof col.width === "number") {
      finalWidths.push(col.width);
      usedWidth += col.width + padding2;
    } else {
      finalWidths.push(maxWidths[i]);
      usedWidth += maxWidths[i] + padding2;
    }
  }
  usedWidth += (columns.length - 1) * 2;
  if (stretchIndex >= 0) {
    const stretchPadding = colPaddings[stretchIndex][0] + colPaddings[stretchIndex][1];
    finalWidths[stretchIndex] = Math.max(
      10,
      tableWidth - usedWidth - stretchPadding
    );
  }
  const pad = (value, width) => {
    if (value.length > width) {
      return value.slice(0, width - 1) + "\u2026";
    }
    return value.padEnd(width);
  };
  const headerStr = columns.map((col, i) => {
    const padded = pad(col.label, finalWidths[i]);
    return " ".repeat(colPaddings[i][0]) + padded + " ".repeat(colPaddings[i][1]);
  }).join("  ");
  const header = formatHeader ? formatHeader(headerStr) : headerStr;
  const formattedRows = rows.map((row) => {
    const rowStr = columns.map((col, i) => {
      const value = col.getValue(row);
      const padded = pad(value, finalWidths[i]);
      const formatted = col.format ? col.format(padded, row) : padded;
      return " ".repeat(colPaddings[i][0]) + formatted + " ".repeat(colPaddings[i][1]);
    }).join("  ");
    return formatRow ? formatRow(rowStr, row) : rowStr;
  });
  return { header, rows: formattedRows };
}
function logsSpanMultipleDays(logs2) {
  if (logs2.length === 0)
    return false;
  const firstDay = new Date(logs2[0].timestamp).toDateString();
  return logs2.some((log) => new Date(log.timestamp).toDateString() !== firstDay);
}
function parseLevels(levels) {
  if (!levels)
    return [];
  if (typeof levels === "string")
    return [levels];
  return levels;
}
function parseSources(sources) {
  if (!sources)
    return [];
  if (typeof sources === "string")
    return [sources];
  return sources;
}
async function logs(client) {
  let parsedArguments;
  const flagsSpecification = getFlagsSpecification(logsCommand.options);
  try {
    parsedArguments = parseArguments(client.argv.slice(2), flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const telemetry2 = new LogsTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  if (parsedArguments.flags["--help"]) {
    telemetry2.trackCliFlagHelp("logs");
    output_manager_default.print(help(logsCommand, { columns: client.stderr.columns }));
    return 2;
  }
  const subArgs = parsedArguments.args.slice(1);
  const [deploymentArgument] = subArgs;
  const projectOption = parsedArguments.flags["--project"];
  const deploymentFlag = parsedArguments.flags["--deployment"];
  const environmentOption = parsedArguments.flags["--environment"];
  let deploymentOption = deploymentFlag;
  if (deploymentArgument) {
    let deploymentIdOrHost = deploymentArgument;
    try {
      deploymentIdOrHost = new URL(deploymentArgument).hostname;
    } catch {
    }
    deploymentOption = deploymentIdOrHost;
  }
  const levelOption = parsedArguments.flags["--level"];
  const statusCodeOption = parsedArguments.flags["--status-code"];
  const sourceOption = parsedArguments.flags["--source"];
  const sinceOption = parsedArguments.flags["--since"];
  const untilOption = parsedArguments.flags["--until"];
  const limitOption = parsedArguments.flags["--limit"];
  const jsonOption = parsedArguments.flags["--json"];
  const queryOption = parsedArguments.flags["--query"];
  const requestIdOption = parsedArguments.flags["--request-id"];
  const expandOption = parsedArguments.flags["--expand"];
  const branchFlagValue = parsedArguments.flags["--branch"];
  const followFlagValue = parsedArguments.flags["--follow"];
  const noFollowFlagValue = parsedArguments.flags["--no-follow"];
  const followOption = deploymentOption && !noFollowFlagValue ? true : followFlagValue;
  telemetry2.trackCliArgumentUrlOrDeploymentId(deploymentArgument);
  telemetry2.trackCliOptionProject(projectOption);
  telemetry2.trackCliOptionDeployment(deploymentFlag);
  telemetry2.trackCliOptionEnvironment(environmentOption);
  telemetry2.trackCliOptionLevel(levelOption);
  telemetry2.trackCliOptionStatusCode(statusCodeOption);
  telemetry2.trackCliOptionSource(sourceOption);
  telemetry2.trackCliOptionSince(sinceOption);
  telemetry2.trackCliOptionUntil(untilOption);
  telemetry2.trackCliOptionLimit(limitOption);
  telemetry2.trackCliFlagJson(jsonOption);
  telemetry2.trackCliFlagFollow(followOption);
  telemetry2.trackCliOptionQuery(queryOption);
  telemetry2.trackCliOptionRequestId(requestIdOption);
  telemetry2.trackCliFlagExpand(expandOption);
  telemetry2.trackCliOptionBranch(branchFlagValue);
  if (followOption) {
    const incompatibleFlags = [
      { flag: "--environment", value: environmentOption },
      { flag: "--level", value: levelOption },
      { flag: "--status-code", value: statusCodeOption },
      { flag: "--source", value: sourceOption },
      { flag: "--since", value: sinceOption },
      { flag: "--until", value: untilOption },
      { flag: "--limit", value: limitOption },
      { flag: "--query", value: queryOption },
      { flag: "--request-id", value: requestIdOption }
    ];
    const usedIncompatible = incompatibleFlags.filter((f) => f.value !== void 0 && f.value !== null).map((f) => import_chalk72.default.bold(f.flag));
    if (usedIncompatible.length > 0) {
      output_manager_default.error(
        `The ${import_chalk72.default.bold("--follow")} flag does not support filtering. Remove: ${usedIncompatible.join(", ")}`
      );
      return 1;
    }
  }
  let contextName = null;
  try {
    ({ contextName } = await getScope(client));
  } catch (err) {
    if ((0, import_error_utils9.isErrnoException)(err) && (err.code === "NOT_AUTHORIZED" || err.code === "TEAM_DELETED")) {
      output_manager_default.error(err.message);
      return 1;
    }
    throw err;
  }
  let projectId;
  let projectSlug;
  let orgSlug;
  let ownerId;
  if (projectOption) {
    output_manager_default.spinner(`Fetching project "${projectOption}"`, 1e3);
    const project = await getProjectByNameOrId(
      client,
      projectOption,
      client.config.currentTeam
    );
    output_manager_default.stopSpinner();
    if (project instanceof ProjectNotFound) {
      output_manager_default.error(`Project not found: ${projectOption}`);
      return 1;
    }
    projectId = project.id;
    projectSlug = project.name;
    orgSlug = contextName;
    ownerId = project.accountId;
  } else {
    const link = await getLinkedProject(client);
    if (link.status === "error") {
      return link.exitCode;
    } else if (link.status === "not_linked") {
      output_manager_default.error(
        `Your codebase isn't linked to a project on Vercel. Run ${getCommandName(
          "link"
        )} to begin, or specify a project with ${import_chalk72.default.bold("--project")}.`
      );
      return 1;
    }
    client.config.currentTeam = link.org.type === "team" ? link.org.id : void 0;
    projectId = link.project.id;
    projectSlug = link.project.name;
    orgSlug = link.org.slug;
    ownerId = link.org.id;
  }
  let deploymentId;
  if (deploymentOption) {
    output_manager_default.spinner(`Resolving deployment "${deploymentOption}"`, 1e3);
    try {
      const deployment = await getDeployment(
        client,
        contextName,
        deploymentOption
      );
      deploymentId = deployment.id;
      output_manager_default.stopSpinner();
    } catch (err) {
      output_manager_default.stopSpinner();
      if (err instanceof DeploymentNotFound) {
        output_manager_default.error(`Deployment not found: ${deploymentOption}`);
        return 1;
      }
      if (err instanceof InvalidDeploymentId) {
        output_manager_default.error(`Invalid deployment ID: ${deploymentOption}`);
        return 1;
      }
      throw err;
    }
  }
  const noBranchFlagValue = parsedArguments.flags["--no-branch"];
  let branchOption;
  if (typeof branchFlagValue === "string") {
    branchOption = branchFlagValue;
  } else if (!noBranchFlagValue && !deploymentId) {
    try {
      const gitMeta = await createGitMeta(client.cwd);
      if (gitMeta?.commitRef) {
        branchOption = gitMeta.commitRef;
        output_manager_default.debug(`Detected git branch: ${branchOption}`);
      }
    } catch {
    }
  }
  if (followOption) {
    if (!deploymentId) {
      if (noBranchFlagValue) {
        output_manager_default.error(
          `The ${import_chalk72.default.bold("--follow")} flag requires a deployment. Specify one with ${import_chalk72.default.bold("--deployment")} or remove ${import_chalk72.default.bold("--no-branch")} to auto-detect from the current git branch.`
        );
        return 1;
      }
      if (!branchOption) {
        output_manager_default.error(
          `The ${import_chalk72.default.bold("--follow")} flag requires a deployment. Specify one with ${import_chalk72.default.bold("--deployment")} or run from within a git repository.`
        );
        return 1;
      }
      output_manager_default.spinner(
        `Finding latest deployment for branch "${branchOption}"`,
        1e3
      );
      const branchDeployment = await getLatestDeploymentByBranch(
        client,
        projectId,
        branchOption
      );
      output_manager_default.stopSpinner();
      if (!branchDeployment) {
        output_manager_default.error(
          `No deployments found for branch "${branchOption}". Deploy this branch first or specify a deployment with ${import_chalk72.default.bold("--deployment")}.`
        );
        return 1;
      }
      deploymentId = branchDeployment.id;
      output_manager_default.debug(
        `Found deployment ${deploymentId} for branch ${branchOption}`
      );
    }
    if (!jsonOption) {
      output_manager_default.print(
        `Streaming logs for deployment ${import_chalk72.default.bold(deploymentId)} starting from ${import_chalk72.default.bold((0, import_date_fns2.format)(Date.now(), TIME_ONLY_FORMAT))}

`
      );
    }
    const abortController = new AbortController();
    return await displayRuntimeLogs(
      client,
      {
        deploymentId,
        projectId,
        parse: !jsonOption
      },
      abortController
    );
  }
  if (environmentOption && !["production", "preview"].includes(environmentOption)) {
    output_manager_default.error(
      `Invalid environment: ${environmentOption}. Must be "production" or "preview".`
    );
    return 1;
  }
  const validLevels = ["error", "warning", "info", "fatal"];
  const levels = parseLevels(levelOption);
  for (const level of levels) {
    if (!validLevels.includes(level)) {
      output_manager_default.error(
        `Invalid log level: ${level}. Must be one of: ${validLevels.join(", ")}.`
      );
      return 1;
    }
  }
  const validSources = [
    "serverless",
    "edge-function",
    "edge-middleware",
    "static"
  ];
  const sources = parseSources(sourceOption);
  for (const source of sources) {
    if (!validSources.includes(source)) {
      output_manager_default.error(
        `Invalid source: ${source}. Must be one of: ${validSources.join(", ")}.`
      );
      return 1;
    }
  }
  const limit = limitOption ?? 100;
  output_manager_default.spinner("Fetching logs...", 1e3);
  const terminalWidth = client.stderr.isTTY ? client.stderr.columns || 120 : 120;
  const logs2 = [];
  try {
    for await (const log of fetchAllRequestLogs(client, {
      projectId,
      ownerId,
      deploymentId,
      environment: environmentOption,
      level: levels.length > 0 ? levels : void 0,
      statusCode: statusCodeOption,
      source: sources.length > 0 ? sources : void 0,
      since: sinceOption,
      until: untilOption,
      limit,
      search: queryOption,
      requestId: requestIdOption,
      branch: branchOption
    })) {
      output_manager_default.stopSpinner();
      if (jsonOption) {
        client.stdout.write(JSON.stringify(log) + "\n");
      } else {
        logs2.push(log);
      }
    }
  } catch (err) {
    output_manager_default.stopSpinner();
    printError(err);
    return 1;
  }
  output_manager_default.stopSpinner();
  if (!jsonOption) {
    const branchSuffix = branchOption ? ` on branch ${import_chalk72.default.cyan(branchOption)}` : "";
    if (logs2.length === 0) {
      output_manager_default.print(
        import_chalk72.default.dim(
          `No logs found for ${formatProject(orgSlug, projectSlug)}${branchSuffix}
`
        )
      );
    } else {
      const showDate = logsSpanMultipleDays(logs2);
      const timeFormat = showDate ? DATE_TIME_FORMAT : TIME_ONLY_FORMAT;
      const rowData = logs2.map((log) => {
        const statusCode = log.responseStatusCode;
        return {
          time: (0, import_date_fns2.format)(log.timestamp, timeFormat),
          host: log.domain || "",
          level: log.level,
          path: `${getSourceIcon(log.source)} ${log.requestMethod} ${log.requestPath}`,
          status: !statusCode || statusCode <= 0 ? "---" : String(statusCode),
          statusCode,
          message: log.message?.replace(/\n/g, " ").trim() || "",
          messageTruncated: log.messageTruncated
        };
      });
      const baseColumns = [
        {
          label: "TIME",
          getValue: (row) => row.time,
          format: (padded) => import_chalk72.default.dim(padded)
        },
        {
          label: "HOST",
          getValue: (row) => row.host,
          format: (padded) => import_chalk72.default.dim(padded)
        },
        {
          label: "LEVEL",
          getValue: (row) => row.level,
          format: (padded, row) => colorizeLevel(padded, row.level)
        },
        {
          label: "",
          padding: [0, 3],
          getValue: (row) => row.path
        }
      ];
      const columns = expandOption ? baseColumns : [
        ...baseColumns,
        {
          label: "STATUS",
          getValue: (row) => row.status,
          format: (padded, row) => row.statusCode <= 0 ? import_chalk72.default.gray(padded) : colorizeStatus(padded, row.statusCode)
        },
        {
          label: "MESSAGE",
          width: "stretch",
          getValue: (row) => row.message || "(no message)",
          format: (padded, row) => row.message ? colorizeMessage(padded, row.level) : import_chalk72.default.dim(padded)
        }
      ];
      const formatted = table2({
        columns,
        rows: rowData,
        tableWidth: terminalWidth,
        formatHeader: (header) => import_chalk72.default.dim(header),
        formatRow: expandOption ? (rowStr, row) => {
          if (row.message) {
            const coloredMessage = colorizeMessage(row.message, row.level);
            const truncatedIndicator = row.messageTruncated ? import_chalk72.default.gray("\u2026") : "";
            return `${rowStr}
${coloredMessage}${truncatedIndicator}
`;
          }
          return rowStr + "\n";
        } : void 0
      });
      output_manager_default.print(formatted.header + "\n");
      for (const row of formatted.rows) {
        output_manager_default.print(row + "\n");
      }
      output_manager_default.print(
        import_chalk72.default.gray(
          `Fetched ${logs2.length} logs for ${formatProject(orgSlug, projectSlug)}${branchSuffix}
`
        )
      );
    }
  }
  return 0;
}
function colorizeLevel(formatted, level) {
  switch (level) {
    case "fatal":
      return import_chalk72.default.red.bold(formatted);
    case "error":
      return import_chalk72.default.red(formatted);
    case "warning":
      return import_chalk72.default.yellow(formatted);
    default:
      return import_chalk72.default.dim(formatted);
  }
}
function colorizeStatus(formatted, statusCode) {
  if (statusCode >= 500) {
    return import_chalk72.default.red(formatted);
  } else if (statusCode >= 400) {
    return import_chalk72.default.yellow(formatted);
  } else if (statusCode >= 300) {
    return import_chalk72.default.cyan(formatted);
  } else if (statusCode >= 200) {
    return import_chalk72.default.green(formatted);
  }
  return import_chalk72.default.gray(formatted);
}
function getSourceIcon(source) {
  switch (source) {
    case "serverless":
    case "lambda":
      return "\u03BB";
    case "edge-function":
    case "edge-middleware":
    case "middleware":
      return "\u03B5";
    case "static":
    case "external":
    case "redirect":
      return "\u25C7";
    default:
      return " ";
  }
}
function colorizeMessage(message, level) {
  switch (level) {
    case "fatal":
    case "error":
      return import_chalk72.default.red(message);
    case "warning":
      return import_chalk72.default.yellow(message);
    default:
      return import_chalk72.default.dim(message);
  }
}

// src/commands/mcp/mcp.ts
import { execSync } from "child_process";
var MCP_ENDPOINT = "https://mcp.vercel.com";
function getAvailableClients() {
  return [
    "Claude Code",
    "Claude.ai and Claude for desktop",
    "Cursor",
    "VS Code with Copilot"
  ];
}
function safeExecSync(command, options = {}) {
  try {
    return execSync(command, {
      stdio: "pipe",
      encoding: "utf8",
      ...options
    });
  } catch (error) {
    return { error: error.message, stderr: error.stderr?.toString() || "" };
  }
}
async function getProjectSpecificUrl(client) {
  try {
    const linkedProject = await getLinkedProject(client);
    if (linkedProject.status !== "linked" || !linkedProject.org || !linkedProject.project) {
      return null;
    }
    const { org, project } = linkedProject;
    return {
      url: `${MCP_ENDPOINT}/${org.slug}/${project.name}`,
      projectName: project.name
    };
  } catch (error) {
    return null;
  }
}
async function mcp(client) {
  output_manager_default.print("\u{1F680} Vercel MCP Setup \u2014 Automated\n");
  const isProjectSpecific = client.argv.includes("--project");
  if (isProjectSpecific) {
    output_manager_default.print("\u{1F517} Setting up project-specific MCP access...\n");
    const projectInfo = await getProjectSpecificUrl(client);
    if (!projectInfo) {
      output_manager_default.print(
        "\u274C No linked project found. Please link your project first:\n"
      );
      output_manager_default.print("   vercel link\n");
      return 1;
    }
    output_manager_default.print(`\u2705 Project-specific URL: ${projectInfo.url}
`);
    output_manager_default.print(
      "This URL will automatically provide project and team context.\n\n"
    );
  }
  const availableClients = getAvailableClients();
  const selectedClients = await client.input.checkbox({
    message: "Select MCP clients to set up:",
    choices: availableClients.map((name) => ({
      name,
      value: name,
      short: name
    }))
  });
  if (!Array.isArray(selectedClients) || selectedClients.length === 0) {
    output_manager_default.print("\nNo clients selected. Exiting.\n");
    return 0;
  }
  const summary = [];
  output_manager_default.print("\nStarting setup...\n");
  for (const clientName of selectedClients) {
    output_manager_default.print(`\u{1F527} Setting up ${clientName}...
`);
    if (clientName === "Claude Code") {
      const mcpUrl = isProjectSpecific ? (await getProjectSpecificUrl(client))?.url : MCP_ENDPOINT;
      const mcpName = isProjectSpecific ? `vercel-${(await getProjectSpecificUrl(client))?.projectName}` : "vercel";
      const result = safeExecSync(
        `claude mcp add --transport http ${mcpName} ${mcpUrl}`
      );
      if (typeof result === "object" && "error" in result) {
        if (result.stderr?.includes("already exists")) {
          summary.push("\u2705 Claude Code: Vercel MCP already configured");
          output_manager_default.print("\u2139\uFE0F  Vercel MCP is already configured in Claude Code\n");
          output_manager_default.print("\u2500".repeat(50) + "\n");
        } else {
          summary.push("\u274C Claude Code: Failed to add MCP server");
          output_manager_default.print("\u{1F4A1} Manual setup required:\n");
          output_manager_default.print(
            `   claude mcp add --transport http ${mcpName} ${mcpUrl}
`
          );
          output_manager_default.print(
            "   # Or use the /mcp command in Claude Code to authenticate\n"
          );
          output_manager_default.print("\u2500".repeat(50) + "\n");
        }
      } else {
        summary.push("\u2705 Claude Code: Vercel MCP added successfully");
        output_manager_default.print("\u2705 Successfully added Vercel MCP to Claude Code\n");
        output_manager_default.print(
          "\u2139\uFE0F You may need to authenticate using the /mcp command in Claude Code\n"
        );
        output_manager_default.print("\u2500".repeat(50) + "\n");
      }
    } else if (clientName === "Claude.ai and Claude for desktop") {
      output_manager_default.print(
        "\u{1F4A1} Manual setup required for Claude.ai and Claude for desktop\n"
      );
      output_manager_default.print("   1. Open Settings in the sidebar\n");
      output_manager_default.print(
        "   2. Navigate to Connectors and select Add custom connector\n"
      );
      output_manager_default.print("   3. Configure the connector:\n");
      if (isProjectSpecific) {
        const projectInfo = await getProjectSpecificUrl(client);
        const projectName = projectInfo?.projectName || "project";
        output_manager_default.print(`      \u2022 Name: Vercel ${projectName}
`);
        output_manager_default.print(`      \u2022 URL: ${projectInfo?.url}
`);
      } else {
        output_manager_default.print("      \u2022 Name: Vercel\n");
        output_manager_default.print(`      \u2022 URL: ${MCP_ENDPOINT}
`);
      }
      output_manager_default.print("   4. Complete the authentication flow\n");
      summary.push("\u2139\uFE0F  Claude.ai/Desktop: Manual setup required");
      output_manager_default.print("\u2500".repeat(50) + "\n");
    } else if (clientName === "Cursor") {
      const cursorCheck = safeExecSync(
        process.platform === "darwin" ? "ls /Applications/Cursor.app" : process.platform === "win32" ? "where cursor" : "which cursor"
      );
      if (typeof cursorCheck === "object" && "error" in cursorCheck) {
        output_manager_default.print("\u26A0\uFE0F Cursor not detected. Please install Cursor first.\n");
        output_manager_default.print("   Download from: https://cursor.sh\n");
        output_manager_default.print("\n");
        summary.push("\u26A0\uFE0F Cursor: Not installed");
        output_manager_default.print("\u2500".repeat(50) + "\n");
        continue;
      }
      const mcpUrl = isProjectSpecific ? (await getProjectSpecificUrl(client))?.url : MCP_ENDPOINT;
      const serverName = isProjectSpecific ? `vercel-${(await getProjectSpecificUrl(client))?.projectName}` : "vercel";
      const cursorConfigPath = process.platform === "darwin" ? `${process.env.HOME}/Library/Application Support/Cursor/User/settings.json` : process.platform === "win32" ? `${process.env.APPDATA}/Cursor/User/settings.json` : `${process.env.HOME}/.config/Cursor/User/settings.json`;
      const cursorMcpPath = process.platform === "darwin" ? `${process.env.HOME}/.cursor/mcp.json` : process.platform === "win32" ? `${process.env.APPDATA}/Cursor/mcp.json` : `${process.env.HOME}/.cursor/mcp.json`;
      let cursorAlreadyConfigured = false;
      try {
        const fs2 = __require("fs");
        if (fs2.existsSync(cursorMcpPath)) {
          const configContent = fs2.readFileSync(cursorMcpPath, "utf8");
          const config2 = JSON.parse(configContent);
          const mcpServers = config2.mcpServers || {};
          cursorAlreadyConfigured = Object.values(mcpServers).some(
            (server) => server.url === mcpUrl || server.url === MCP_ENDPOINT
          );
        }
        if (!cursorAlreadyConfigured && fs2.existsSync(cursorConfigPath)) {
          const configContent = fs2.readFileSync(cursorConfigPath, "utf8");
          const config2 = JSON.parse(configContent);
          const mcpServers = config2["mcp.servers"] || {};
          cursorAlreadyConfigured = Object.values(mcpServers).some(
            (server) => server.url === mcpUrl || server.url === MCP_ENDPOINT
          );
        }
      } catch (error) {
      }
      if (cursorAlreadyConfigured) {
        summary.push("\u2705 Cursor: Vercel MCP already configured");
        output_manager_default.print("\u2139\uFE0F  Vercel MCP is already configured in Cursor\n");
        output_manager_default.print("\u2500".repeat(50) + "\n");
        continue;
      }
      const config = {
        url: mcpUrl,
        name: serverName
      };
      const configJson = JSON.stringify(config);
      const encodedConfig = Buffer.from(configJson).toString("base64");
      const oneClickUrl = `cursor://anysphere.cursor-deeplink/mcp/install?name=${serverName}&config=${encodedConfig}`;
      try {
        if (process.platform === "darwin") {
          execSync(`open '${oneClickUrl}'`);
        } else if (process.platform === "win32") {
          execSync(`start ${oneClickUrl}`);
        } else {
          execSync(`xdg-open '${oneClickUrl}'`);
        }
        summary.push("\u2705 Cursor: One-click installer opened");
        output_manager_default.print("\u2139\uFE0F  Follow the prompts in Cursor to complete setup\n");
      } catch (error) {
        summary.push("\u26A0\uFE0F Cursor: Deep link may not have worked");
        output_manager_default.print("\u26A0\uFE0F Could not open Cursor automatically\n");
        output_manager_default.print("\u{1F4A1} Manual setup:\n");
        output_manager_default.print("   1. Open Cursor\n");
        output_manager_default.print("   2. Go to Settings (Cmd+, / Ctrl+,)\n");
        output_manager_default.print("   3. Navigate to MCP section\n");
        output_manager_default.print('   4. Click "Add Server"\n');
        output_manager_default.print("   5. Enter the following details:\n");
        output_manager_default.print(`      \u2022 Name: ${serverName}
`);
        output_manager_default.print(`      \u2022 URL: ${mcpUrl}
`);
        output_manager_default.print(
          '   6. Click "Add" and follow the authorization prompts\n'
        );
        output_manager_default.print("\u2500".repeat(50) + "\n");
      }
    } else if (clientName === "VS Code with Copilot") {
      const copilotCheck = safeExecSync(
        "code --list-extensions | grep -i copilot"
      );
      if (typeof copilotCheck === "object" && "error" in copilotCheck) {
        output_manager_default.print(
          "\u26A0\uFE0F GitHub Copilot not detected. MCP functionality may be limited.\n"
        );
        output_manager_default.print("   1. Open VS Code\n");
        output_manager_default.print("   2. Go to Extensions (Cmd+Shift+X / Ctrl+Shift+X)\n");
        output_manager_default.print('   3. Search for "GitHub Copilot"\n');
        output_manager_default.print(
          "   4. Install and authenticate with your GitHub account\n"
        );
        output_manager_default.print("   5. Restart VS Code\n");
        output_manager_default.print("\n");
      }
      const mcpUrl = isProjectSpecific ? (await getProjectSpecificUrl(client))?.url : MCP_ENDPOINT;
      const serverName = isProjectSpecific ? `vercel-${(await getProjectSpecificUrl(client))?.projectName}` : "vercel";
      const vscodeConfigPath = process.platform === "darwin" ? `${process.env.HOME}/Library/Application Support/Code/User/settings.json` : process.platform === "win32" ? `${process.env.APPDATA}/Code/User/settings.json` : `${process.env.HOME}/.config/Code/User/settings.json`;
      const vscodeMcpPath = process.platform === "darwin" ? `${process.env.HOME}/Library/Application Support/Code/User/mcp.json` : process.platform === "win32" ? `${process.env.APPDATA}/Code/User/mcp.json` : `${process.env.HOME}/.config/Code/User/mcp.json`;
      let vscodeAlreadyConfigured = false;
      try {
        const fs2 = __require("fs");
        if (fs2.existsSync(vscodeMcpPath)) {
          const configContent = fs2.readFileSync(vscodeMcpPath, "utf8");
          const config2 = JSON.parse(configContent);
          const mcpServers = config2.servers || {};
          vscodeAlreadyConfigured = Object.values(mcpServers).some(
            (server) => server.url === mcpUrl || server.url === MCP_ENDPOINT
          );
        }
        if (!vscodeAlreadyConfigured && fs2.existsSync(vscodeConfigPath)) {
          const configContent = fs2.readFileSync(vscodeConfigPath, "utf8");
          const config2 = JSON.parse(configContent);
          const mcpServers = config2["mcp.servers"] || {};
          vscodeAlreadyConfigured = Object.values(mcpServers).some(
            (server) => server.url === mcpUrl || server.url === MCP_ENDPOINT
          );
        }
      } catch (error) {
      }
      if (vscodeAlreadyConfigured) {
        summary.push("\u2705 VS Code: Vercel MCP already configured");
        output_manager_default.print("\u2139\uFE0F  Vercel MCP is already configured in VS Code\n");
        output_manager_default.print("\u2500".repeat(50) + "\n");
        continue;
      }
      const config = {
        name: serverName,
        url: mcpUrl
      };
      const encodedConfig = encodeURIComponent(JSON.stringify(config));
      const oneClickUrl = `vscode:mcp/install?${encodedConfig}`;
      try {
        if (process.platform === "darwin") {
          execSync(`open '${oneClickUrl}'`);
        } else if (process.platform === "win32") {
          execSync(`start ${oneClickUrl}`);
        } else {
          execSync(`xdg-open '${oneClickUrl}'`);
        }
        summary.push("\u2705 VS Code: One-click installer opened");
        output_manager_default.print("\u2139\uFE0F  Follow the prompts in VS Code to complete setup\n");
      } catch (error) {
        summary.push("\u274C VS Code: Failed to open one-click installer");
        output_manager_default.print("\u{1F4A1} Manual setup instructions:\n");
        output_manager_default.print("   1. Open VS Code\n");
        output_manager_default.print(
          "   2. Press Cmd+Shift+P (Mac) or Ctrl+Shift+P (Windows/Linux)\n"
        );
        output_manager_default.print('   3. Type "MCP: Add Server" and press Enter\n');
        output_manager_default.print("   4. Select HTTP\n");
        output_manager_default.print("   5. Enter the following details:\n");
        output_manager_default.print(`      \u2022 URL: ${mcpUrl}
`);
        output_manager_default.print(`      \u2022 Name: ${serverName}
`);
        output_manager_default.print(
          "   6. Select Global or Workspace depending on your needs\n"
        );
        output_manager_default.print("   7. Click Add\n");
        output_manager_default.print("   8. Follow the authorization steps\n");
        output_manager_default.print("\u2500".repeat(50) + "\n");
      }
    }
  }
  output_manager_default.print("\u{1F4CA} Setup Summary\n");
  output_manager_default.print("\u2500".repeat(50) + "\n");
  summary.forEach((line) => output_manager_default.print(`${line}
`));
  output_manager_default.print("\u2728 Setup complete! Restart your clients if needed.\n");
  return 0;
}

// src/commands/mcp/index.ts
async function main11(client) {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(mcpCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  if (parsedArgs.flags["--help"]) {
    output_manager_default.print(help(mcpCommand, { columns: client.stderr.columns }));
    return 2;
  }
  if (parsedArgs.flags["--project"]) {
    client.argv.push("--project");
  }
  try {
    return await mcp(client);
  } catch (err) {
    output_manager_default.prettyError(err);
    return 1;
  }
}

// src/commands/microfrontends/pull.ts
var import_chalk73 = __toESM(require_source(), 1);
import { join as join3 } from "path";
var import_fs_extra = __toESM(require_lib(), 1);
var VERCEL_DIR = ".vercel";
var VERCEL_DIR_MICROFRONTENDS = "microfrontends.json";
async function pull2(client) {
  const link = await ensureLink("microfrontends", client, client.cwd);
  if (typeof link === "number") {
    return link;
  }
  const { project, org, repoRoot } = link;
  let currentDirectory;
  if (repoRoot) {
    currentDirectory = join3(repoRoot, project.rootDirectory || "");
  } else {
    currentDirectory = client.cwd;
  }
  client.config.currentTeam = org.type === "team" ? org.id : void 0;
  const { contextName } = await getScope(client);
  output_manager_default.spinner(
    `Fetching microfrontends configuration in ${import_chalk73.default.bold(contextName)}`
  );
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(pullSubcommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  let rawConfig;
  const dpl = parsedArgs.flags["--dpl"];
  try {
    if (dpl) {
      const { config } = await client.fetch(`/v1/microfrontends/${dpl}/config`, {
        method: "GET"
      });
      rawConfig = config;
    } else {
      const projectId = project.id;
      const { config } = await client.fetch(`/v1/microfrontends/projects/${projectId}/production-mfe-config`, {
        method: "GET"
      });
      rawConfig = config;
    }
    const sanitizedConfig = {
      ...rawConfig,
      applications: Object.fromEntries(
        Object.entries(rawConfig.applications).map(([name, app]) => [
          name,
          {
            ...app,
            projectId: void 0
            // remove projectId
          }
        ])
      )
    };
    output_manager_default.stopSpinner();
    const path3 = join3(currentDirectory, VERCEL_DIR, VERCEL_DIR_MICROFRONTENDS);
    await (0, import_fs_extra.outputJSON)(path3, sanitizedConfig, {
      spaces: 2
    });
    const microfrontendsStamp = stamp_default();
    output_manager_default.print(
      `${prependEmoji(
        `Downloaded microfrontends configuration to ${import_chalk73.default.bold(
          humanizePath(
            join3(currentDirectory, VERCEL_DIR, VERCEL_DIR_MICROFRONTENDS)
          )
        )} ${import_chalk73.default.gray(microfrontendsStamp())}`,
        emoji("success")
      )}
`
    );
    return 0;
  } catch (error) {
    output_manager_default.stopSpinner();
    printError(error);
    return 1;
  }
}

// src/util/telemetry/commands/microfrontends/index.ts
var MicrofrontendsTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandPull(actual) {
    this.trackCliSubcommand({
      subcommand: "pull",
      value: actual
    });
  }
};

// src/commands/microfrontends/index.ts
var COMMAND_CONFIG15 = {
  pull: getCommandAliases(pullSubcommand)
};
async function main12(client) {
  const telemetry2 = new MicrofrontendsTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(
    microfrontendsCommand.options
  );
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification, {
      permissive: true
    });
  } catch (error) {
    printError(error);
    return 1;
  }
  let { subcommand, subcommandOriginal } = getSubcommand2(
    parsedArgs.args.slice(1),
    COMMAND_CONFIG15
  );
  const needHelp = parsedArgs.flags["--help"];
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp("microfrontends");
    output_manager_default.print(
      help(microfrontendsCommand, { columns: client.stderr.columns })
    );
    return 2;
  }
  function printHelp(command) {
    output_manager_default.print(
      help(command, {
        parent: microfrontendsCommand,
        columns: client.stderr.columns
      })
    );
    return 2;
  }
  switch (subcommand) {
    case "pull":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("microfrontends", subcommandOriginal);
        return printHelp(pullSubcommand);
      }
      telemetry2.trackCliSubcommandPull(subcommandOriginal);
      return pull2(client);
    default:
      output_manager_default.error(getInvalidSubcommand(COMMAND_CONFIG15));
      output_manager_default.print(
        help(microfrontendsCommand, { columns: client.stderr.columns })
      );
      return 2;
  }
}

// src/commands/open/index.ts
var import_open6 = __toESM(require_open(), 1);

// src/util/telemetry/commands/open/index.ts
var OpenTelemetryClient = class extends TelemetryClient {
  trackCliCommandOpen(value) {
    this.trackCliCommand({
      command: "open",
      value
    });
  }
};

// src/commands/open/index.ts
async function openCommandHandler(client) {
  let parsedArgs = null;
  const flagsSpecification = getFlagsSpecification(openCommand.options);
  const telemetry2 = new OpenTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  if (parsedArgs.flags["--help"]) {
    telemetry2.trackCliFlagHelp("open");
    output_manager_default.print(help(openCommand, { columns: client.stderr.columns }));
    return 0;
  }
  const { getLinkedProject: getLinkedProject2 } = await import("./chunks/link-CWVBI7DX.js");
  const linkCheck = await getLinkedProject2(client, client.cwd);
  if (linkCheck.status !== "linked" || !linkCheck.org || !linkCheck.project) {
    output_manager_default.error("This command requires a linked project. Please run:");
    output_manager_default.print(`  vercel link
`);
    return 1;
  }
  const link = await ensureLink("open", client, client.cwd);
  if (typeof link === "number") {
    return link;
  }
  if (link.status !== "linked" || !link.org || !link.project) {
    output_manager_default.error("This command requires a linked project. Please run:");
    output_manager_default.print("  vercel link\n");
    return 1;
  }
  const { org, project } = link;
  const projectUrl = `https://vercel.com/${org.slug}/${project.name}`;
  output_manager_default.log(`Opening ${projectUrl} in your browser...`);
  await (0, import_open6.default)(projectUrl);
  return 0;
}

// src/commands/project/add.ts
var import_chalk74 = __toESM(require_source(), 1);
var import_ms15 = __toESM(require_ms(), 1);

// src/util/telemetry/commands/project/add.ts
var ProjectAddTelemetryClient = class extends TelemetryClient {
  trackCliArgumentName(name) {
    if (name) {
      this.trackCliArgument({
        arg: "name",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/project/add.ts
async function add6(client, argv) {
  const telemetryClient = new ProjectAddTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(addSubcommand6.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args } = parsedArgs;
  if (args.length !== 1) {
    output_manager_default.error(
      `Invalid number of arguments. Usage: ${import_chalk74.default.cyan(
        `${getCommandName("project add <name>")}`
      )}`
    );
    if (args.length > 1) {
      const example = import_chalk74.default.cyan(
        `${getCommandName(`project add "${args.join(" ")}"`)}`
      );
      output_manager_default.log(
        `If your project name  has spaces, make sure to wrap it in quotes. Example: 
  ${example} `
      );
    }
    return 1;
  }
  const start = Date.now();
  const [name] = args;
  telemetryClient.trackCliArgumentName(name);
  try {
    await createProject(client, { name });
  } catch (err) {
    if (isAPIError(err) && err.code === "too_many_projects") {
      output_manager_default.prettyError(err);
      return 1;
    }
    if (isAPIError(err) && err.status === 409) {
    } else {
      throw err;
    }
  }
  const elapsed2 = (0, import_ms15.default)(Date.now() - start);
  const { contextName } = await getScope(client);
  output_manager_default.log(
    `${import_chalk74.default.cyan("Success!")} Project ${import_chalk74.default.bold(
      name.toLowerCase()
    )} added (${import_chalk74.default.bold(contextName)}) ${import_chalk74.default.gray(`[${elapsed2}]`)}`
  );
  return 0;
}

// src/commands/project/inspect.ts
var import_chalk75 = __toESM(require_source(), 1);
var import_frameworks = __toESM(require_frameworks(), 1);

// src/util/telemetry/commands/project/inspect.ts
var ProjectInspectTelemetryClient = class extends TelemetryClient {
  trackCliArgumentName(value) {
    if (value) {
      this.trackCliArgument({
        arg: "name",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
};

// src/util/projects/get-project-by-cwd-or-link.ts
async function getProjectByCwdOrLink({
  autoConfirm,
  client,
  commandName,
  cwd,
  projectNameOrId
}) {
  if (projectNameOrId) {
    const project = await getProjectByNameOrId(client, projectNameOrId);
    if (project instanceof ProjectNotFound) {
      throw project;
    }
    return project;
  }
  const linkedProject = await ensureLink(
    commandName,
    client,
    cwd ?? client.cwd,
    {
      autoConfirm
    }
  );
  if (typeof linkedProject === "number") {
    const err = new Error("Link project error");
    err.code = "ERR_LINK_PROJECT";
    throw err;
  }
  return linkedProject.project;
}

// src/commands/project/inspect.ts
async function inspect4(client, argv) {
  const telemetry2 = new ProjectInspectTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(inspectSubcommand3.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args } = parsedArgs;
  const name = args[0];
  telemetry2.trackCliArgumentName(name);
  telemetry2.trackCliFlagYes(parsedArgs.flags["--yes"]);
  if (args.length !== 0 && args.length !== 1) {
    output_manager_default.error(
      `Invalid number of arguments. Usage: ${import_chalk75.default.cyan(
        `${getCommandName("project inspect <name>")}`
      )}`
    );
    return 2;
  }
  const inspectStamp = stamp_default();
  const project = await getProjectByCwdOrLink({
    autoConfirm: parsedArgs.flags["--yes"],
    client,
    commandName: "project inspect",
    projectNameOrId: name
  });
  const org = await getTeamById(client, project.accountId);
  const projectSlugLink = formatProject(org.slug, project.name);
  output_manager_default.log(`Found Project ${projectSlugLink} ${import_chalk75.default.gray(inspectStamp())}`);
  output_manager_default.print("\n");
  output_manager_default.print(import_chalk75.default.bold("  General\n\n"));
  output_manager_default.print(`    ${import_chalk75.default.cyan("ID")}				${project.id}
`);
  output_manager_default.print(`    ${import_chalk75.default.cyan("Name")}			${project.name}
`);
  output_manager_default.print(`    ${import_chalk75.default.cyan("Owner")}			${org.name}
`);
  output_manager_default.print(
    `    ${import_chalk75.default.cyan("Created At")}			${formatDate(project.createdAt)}
`
  );
  output_manager_default.print(
    `    ${import_chalk75.default.cyan("Root Directory")}		${project.rootDirectory ?? "."}
`
  );
  output_manager_default.print(
    `    ${import_chalk75.default.cyan("Node.js Version")}		${project.nodeVersion}
`
  );
  const framework = import_frameworks.frameworkList.find((f) => f.slug === project.framework);
  output_manager_default.print("\n");
  output_manager_default.print(import_chalk75.default.bold("  Framework Settings\n\n"));
  output_manager_default.print(`    ${import_chalk75.default.cyan("Framework Preset")}		${framework?.name}
`);
  output_manager_default.print(
    `    ${import_chalk75.default.cyan("Build Command")}		${project.buildCommand ?? import_chalk75.default.dim(framework?.settings?.buildCommand.placeholder ?? "None")}
`
  );
  output_manager_default.print(
    `    ${import_chalk75.default.cyan("Output Directory")}		${project.outputDirectory ?? import_chalk75.default.dim(framework?.settings?.outputDirectory.placeholder ?? "None")}
`
  );
  output_manager_default.print(
    `    ${import_chalk75.default.cyan("Install Command")}		${project.installCommand ?? import_chalk75.default.dim(framework?.settings?.installCommand.placeholder ?? "None")}
`
  );
  output_manager_default.print("\n");
  return 0;
}

// src/commands/project/list.ts
var import_ms16 = __toESM(require_ms(), 1);
var import_chalk76 = __toESM(require_source(), 1);

// src/util/telemetry/commands/project/list.ts
var ProjectListTelemetryClient = class extends TelemetryClient {
  trackCliFlagUpdateRequired(updateRequired) {
    if (updateRequired) {
      this.trackCliFlag("update-required");
    }
  }
  trackCliOptionNext(next) {
    if (next) {
      this.trackCliOption({
        option: "next",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagJson(json) {
    if (json) {
      this.trackCliFlag("json");
    }
  }
};

// src/commands/project/list.ts
var TABLE_HEADERS = [
  "Project Name",
  "Latest Production URL",
  "Updated",
  "Node Version"
];
var PAGINATION_FLAGS_TO_EXCLUDE = [
  "_",
  "--next",
  "-N",
  "-d",
  "-y",
  "--json",
  "--format"
];
var BASE_PROJECTS_URL = "/v9/projects?limit=20";
async function list5(client, argv) {
  const telemetryClient = new ProjectListTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(listSubcommand8.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  if (args.length !== 0) {
    output_manager_default.error(
      `Invalid number of arguments. Usage: ${import_chalk76.default.cyan(
        `${getCommandName("project ls")}`
      )}`
    );
    return 2;
  }
  const start = Date.now();
  const { contextName } = await getScope(client);
  output_manager_default.spinner(`Fetching projects in ${import_chalk76.default.bold(contextName)}`);
  const flags = processFlags(opts, telemetryClient);
  if ("error" in flags) {
    output_manager_default.stopSpinner();
    output_manager_default.error(flags.error);
    return 1;
  }
  const projectsUrl = buildProjectsUrl(flags);
  const {
    projects: projectList,
    pagination
  } = await client.fetch(projectsUrl, {
    method: "GET"
  });
  output_manager_default.stopSpinner();
  const elapsed2 = (0, import_ms16.default)(Date.now() - start);
  if (flags.json) {
    outputJson2(client, projectList, {
      pagination,
      contextName,
      elapsed: elapsed2,
      deprecated: flags.deprecated
    });
  } else {
    outputTable(projectList, {
      contextName,
      elapsed: elapsed2,
      deprecated: flags.deprecated,
      opts,
      pagination
    });
  }
  return 0;
}
function processFlags(opts, telemetryClient) {
  const deprecated = opts["--update-required"] || false;
  const next = opts["--next"];
  const formatResult = validateJsonOutput(opts);
  if (!formatResult.valid) {
    return { error: formatResult.error };
  }
  const json = formatResult.jsonOutput;
  telemetryClient.trackCliFlagUpdateRequired(deprecated);
  telemetryClient.trackCliOptionNext(next);
  telemetryClient.trackCliOptionFormat(opts["--format"]);
  telemetryClient.trackCliFlagJson(opts["--json"]);
  return { deprecated, next, json };
}
function buildProjectsUrl(flags) {
  let url = BASE_PROJECTS_URL;
  if (flags.deprecated) {
    url += `&deprecated=${flags.deprecated}`;
  }
  if (flags.next) {
    url += `&until=${flags.next}`;
  }
  return url;
}
function createProjectJson(project, deprecated) {
  return {
    name: project.name,
    id: project.id,
    latestProductionUrl: getLatestProdUrl(project),
    updatedAt: project.updatedAt,
    nodeVersion: project.nodeVersion ?? null,
    deprecated
  };
}
function outputJson2(client, projectList, metadata) {
  const jsonOutput = {
    projects: projectList.map(
      (project) => createProjectJson(project, metadata.deprecated)
    ),
    pagination: metadata.pagination,
    contextName: metadata.contextName,
    elapsed: metadata.elapsed
  };
  client.stdout.write(`${JSON.stringify(jsonOutput, null, 2)}
`);
}
function outputTable(projectList, options) {
  const { contextName, elapsed: elapsed2, deprecated, opts, pagination } = options;
  output_manager_default.log(
    `${projectList.length > 0 ? "Projects" : "No projects"} found under ${import_chalk76.default.bold(contextName)} ${deprecated ? "that are using a deprecated Node.js version" : "\b"} ${import_chalk76.default.gray(`[${elapsed2}]`)}`
  );
  if (projectList.length > 0) {
    printProjectsTable(projectList);
    printPaginationInstructions(opts, pagination);
  }
}
function printProjectsTable(projectList) {
  const tablePrint = table(
    [
      TABLE_HEADERS.map((header) => import_chalk76.default.bold(import_chalk76.default.cyan(header))),
      ...projectList.flatMap((project) => [
        [
          import_chalk76.default.bold(project.name),
          getLatestProdUrl(project),
          import_chalk76.default.gray((0, import_ms16.default)(Date.now() - project.updatedAt)),
          project.nodeVersion ?? ""
        ]
      ])
    ],
    { hsep: 3 }
  ).replace(/^/gm, "  ");
  output_manager_default.print(`
${tablePrint}

`);
}
function printPaginationInstructions(opts, pagination) {
  if (pagination && pagination.count === 20) {
    const flags = getCommandFlags(opts, PAGINATION_FLAGS_TO_EXCLUDE);
    const nextCmd = `project ls${flags} --next ${pagination.next}`;
    output_manager_default.log(`To display the next page, run ${getCommandName(nextCmd)}`);
  }
}
function getLatestProdUrl(project) {
  const alias2 = project.targets?.production?.alias?.[0];
  if (alias2)
    return `https://${alias2}`;
  return "--";
}

// src/commands/project/rm.ts
var import_chalk77 = __toESM(require_source(), 1);
var import_ms17 = __toESM(require_ms(), 1);

// src/util/telemetry/commands/project/rm.ts
var ProjectRmTelemetryClient = class extends TelemetryClient {
  trackCliArgumentName(name) {
    if (name) {
      this.trackCliArgument({
        arg: "name",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/project/rm.ts
var e = encodeURIComponent;
async function rm6(client, argv) {
  const telemetryClient = new ProjectRmTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(removeSubcommand8.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args } = parsedArgs;
  if (args.length !== 1) {
    output_manager_default.error(
      `Invalid number of arguments. Usage: ${import_chalk77.default.cyan(
        `${getCommandName("project rm <name>")}`
      )}`
    );
    return 1;
  }
  const name = args[0];
  telemetryClient.trackCliArgumentName(name);
  const start = Date.now();
  const yes = await readConfirmation3(client, name);
  if (!yes) {
    output_manager_default.log("User abort");
    return 0;
  }
  try {
    await client.fetch(`/v2/projects/${e(name)}`, {
      method: "DELETE"
    });
  } catch (err) {
    if (isAPIError(err) && err.status === 404) {
      output_manager_default.error("No such project exists");
      return 1;
    }
    if (isAPIError(err) && err.status === 403) {
      output_manager_default.error(err.message);
      return 1;
    }
  }
  const elapsed2 = (0, import_ms17.default)(Date.now() - start);
  output_manager_default.log(
    `${import_chalk77.default.cyan("Success!")} Project ${import_chalk77.default.bold(name)} removed ${import_chalk77.default.gray(
      `[${elapsed2}]`
    )}`
  );
  return 0;
}
async function readConfirmation3(client, projectName) {
  output_manager_default.print(
    prependEmoji(
      `The project ${import_chalk77.default.bold(projectName)} will be removed permanently.
It will also delete everything under the project including deployments.
`,
      emoji("warning")
    )
  );
  return await client.input.confirm(
    `${import_chalk77.default.bold.red("Are you sure?")}`,
    false
  );
}

// src/util/telemetry/commands/project/index.ts
var ProjectTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandInspect(actual) {
    this.trackCliSubcommand({
      subcommand: "inspect",
      value: actual
    });
  }
  trackCliSubcommandList(actual) {
    this.trackCliSubcommand({
      subcommand: "list",
      value: actual
    });
  }
  trackCliSubcommandAdd(actual) {
    this.trackCliSubcommand({
      subcommand: "add",
      value: actual
    });
  }
  trackCliSubcommandRemove(actual) {
    this.trackCliSubcommand({
      subcommand: "remove",
      value: actual
    });
  }
};

// src/commands/project/index.ts
var COMMAND_CONFIG16 = {
  inspect: getCommandAliases(inspectSubcommand3),
  list: getCommandAliases(listSubcommand8),
  add: getCommandAliases(addSubcommand6),
  remove: getCommandAliases(removeSubcommand8)
};
async function main13(client) {
  const telemetry2 = new ProjectTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(projectCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification, {
      permissive: true
    });
  } catch (error) {
    printError(error);
    return 1;
  }
  let { subcommand, args, subcommandOriginal } = getSubcommand2(
    parsedArgs.args.slice(1),
    COMMAND_CONFIG16
  );
  const needHelp = parsedArgs.flags["--help"];
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp("project");
    output_manager_default.print(help(projectCommand, { columns: client.stderr.columns }));
    return 0;
  }
  function printHelp(command) {
    output_manager_default.print(
      help(command, { parent: projectCommand, columns: client.stderr.columns })
    );
    return 0;
  }
  if (!parsedArgs.args[1]) {
    subcommand = "list";
  }
  switch (subcommand) {
    case "inspect":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("project", subcommandOriginal);
        return printHelp(inspectSubcommand3);
      }
      telemetry2.trackCliSubcommandInspect(subcommandOriginal);
      return inspect4(client, args);
    case "list":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("project", subcommandOriginal);
        return printHelp(listSubcommand8);
      }
      telemetry2.trackCliSubcommandList(subcommandOriginal);
      return list5(client, args);
    case "add":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("project", subcommandOriginal);
        return printHelp(addSubcommand6);
      }
      telemetry2.trackCliSubcommandAdd(subcommandOriginal);
      return add6(client, args);
    case "remove":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("project", subcommandOriginal);
        return printHelp(removeSubcommand8);
      }
      telemetry2.trackCliSubcommandRemove(subcommandOriginal);
      return rm6(client, args);
    default:
      output_manager_default.error(getInvalidSubcommand(COMMAND_CONFIG16));
      output_manager_default.print(help(projectCommand, { columns: client.stderr.columns }));
      return 2;
  }
}

// src/commands/promote/index.ts
var import_ms20 = __toESM(require_ms(), 1);
var import_error_utils10 = __toESM(require_dist(), 1);

// src/commands/promote/request-promote.ts
var import_chalk81 = __toESM(require_source(), 1);

// src/util/projects/get-project-by-deployment.ts
var import_chalk78 = __toESM(require_source(), 1);
async function getProjectByDeployment({
  client,
  deployId
}) {
  const { config } = client;
  const { contextName } = await getScope(client);
  if (!isValidName(deployId)) {
    throw new Error(
      `The provided argument "${deployId}" is not a valid deployment ID or URL`
    );
  }
  let deployment;
  let team;
  try {
    output_manager_default?.spinner(
      `Fetching deployment "${deployId}" in ${import_chalk78.default.bold(contextName)}\u2026`
    );
    const [teamResult, deploymentResult] = await Promise.allSettled([
      config.currentTeam ? getTeamById(client, config.currentTeam) : void 0,
      getDeployment(client, contextName, deployId)
    ]);
    if (teamResult.status === "rejected") {
      throw new Error(
        `Failed to retrieve team information: ${teamResult.reason}`
      );
    }
    if (deploymentResult.status === "rejected") {
      throw new Error(deploymentResult.reason);
    }
    team = teamResult.value;
    deployment = deploymentResult.value;
    output_manager_default?.log(
      `Fetching deployment "${deployId}" in ${import_chalk78.default.bold(contextName)}\u2026`
    );
    if (deployment.team?.id) {
      if (!team || deployment.team.id !== team.id) {
        const err = new Error(
          team ? `Deployment doesn't belong to current team ${import_chalk78.default.bold(
            contextName
          )}` : `Deployment belongs to a different team`
        );
        err.code = "ERR_INVALID_TEAM";
        throw err;
      }
    } else if (team) {
      const err = new Error(
        `Deployment doesn't belong to current team ${import_chalk78.default.bold(contextName)}`
      );
      err.code = "ERR_INVALID_TEAM";
      throw err;
    }
    if (!deployment.projectId) {
      throw new Error("Deployment is not associated to a project");
    }
    const project = await getProjectByNameOrId(client, deployment.projectId);
    if (project instanceof ProjectNotFound) {
      throw project;
    }
    return {
      contextName,
      deployment,
      project
    };
  } finally {
    output_manager_default?.stopSpinner();
  }
}

// src/commands/promote/request-promote.ts
var import_ms19 = __toESM(require_ms(), 1);

// src/commands/promote/status.ts
var import_chalk80 = __toESM(require_source(), 1);
var import_ms18 = __toESM(require_ms(), 1);

// src/util/alias/render-alias-status.ts
var import_chalk79 = __toESM(require_source(), 1);
function renderAliasStatus(status3) {
  if (status3 === "completed") {
    return import_chalk79.default.green(status3);
  }
  if (status3 === "failed") {
    return import_chalk79.default.red(status3);
  }
  if (status3 === "skipped") {
    return import_chalk79.default.gray(status3);
  }
  return import_chalk79.default.yellow(status3);
}

// src/commands/rolling-release/request-rolling-release.ts
async function requestRollingRelease({
  client,
  projectId,
  teamId
}) {
  const { rollingRelease: rollingRelease2 } = await client.fetch(
    `/v1/projects/${projectId}/rolling-release?teamId=${teamId}`
  );
  return rollingRelease2;
}

// src/commands/promote/status.ts
async function promoteStatus({
  client,
  contextName,
  deployment,
  project,
  timeout = "3m"
}) {
  const recentThreshold = Date.now() - (0, import_ms18.default)("3m");
  const promoteTimeout = Date.now() + (0, import_ms18.default)(timeout);
  let counter = 0;
  let spinnerMessage = deployment ? "Promote in progress" : `Checking promotion status of ${project.name}`;
  if (!contextName) {
    ({ contextName } = await getScope(client));
  }
  try {
    output_manager_default.spinner(`${spinnerMessage}\u2026`);
    for (; ; ) {
      const projectCheck = await getProjectByNameOrId(
        client,
        project.id,
        project.accountId,
        true
      );
      if (projectCheck instanceof ProjectNotFound) {
        throw projectCheck;
      }
      if (projectCheck.rollingRelease) {
        output_manager_default.log(`Rolling Releases enabled \u2026`);
        const rr = await requestRollingRelease({
          client,
          projectId: project.id,
          teamId: project.accountId
        });
        if (rr.activeStage) {
          output_manager_default.stopSpinner();
          output_manager_default.log(
            `Rolling Release serving traffic at initial percentage ${rr.activeStage.targetPercentage}`
          );
          return 0;
        }
        continue;
      }
      const {
        jobStatus,
        requestedAt,
        toDeploymentId,
        type
      } = projectCheck.lastAliasRequest ?? {};
      if (!jobStatus || jobStatus !== "in-progress" && jobStatus !== "pending") {
        output_manager_default.stopSpinner();
        output_manager_default.log(`${spinnerMessage}\u2026`);
      }
      if (!jobStatus || !requestedAt || !toDeploymentId || requestedAt < recentThreshold) {
        output_manager_default.log("No deployment promotion in progress");
        return 0;
      }
      if (jobStatus === "skipped" && type === "promote") {
        output_manager_default.log("Promote deployment was skipped");
        return 0;
      }
      if (jobStatus === "succeeded") {
        return await renderJobSucceeded({
          client,
          contextName,
          performingPromote: !!deployment,
          requestedAt,
          project,
          toDeploymentId
        });
      }
      if (jobStatus === "failed") {
        return await renderJobFailed({
          client,
          contextName,
          deployment,
          project,
          toDeploymentId
        });
      }
      if (jobStatus !== "pending" && jobStatus !== "in-progress") {
        output_manager_default.log(`Unknown promote deployment status "${jobStatus}"`);
        return 1;
      }
      if (requestedAt < recentThreshold || Date.now() >= promoteTimeout) {
        output_manager_default.log(
          `The promotion exceeded its deadline - rerun ${import_chalk80.default.bold(
            `${packageName} promote ${toDeploymentId}`
          )} to try again`
        );
        return 1;
      }
      if (counter++ === 0 && !deployment) {
        spinnerMessage += ` requested at ${formatDate(requestedAt)}`;
      }
      output_manager_default.spinner(`${spinnerMessage}\u2026`);
      await sleep(250);
    }
  } finally {
    output_manager_default.stopSpinner();
  }
}
async function renderJobFailed({
  client,
  contextName,
  deployment,
  project,
  toDeploymentId
}) {
  try {
    const name = (deployment || await getDeployment(client, contextName, toDeploymentId))?.url;
    output_manager_default.error(
      `Failed to remap all aliases to the requested deployment ${name} (${toDeploymentId})`
    );
  } catch (e2) {
    output_manager_default.error(
      `Failed to remap all aliases to the requested deployment ${toDeploymentId}`
    );
  }
  let nextTimestamp;
  for (; ; ) {
    let url = `/v9/projects/${project.id}/promote/aliases?failedOnly=true&limit=20`;
    if (nextTimestamp) {
      url += `&until=${nextTimestamp}`;
    }
    const { aliases, pagination } = await client.fetch(url);
    for (const { alias: alias2, status: status3 } of aliases) {
      output_manager_default.log(
        `  ${renderAliasStatus(status3).padEnd(11)}  ${alias2.alias} (${alias2.deploymentId})`
      );
    }
    if (pagination?.next) {
      nextTimestamp = pagination.next;
    } else {
      break;
    }
  }
  return 1;
}
async function renderJobSucceeded({
  client,
  contextName,
  performingPromote,
  project,
  requestedAt,
  toDeploymentId
}) {
  let deploymentInfo = "";
  try {
    const deployment = await getDeployment(client, contextName, toDeploymentId);
    deploymentInfo = `${import_chalk80.default.bold(deployment.url)} (${toDeploymentId})`;
  } catch (err) {
    output_manager_default.debug(
      `Failed to get deployment url for ${toDeploymentId}: ${err?.toString() || err}`
    );
    deploymentInfo = import_chalk80.default.bold(toDeploymentId);
  }
  const duration = performingPromote ? elapsed(Date.now() - requestedAt) : "";
  output_manager_default.log(
    `Success! ${import_chalk80.default.bold(
      project.name
    )} was promoted to ${deploymentInfo} ${duration}`
  );
  return 0;
}

// src/commands/promote/request-promote.ts
async function requestPromote({
  client,
  deployId,
  timeout,
  yes
}) {
  const { contextName, deployment, project } = await getProjectByDeployment({
    client,
    deployId
  });
  let promoteByCreation = false;
  if (deployment.target !== "production") {
    if (yes) {
      promoteByCreation = true;
    } else {
      const question = "This deployment is not a production deployment and cannot be directly promoted. A new deployment will be built using your production environment. Are you sure you want to continue?";
      promoteByCreation = await client.input.confirm(question, false);
      if (!promoteByCreation) {
        output_manager_default.error("Canceled");
        return 0;
      }
    }
  }
  if (promoteByCreation) {
    const newDeployment = await client.fetch(
      `/v13/deployments?teamId=${deployment.ownerId}`,
      {
        body: {
          deploymentId: deployment.id,
          name: project.name,
          target: "production",
          meta: {
            action: "promote"
          }
        },
        accountId: deployment.ownerId,
        method: "POST"
      }
    );
    output_manager_default.log(
      `Successfully created new deployment of ${import_chalk81.default.bold(project.name)} at ${newDeployment.inspectorUrl}`
    );
    return 0;
  }
  const res = await client.fetch(
    `/v10/projects/${project.id}/promote/${deployment.id}`,
    {
      body: {},
      // required
      json: false,
      method: "POST"
    }
  );
  if (res.status === 202) {
    output_manager_default.log(
      "Promotion has been queued and will begin when the active rolling release completes successfully."
    );
    return 0;
  }
  if (timeout !== void 0 && (0, import_ms19.default)(timeout) === 0) {
    output_manager_default.log(
      `Successfully requested promote of ${import_chalk81.default.bold(project.name)} to ${deployment.url} (${deployment.id})`
    );
    output_manager_default.log(`To check promote status, run ${getCommandName("promote")}.`);
    return 0;
  }
  return await promoteStatus({
    client,
    contextName,
    deployment,
    project,
    timeout
  });
}

// src/util/telemetry/commands/promote/index.ts
var PromoteTelemetryClient = class extends TelemetryClient {
  trackCliArgumentUrlOrDeploymentId(value) {
    if (value) {
      this.trackCliArgument({
        arg: "urlOrDeploymentId",
        value: this.redactedValue
      });
    }
  }
  trackCliSubcommandStatus() {
    this.trackCliSubcommand({
      subcommand: "status",
      value: "status"
    });
  }
  trackCliOptionTimeout(time) {
    if (time) {
      this.trackCliOption({
        option: "timeout",
        value: "[TIME]"
      });
    }
  }
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
};

// src/commands/promote/index.ts
var promote_default = async (client) => {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(promoteCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const telemetry2 = new PromoteTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const needHelp = parsedArgs.flags["--help"];
  if (!parsedArgs.args[1] && needHelp) {
    telemetry2.trackCliFlagHelp("promote");
    output_manager_default.print(help(promoteCommand, { columns: client.stderr.columns }));
    return 2;
  }
  const yes = parsedArgs.flags["--yes"] ?? false;
  telemetry2.trackCliFlagYes(parsedArgs.flags["--yes"]);
  const timeout = parsedArgs.flags["--timeout"];
  if (timeout && (0, import_ms20.default)(timeout) === void 0) {
    output_manager_default.error(`Invalid timeout "${timeout}"`);
    return 1;
  }
  telemetry2.trackCliOptionTimeout(parsedArgs.flags["--timeout"]);
  const actionOrDeployId = parsedArgs.args[1] || "status";
  try {
    if (actionOrDeployId === "status") {
      if (needHelp) {
        telemetry2.trackCliFlagHelp("promote", "status");
        output_manager_default.print(
          help(statusSubcommand2, {
            columns: client.stderr.columns,
            parent: promoteCommand
          })
        );
        return 2;
      }
      telemetry2.trackCliSubcommandStatus();
      const project = await getProjectByCwdOrLink({
        autoConfirm: parsedArgs.flags["--yes"],
        client,
        commandName: "promote",
        projectNameOrId: parsedArgs.args[2]
      });
      return await promoteStatus({
        client,
        project,
        timeout
      });
    }
    telemetry2.trackCliArgumentUrlOrDeploymentId(actionOrDeployId);
    return await requestPromote({
      client,
      deployId: actionOrDeployId,
      timeout,
      yes
    });
  } catch (err) {
    if ((0, import_error_utils10.isErrnoException)(err)) {
      if (err.code === "ERR_CANCELED") {
        return 0;
      }
      if (err.code === "ERR_INVALID_CWD" || err.code === "ERR_LINK_PROJECT") {
        return 1;
      }
    }
    output_manager_default.prettyError(err);
    return 1;
  }
};

// src/commands/redeploy/index.ts
var import_chalk83 = __toESM(require_source(), 1);
var import_client = __toESM(require_dist2(), 1);

// src/util/deploy/get-deployment-by-id-or-url.ts
var import_chalk82 = __toESM(require_source(), 1);
async function getDeploymentByIdOrURL({
  client,
  contextName,
  deployIdOrUrl
}) {
  const { config } = client;
  if (!isValidName(deployIdOrUrl)) {
    throw new Error(
      `The provided argument "${deployIdOrUrl}" is not a valid deployment ID or URL`
    );
  }
  let deployment;
  let team;
  try {
    output_manager_default.spinner(
      `Fetching deployment "${deployIdOrUrl}" in ${import_chalk82.default.bold(contextName)}\u2026`
    );
    const [teamResult, deploymentResult] = await Promise.allSettled([
      config.currentTeam ? getTeamById(client, config.currentTeam) : void 0,
      getDeployment(client, contextName, deployIdOrUrl)
    ]);
    if (teamResult.status === "rejected") {
      throw new Error(
        `Failed to retrieve team information: ${teamResult.reason}`
      );
    }
    if (deploymentResult.status === "rejected") {
      throw new Error(deploymentResult.reason.message);
    }
    team = teamResult.value;
    deployment = deploymentResult.value;
    output_manager_default.log(
      `Fetching deployment "${deployIdOrUrl}" in ${import_chalk82.default.bold(contextName)}\u2026`
    );
  } finally {
    output_manager_default.stopSpinner();
  }
  if (deployment.team?.id) {
    if (!team || deployment.team.id !== team.id) {
      const err = new Error(
        team ? `Deployment doesn't belong to current team ${import_chalk82.default.bold(
          contextName
        )}` : `Deployment belongs to a different team`
      );
      err.code = "ERR_INVALID_TEAM";
      throw err;
    }
  } else if (team) {
    const err = new Error(
      `Deployment doesn't belong to current team ${import_chalk82.default.bold(contextName)}`
    );
    err.code = "ERR_INVALID_TEAM";
    throw err;
  }
  return deployment;
}

// src/commands/redeploy/index.ts
var import_error_utils11 = __toESM(require_dist(), 1);

// src/util/telemetry/commands/redeploy/index.ts
var RedeployTelemetryClient = class extends TelemetryClient {
  trackCliArgumentUrlOrDeploymentId(value) {
    if (value) {
      this.trackCliArgument({
        arg: "urlOrDeploymentId",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagNoWait(noWait) {
    if (noWait) {
      this.trackCliFlag("no-wait");
    }
  }
  trackCliOptionTarget(target) {
    if (target) {
      this.trackCliArgument({
        arg: "target",
        value: this.redactedTargetName(target)
      });
    }
  }
};

// src/commands/redeploy/index.ts
async function redeploy(client) {
  let parsedArgs = null;
  const flagsSpecification = getFlagsSpecification(redeployCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const telemetry2 = new RedeployTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  if (parsedArgs.flags["--help"]) {
    telemetry2.trackCliFlagHelp("redeploy");
    output_manager_default.print(help(redeployCommand, { columns: client.stderr.columns }));
    return 2;
  }
  const deployIdOrUrl = parsedArgs.args[1];
  if (!deployIdOrUrl) {
    output_manager_default.error(
      `Missing required deployment id or url: ${getCommandName(
        `redeploy <deployment-id-or-url>`
      )}`
    );
    return 1;
  }
  telemetry2.trackCliArgumentUrlOrDeploymentId(deployIdOrUrl);
  telemetry2.trackCliFlagNoWait(parsedArgs.flags["--no-wait"]);
  telemetry2.trackCliOptionTarget(parsedArgs.flags["--target"]);
  const { contextName } = await getScope(client);
  const noWait = !!parsedArgs.flags["--no-wait"];
  const targetArgument = parsedArgs.flags["--target"];
  try {
    const fromDeployment = await getDeploymentByIdOrURL({
      client,
      contextName,
      deployIdOrUrl
    });
    let target;
    let customEnvironmentSlugOrId;
    if (!targetArgument) {
      target = fromDeployment.target ?? void 0;
      customEnvironmentSlugOrId = fromDeployment.customEnvironment?.id;
    } else if (targetArgument === "staging" || targetArgument === "production") {
      target = targetArgument;
    } else if (targetArgument === "preview") {
      target = void 0;
    } else if (targetArgument) {
      customEnvironmentSlugOrId = targetArgument;
      target = void 0;
    } else {
      target = fromDeployment.target;
    }
    let customEnvironment;
    if (fromDeployment?.projectId && customEnvironmentSlugOrId) {
      const customEnvironments = await getCustomEnvironments(
        client,
        fromDeployment.projectId
      );
      customEnvironment = pickCustomEnvironment(
        customEnvironments,
        customEnvironmentSlugOrId
      );
    }
    if (customEnvironmentSlugOrId && !customEnvironment) {
      output_manager_default.error(
        `The provided argument "${targetArgument}" is not a valid target environment.`
      );
      return 1;
    }
    const deployStamp = stamp_default();
    output_manager_default.spinner(`Redeploying project ${fromDeployment.id}`, 0);
    let deployment = await client.fetch(`/v13/deployments?forceNew=1`, {
      body: {
        deploymentId: fromDeployment.id,
        meta: {
          action: "redeploy"
        },
        name: fromDeployment.name,
        target,
        customEnvironmentSlugOrId
      },
      method: "POST"
    });
    output_manager_default.stopSpinner();
    const previewUrl = `https://${deployment.url}`;
    let isProdDeployment = target === "production";
    if (customEnvironmentSlugOrId && customEnvironment) {
      isProdDeployment = customEnvironment.type === "production";
    }
    output_manager_default.print(
      `${prependEmoji(
        `Inspect: ${import_chalk83.default.bold(deployment.inspectorUrl)} ${deployStamp()}`,
        emoji("inspect")
      )}
`
    );
    output_manager_default.print(
      prependEmoji(
        `${isProdDeployment ? "Production" : "Preview"}: ${import_chalk83.default.bold(
          previewUrl
        )} ${deployStamp()}`,
        emoji("success")
      ) + `
`
    );
    if (!client.stdout.isTTY) {
      client.stdout.write(`https://${deployment.url}`);
    }
    if (!noWait) {
      output_manager_default.spinner(
        deployment.readyState === "QUEUED" ? "Queued" : "Building",
        0
      );
      let project;
      let rollingRelease2;
      if (deployment.projectId && deployment.projectId != "") {
        project = await getProjectByNameOrId(client, deployment.projectId);
        rollingRelease2 = project?.rollingRelease;
      }
      if (deployment.readyState === "READY" && deployment.aliasAssigned && !rollingRelease2) {
        output_manager_default.spinner("Completing", 0);
      } else {
        try {
          const clientOptions = {
            agent: client.agent,
            apiUrl: client.apiUrl,
            debug: output_manager_default.debugEnabled,
            path: "",
            // unused by checkDeploymentStatus()
            teamId: fromDeployment.team?.id,
            token: client.authConfig.token,
            userAgent: ua_default
          };
          for await (const event of (0, import_client.checkDeploymentStatus)(
            deployment,
            clientOptions
          )) {
            if (event.type === "building") {
              output_manager_default.spinner("Building", 0);
            } else if (event.type === "ready" && rollingRelease2) {
              output_manager_default.spinner("Releasing", 0);
              output_manager_default.stopSpinner();
              deployment = event.payload;
              break;
            } else if (event.type === "ready" && (event.payload.checksState ? event.payload.checksState === "completed" : true)) {
              output_manager_default.spinner("Completing", 0);
            } else if (event.type === "checks-running") {
              output_manager_default.spinner("Running Checks", 0);
            } else if (event.type === "alias-assigned" || event.type === "checks-conclusion-failed") {
              output_manager_default.stopSpinner();
              if (event.type === "alias-assigned" && !Array.isArray(event.payload) && event.payload.target === "production" && event.payload.alias && event.payload.alias.length > 0) {
                const primaryDomain = event.payload.alias[0];
                const prodUrl = `https://${primaryDomain}`;
                output_manager_default.print(
                  prependEmoji(
                    `Aliased: ${import_chalk83.default.bold(prodUrl)} ${deployStamp()}`,
                    emoji("link")
                  ) + "\n"
                );
              }
              deployment = event.payload;
              break;
            } else if (event.type === "canceled") {
              output_manager_default.stopSpinner();
              output_manager_default.print("The deployment has been canceled.\n");
              return 1;
            } else if (event.type === "error") {
              output_manager_default.stopSpinner();
              const now = new Now({
                client,
                currentTeam: fromDeployment.team?.id
              });
              const error = await now.handleDeploymentError(event.payload, {
                env: {}
              });
              throw error;
            }
          }
        } catch (err) {
          output_manager_default.prettyError(err);
          process.exit(1);
        }
      }
    }
    return printDeploymentStatus(deployment, deployStamp, noWait, false);
  } catch (err) {
    output_manager_default.prettyError(err);
    if ((0, import_error_utils11.isErrnoException)(err) && err.code === "ERR_INVALID_TEAM") {
      output_manager_default.error(
        `Use ${import_chalk83.default.bold("vc switch")} to change your current team`
      );
    }
    return 1;
  }
}

// src/commands/redirects/list.ts
var import_chalk84 = __toESM(require_source(), 1);
var import_pluralize9 = __toESM(require_pluralize(), 1);

// src/commands/redirects/shared.ts
async function parseSubcommandArgs(argv, command) {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(command.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  return parsedArgs;
}
function validateRequiredArgs(args, required) {
  for (let i = 0; i < required.length; i++) {
    if (!args[i]) {
      return `Missing required argument: ${required[i]}`;
    }
  }
  return null;
}
async function ensureProjectLink(client) {
  const link = await getLinkedProject(client);
  if (link.status === "error") {
    return link.exitCode;
  } else if (link.status === "not_linked") {
    output_manager_default.error(
      `Your codebase isn't linked to a project on Vercel. Run ${getCommandName("link")} to begin.`
    );
    return 1;
  }
  client.config.currentTeam = link.org.type === "team" ? link.org.id : void 0;
  return link;
}
async function confirmAction(client, skipConfirmation, message, details) {
  if (skipConfirmation)
    return true;
  if (details) {
    output_manager_default.print(`  ${details}
`);
  }
  return await client.input.confirm(message, false);
}
function isValidUrl(url) {
  if (url.startsWith("/")) {
    return true;
  }
  try {
    const parsed = new URL(url);
    return parsed.protocol === "http:" || parsed.protocol === "https:";
  } catch {
    return false;
  }
}

// src/util/redirects/get-redirects.ts
async function getRedirects(client, projectId, options = {}) {
  const { teamId, search, page, perPage = 50, versionId, diff } = options;
  const params = new URLSearchParams();
  params.set("projectId", projectId);
  if (teamId) {
    params.set("teamId", teamId);
  }
  if (versionId) {
    params.set("versionId", versionId);
  }
  if (diff) {
    params.set("diff", diff === true ? "true" : diff);
  } else {
    params.set("per_page", perPage.toString());
    if (search) {
      params.set("q", search);
    }
    if (page) {
      params.set("page", page.toString());
    }
  }
  const url = `/v1/bulk-redirects?${params}`;
  return await client.fetch(url);
}

// src/util/redirects/get-redirect-versions.ts
async function getRedirectVersions(client, projectId, teamId) {
  const params = new URLSearchParams();
  params.set("projectId", projectId);
  if (teamId) {
    params.set("teamId", teamId);
  }
  const url = `/v1/bulk-redirects/versions?${params}`;
  return await client.fetch(url);
}

// src/commands/redirects/list.ts
async function list6(client, argv) {
  const parsed = await parseSubcommandArgs(argv, listSubcommand9);
  if (typeof parsed === "number")
    return parsed;
  const link = await ensureProjectLink(client);
  if (typeof link === "number")
    return link;
  const { project, org } = link;
  const { flags } = parsed;
  const teamId = org.type === "team" ? org.id : void 0;
  const search = flags["--search"];
  const page = flags["--page"];
  const perPage = flags["--per-page"];
  const staging = flags["--staging"];
  const versionIdFlag = flags["--version"];
  let versionId;
  let versionName;
  let useDiff = false;
  if (staging) {
    output_manager_default.spinner("Fetching staging version");
    const { versions } = await getRedirectVersions(client, project.id, teamId);
    const stagingVersion = versions.find((v) => v.isStaging);
    if (!stagingVersion) {
      output_manager_default.error(
        `No staging version found for ${import_chalk84.default.bold(project.name)}. Run ${import_chalk84.default.cyan(
          "vercel redirects list-versions"
        )} to see available versions.`
      );
      return 1;
    }
    versionId = stagingVersion.id;
    versionName = stagingVersion.name || stagingVersion.id;
    if (!search && !page) {
      useDiff = true;
    }
  }
  if (versionIdFlag) {
    if (staging) {
      output_manager_default.error("Cannot use both --staging and --version flags together");
      return 1;
    }
    output_manager_default.spinner("Fetching version");
    const { versions } = await getRedirectVersions(client, project.id, teamId);
    const version = versions.find(
      (v) => v.id === versionIdFlag || v.name === versionIdFlag
    );
    if (!version) {
      output_manager_default.error(
        `Version "${versionIdFlag}" not found. Run ${import_chalk84.default.cyan(
          "vercel redirects list-versions"
        )} to see available versions.`
      );
      return 1;
    }
    versionId = version.id;
    versionName = version.name || version.id;
  }
  const lsStamp = stamp_default();
  let spinnerMessage = `Fetching redirects for ${import_chalk84.default.bold(project.name)}`;
  if (versionName) {
    spinnerMessage += ` (version: ${versionName})`;
  }
  if (search) {
    spinnerMessage += ` matching "${search}"`;
  }
  output_manager_default.spinner(spinnerMessage);
  const { redirects, pagination } = await getRedirects(client, project.id, {
    teamId,
    search,
    page,
    perPage,
    versionId,
    diff: useDiff
  });
  if (useDiff) {
    const added = redirects.filter((r) => r.action === "+");
    const removed = redirects.filter((r) => r.action === "-");
    const unchanged = redirects.filter((r) => !r.action);
    output_manager_default.log(
      `Changes in staging version ${import_chalk84.default.bold(versionName || "")} ${import_chalk84.default.gray(lsStamp())}`
    );
    if (added.length === 0 && removed.length === 0) {
      output_manager_default.log("\n  No changes from production version\n");
    } else {
      if (added.length > 0) {
        output_manager_default.print(`
  ${import_chalk84.default.bold(import_chalk84.default.green(`Added (${added.length}):`))}
`);
        output_manager_default.print(formatRedirectsTable(added, "+"));
      }
      if (removed.length > 0) {
        output_manager_default.print(`
  ${import_chalk84.default.bold(import_chalk84.default.red(`Removed (${removed.length}):`))}
`);
        output_manager_default.print(formatRedirectsTable(removed, "-"));
      }
      if (unchanged.length > 0) {
        output_manager_default.print(
          `
  ${import_chalk84.default.gray(`${unchanged.length} redirect${unchanged.length === 1 ? "" : "s"} unchanged`)}
`
        );
      }
      output_manager_default.print("\n");
    }
  } else {
    let resultMessage = `${(0, import_pluralize9.default)("Redirect", redirects.length, true)} found for ${import_chalk84.default.bold(
      project.name
    )}`;
    if (versionName) {
      resultMessage += ` ${import_chalk84.default.gray(`(version: ${versionName})`)}`;
    }
    if (search) {
      resultMessage += ` matching "${search}"`;
    }
    if (pagination) {
      resultMessage += ` ${import_chalk84.default.gray(`(page ${pagination.page} of ${pagination.numPages})`)}`;
    }
    resultMessage += ` ${import_chalk84.default.gray(lsStamp())}`;
    output_manager_default.log(resultMessage);
    if (redirects.length > 0) {
      output_manager_default.print(formatRedirectsTable(redirects));
      output_manager_default.print("\n");
    }
  }
  if (pagination && pagination.page < pagination.numPages) {
    const nextPage = pagination.page + 1;
    let command = `redirects list --page ${nextPage}`;
    if (search) {
      command += ` --search "${search}"`;
    }
    if (perPage) {
      command += ` --per-page ${perPage}`;
    }
    output_manager_default.log(`To display the next page, run ${getCommandName(command)}`);
  }
  return 0;
}
function formatRedirectsTable(redirects, actionSymbol) {
  const rows = redirects.map((redirect) => {
    const status3 = redirect.statusCode || (redirect.permanent ? 308 : 307);
    const prefix = actionSymbol || "";
    const colorFn = actionSymbol === "+" ? import_chalk84.default.green : actionSymbol === "-" ? import_chalk84.default.red : (s) => s;
    return [
      colorFn(`${prefix} ${redirect.source}`),
      colorFn(`${redirect.destination}`),
      colorFn(status3.toString())
    ];
  });
  return formatTable(
    ["Source", "Destination", "Status"],
    ["l", "l", "l"],
    [{ rows }]
  );
}

// src/commands/redirects/list-versions.ts
var import_chalk85 = __toESM(require_source(), 1);
var import_ms21 = __toESM(require_ms(), 1);
var import_pluralize10 = __toESM(require_pluralize(), 1);
async function listVersions(client, argv) {
  const parsed = await parseSubcommandArgs(argv, listVersionsSubcommand);
  if (typeof parsed === "number")
    return parsed;
  const link = await ensureProjectLink(client);
  if (typeof link === "number")
    return link;
  const { project, org } = link;
  const teamId = org.type === "team" ? org.id : void 0;
  const lsStamp = stamp_default();
  output_manager_default.spinner(`Fetching redirect versions for ${import_chalk85.default.bold(project.name)}`);
  const { versions } = await getRedirectVersions(client, project.id, teamId);
  const sortedVersions = sortVersions(versions).slice(0, 20);
  output_manager_default.log(
    `${(0, import_pluralize10.default)("Version", sortedVersions.length, true)} found for ${import_chalk85.default.bold(
      project.name
    )} ${import_chalk85.default.gray(lsStamp())}`
  );
  if (sortedVersions.length > 0) {
    output_manager_default.print(formatVersionsTable(sortedVersions));
    output_manager_default.print("\n");
  }
  return 0;
}
function sortVersions(versions) {
  return versions.slice().sort((a, b) => {
    if (a.isStaging && !b.isStaging)
      return -1;
    if (!a.isStaging && b.isStaging)
      return 1;
    if (a.isLive && !b.isLive)
      return -1;
    if (!a.isLive && b.isLive)
      return 1;
    return b.lastModified - a.lastModified;
  });
}
function formatVersionsTable(versions) {
  const now = Date.now();
  const rows = versions.map((version) => {
    const age = (0, import_ms21.default)(now - version.lastModified);
    let status3 = "";
    if (version.isStaging) {
      status3 = import_chalk85.default.yellow("Staging");
    } else if (version.isLive) {
      status3 = import_chalk85.default.green("Live");
    } else {
      status3 = import_chalk85.default.gray("Previous");
    }
    const name = version.name || import_chalk85.default.gray("(unnamed)");
    const redirectCountStr = version.redirectCount !== void 0 && version.redirectCount !== null ? version.redirectCount.toString() : import_chalk85.default.gray("-");
    return [
      status3,
      name,
      version.id,
      redirectCountStr,
      version.createdBy || import_chalk85.default.gray("(unknown)"),
      import_chalk85.default.gray(age + " ago")
    ];
  });
  return formatTable(
    ["Status", "Name", "ID", "Redirects", "Created By", "Age"],
    ["l", "l", "l", "r", "l", "l"],
    [{ rows }]
  );
}

// src/commands/redirects/add.ts
var import_chalk86 = __toESM(require_source(), 1);

// src/util/redirects/put-redirects.ts
async function putRedirects(client, projectId, redirects, teamId, name) {
  const url = `/v1/bulk-redirects`;
  const body = {
    projectId,
    redirects
  };
  if (teamId) {
    body.teamId = teamId;
  }
  if (name) {
    body.name = name;
  }
  return await client.fetch(url, {
    method: "PUT",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(body)
  });
}

// src/util/redirects/update-redirect-version.ts
async function updateRedirectVersion(client, projectId, versionId, action, teamId) {
  const params = new URLSearchParams();
  params.set("projectId", projectId);
  if (teamId) {
    params.set("teamId", teamId);
  }
  const url = `/v1/bulk-redirects/versions?${params}`;
  return await client.fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      id: versionId,
      action
    })
  });
}

// src/commands/redirects/add.ts
async function add7(client, argv) {
  const parsed = await parseSubcommandArgs(argv, addSubcommand7);
  if (typeof parsed === "number")
    return parsed;
  const link = await ensureProjectLink(client);
  if (typeof link === "number")
    return link;
  const { project, org } = link;
  const teamId = org.type === "team" ? org.id : void 0;
  const { versions } = await getRedirectVersions(client, project.id, teamId);
  const existingStagingVersion = versions.find((v) => v.isStaging);
  const { args, flags } = parsed;
  const skipPrompts = flags["--yes"];
  let source;
  if (args[0]) {
    source = args[0];
    if (!isValidUrl(source)) {
      output_manager_default.error(
        "Source must be a relative path (starting with /) or an absolute URL"
      );
      return 1;
    }
  } else {
    if (skipPrompts) {
      output_manager_default.error(
        "Source and destination are required when using --yes. Use: vercel redirects add <source> <destination> --yes"
      );
      return 1;
    }
    output_manager_default.log("Add a new redirect\n");
    source = await client.input.text({
      message: "What is the source URL?",
      validate: (val) => {
        if (!val) {
          return "Source URL cannot be empty";
        }
        if (!isValidUrl(val)) {
          return "Must be a relative path (starting with /) or an absolute URL";
        }
        return true;
      }
    });
  }
  let destination;
  if (args[1]) {
    destination = args[1];
    if (!isValidUrl(destination)) {
      output_manager_default.error(
        "Destination must be a relative path (starting with /) or an absolute URL"
      );
      return 1;
    }
  } else {
    if (skipPrompts) {
      output_manager_default.error(
        "Source and destination are required when using --yes. Use: vercel redirects add <source> <destination> --yes"
      );
      return 1;
    }
    if (!args[0]) {
      output_manager_default.log("Add a new redirect\n");
    }
    destination = await client.input.text({
      message: "What is the destination URL?",
      validate: (val) => {
        if (!val) {
          return "Destination URL cannot be empty";
        }
        if (!isValidUrl(val)) {
          return "Must be a relative path (starting with /) or an absolute URL";
        }
        return true;
      }
    });
  }
  let statusCode;
  if (flags["--status"]) {
    statusCode = flags["--status"];
    if (![301, 302, 307, 308].includes(statusCode)) {
      output_manager_default.error("Status code must be 301, 302, 307, or 308");
      return 1;
    }
  } else if (skipPrompts) {
    statusCode = 307;
  } else {
    statusCode = await client.input.select({
      message: "Select the status code:",
      choices: [
        {
          name: "307 - Temporary Redirect (preserves request method)",
          value: 307
        },
        {
          name: "308 - Permanent Redirect (preserves request method)",
          value: 308
        },
        {
          name: "301 - Moved Permanently (cached by browsers)",
          value: 301
        },
        {
          name: "302 - Found (temporary redirect, not cached)",
          value: 302
        }
      ]
    });
  }
  let caseSensitive;
  if (flags["--case-sensitive"] !== void 0) {
    caseSensitive = flags["--case-sensitive"];
  } else if (skipPrompts) {
    caseSensitive = false;
  } else {
    caseSensitive = await client.input.confirm(
      "Should the redirect be case sensitive?",
      false
    );
  }
  let preserveQueryParams;
  if (flags["--preserve-query-params"] !== void 0) {
    preserveQueryParams = flags["--preserve-query-params"];
  } else if (skipPrompts) {
    preserveQueryParams = false;
  } else {
    preserveQueryParams = await client.input.confirm(
      "Should query parameters be preserved?",
      false
    );
  }
  let versionName;
  if (flags["--name"]) {
    versionName = flags["--name"];
    if (versionName && versionName.length > 256) {
      output_manager_default.error("Name must be 256 characters or less");
      return 1;
    }
  } else if (skipPrompts) {
    versionName = void 0;
  } else {
    const provideName = await client.input.confirm(
      "Do you want to provide a name for this version?",
      false
    );
    if (provideName) {
      versionName = await client.input.text({
        message: "Version name (max 256 characters):",
        validate: (val) => {
          if (val && val.length > 256) {
            return "Name must be 256 characters or less";
          }
          return true;
        }
      });
      if (!versionName) {
        versionName = void 0;
      }
    }
  }
  const addStamp = stamp_default();
  output_manager_default.spinner("Adding redirect");
  const { alias: alias2, version } = await putRedirects(
    client,
    project.id,
    [
      {
        source,
        destination,
        statusCode,
        caseSensitive,
        preserveQueryParams
      }
    ],
    teamId,
    versionName
  );
  output_manager_default.log(`${import_chalk86.default.cyan("\u2713")} Redirect added ${import_chalk86.default.gray(addStamp())}`);
  output_manager_default.print(`
  ${import_chalk86.default.bold("Redirect:")}
`);
  output_manager_default.print(`    ${import_chalk86.default.cyan(source)} \u2192 ${import_chalk86.default.cyan(destination)}
`);
  output_manager_default.print(`    Status: ${statusCode}
`);
  output_manager_default.print(`    Case sensitive: ${caseSensitive ? "Yes" : "No"}
`);
  output_manager_default.print(
    `    Preserve query params: ${preserveQueryParams ? "Yes" : "No"}
`
  );
  if (alias2) {
    const testUrl = source.startsWith("/") ? `https://${alias2}${source}` : `https://${alias2}`;
    output_manager_default.print(
      `
  ${import_chalk86.default.bold("Test your changes:")} ${import_chalk86.default.cyan(testUrl)}
`
    );
  }
  const newVersionName = version.name || version.id;
  output_manager_default.print(`  ${import_chalk86.default.bold("New staging version:")} ${newVersionName}

`);
  if (!existingStagingVersion) {
    const shouldPromote = await client.input.confirm(
      "This is the only staged change. Do you want to promote it to production now?",
      false
    );
    if (shouldPromote) {
      const promoteStamp = stamp_default();
      output_manager_default.spinner("Promoting to production");
      await updateRedirectVersion(
        client,
        project.id,
        version.id,
        "promote",
        teamId
      );
      output_manager_default.log(
        `${import_chalk86.default.cyan("\u2713")} Version promoted to production ${import_chalk86.default.gray(promoteStamp())}`
      );
    }
  } else {
    output_manager_default.warn(
      `There are other staged changes. Please review all changes with ${import_chalk86.default.cyan("vercel redirects list --staging")} before promoting to production.`
    );
  }
  return 0;
}

// src/commands/redirects/upload.ts
var import_chalk87 = __toESM(require_source(), 1);
import { readFileSync as readFileSync3 } from "fs";
import { basename as basename2 } from "path";
import FormData from "form-data";

// src/commands/redirects/validate-redirects.ts
import { statSync as statSync2 } from "fs";
var MAX_FILE_SIZE = 50 * 1024 * 1024;
var ALLOWED_EXTENSIONS = [".csv", ".json"];
var MAX_REDIRECTS = 1e6;
var MAX_URL_LENGTH = 2048;
var VALID_STATUS_CODES = [301, 302, 303, 307, 308];
function validateUploadFile(filePath, options = {}) {
  const maxSize = options.maxFileSize ?? MAX_FILE_SIZE;
  const allowedExts = options.allowedExtensions ?? ALLOWED_EXTENSIONS;
  try {
    const stats = statSync2(filePath);
    if (!stats.isFile()) {
      return { valid: false, error: `Path "${filePath}" is not a file` };
    }
    if (stats.size > maxSize) {
      const sizeMB = Math.round(maxSize / (1024 * 1024));
      return { valid: false, error: `File must be below ${sizeMB}MB` };
    }
    const hasValidExtension = allowedExts.some(
      (ext) => filePath.toLowerCase().endsWith(ext)
    );
    if (!hasValidExtension) {
      return {
        valid: false,
        error: `File must be a .csv or .json file`
      };
    }
    return { valid: true };
  } catch (err) {
    if (err.code === "ENOENT") {
      return { valid: false, error: `File "${filePath}" not found` };
    }
    return { valid: false, error: `Error accessing file: ${err.message}` };
  }
}
function validateRedirect(redirect) {
  if (!redirect.source) {
    return { valid: false, error: "Redirect source is required" };
  }
  if (redirect.source.length > MAX_URL_LENGTH) {
    return { valid: false, error: "Source URL is too long" };
  }
  if (!redirect.source.startsWith("/")) {
    return { valid: false, error: "Source must be a relative path" };
  }
  if (!redirect.destination) {
    return { valid: false, error: "Redirect destination is required" };
  }
  if (redirect.destination.length > MAX_URL_LENGTH) {
    return { valid: false, error: "Destination URL is too long" };
  }
  try {
    new URL(redirect.destination, "https://vercel.com");
  } catch {
    return { valid: false, error: "Destination must be a valid URL" };
  }
  if (redirect.statusCode) {
    if (!VALID_STATUS_CODES.includes(redirect.statusCode)) {
      return {
        valid: false,
        error: `Invalid status code. Must be one of: ${VALID_STATUS_CODES.join(", ")}`
      };
    }
  }
  return { valid: true };
}
function validateRedirectsArray(redirects) {
  if (!Array.isArray(redirects)) {
    return {
      valid: false,
      error: "JSON file must contain an array of redirects"
    };
  }
  if (redirects.length === 0) {
    return { valid: false, error: "No redirects provided" };
  }
  if (redirects.length > MAX_REDIRECTS) {
    return {
      valid: false,
      error: `Too many redirects. Maximum allowed: ${MAX_REDIRECTS}`
    };
  }
  for (let i = 0; i < redirects.length; i++) {
    const result = validateRedirect(redirects[i]);
    if (!result.valid) {
      return {
        valid: false,
        error: `Redirect ${i + 1}: ${result.error}`
      };
    }
  }
  return { valid: true };
}
function validateCSVStructure(content) {
  const lines = content.trim().split("\n");
  if (lines.length < 2) {
    return {
      valid: false,
      error: "CSV must have a header and at least one redirect"
    };
  }
  const header = lines[0].toLowerCase();
  const hasSource = header.includes("source");
  const hasDestination = header.includes("destination");
  if (!hasSource || !hasDestination) {
    return {
      valid: false,
      error: 'CSV must have "source" and "destination" columns'
    };
  }
  return { valid: true };
}
function validateVersionName(name) {
  if (!name) {
    return { valid: false, error: "Name is required" };
  }
  if (name.length > 256) {
    return { valid: false, error: "Name must be 256 characters or less" };
  }
  return { valid: true };
}

// src/commands/redirects/upload.ts
async function upload(client, argv) {
  const parsed = await parseSubcommandArgs(argv, uploadSubcommand);
  if (typeof parsed === "number")
    return parsed;
  const link = await ensureProjectLink(client);
  if (typeof link === "number")
    return link;
  const { project, org } = link;
  const teamId = org.type === "team" ? org.id : void 0;
  const { args, flags } = parsed;
  const skipPrompts = flags["--yes"];
  const overwrite = flags["--overwrite"] || false;
  const filePath = args[0];
  if (!filePath) {
    output_manager_default.error("File path is required. Use: vercel redirects upload <file>");
    return 1;
  }
  const fileValidation = validateUploadFile(filePath);
  if (!fileValidation.valid) {
    output_manager_default.error(fileValidation.error);
    return 1;
  }
  const { versions } = await getRedirectVersions(client, project.id, teamId);
  const existingStagingVersion = versions.find((v) => v.isStaging);
  if (!skipPrompts) {
    const fileName = basename2(filePath);
    const fileType = filePath.endsWith(".csv") ? "CSV" : "JSON";
    const message = overwrite ? `Upload ${fileType} file "${fileName}" and replace all existing redirects?` : `Upload ${fileType} file "${fileName}"?`;
    const confirmed = await client.input.confirm(message, true);
    if (!confirmed) {
      output_manager_default.log("Upload cancelled");
      return 0;
    }
  }
  let versionName;
  if (!skipPrompts) {
    const provideName = await client.input.confirm(
      "Do you want to provide a name for this version?",
      false
    );
    if (provideName) {
      versionName = await client.input.text({
        message: "Version name (max 256 characters):",
        validate: (val) => {
          if (val && val.length > 256) {
            return "Name must be 256 characters or less";
          }
          return true;
        }
      });
      const { valid, error } = validateVersionName(versionName);
      if (!valid) {
        output_manager_default.error(error);
        return 1;
      }
    }
  }
  const uploadStamp = stamp_default();
  output_manager_default.spinner("Uploading redirects");
  try {
    let result;
    const url = "/v1/bulk-redirects";
    if (filePath.endsWith(".csv")) {
      const csvContent = readFileSync3(filePath);
      const fileName = basename2(filePath);
      const csvValidation = validateCSVStructure(csvContent.toString());
      if (!csvValidation.valid) {
        output_manager_default.error(`Invalid CSV: ${csvValidation.error}`);
        return 1;
      }
      const form = new FormData();
      form.append("teamId", teamId || org.id);
      form.append("projectId", project.id);
      form.append("overwrite", String(overwrite));
      if (versionName) {
        form.append("name", versionName);
      }
      form.append("bulkRedirectsFile", csvContent, {
        filename: fileName,
        contentType: "text/csv"
      });
      result = await client.fetch(url, {
        method: "PUT",
        headers: form.getHeaders(),
        body: form
      });
    } else {
      const content = readFileSync3(filePath, "utf8");
      let redirects2;
      try {
        redirects2 = JSON.parse(content);
      } catch (err) {
        output_manager_default.error("Invalid JSON file format");
        return 1;
      }
      const redirectsValidation = validateRedirectsArray(redirects2);
      if (!redirectsValidation.valid) {
        output_manager_default.error(redirectsValidation.error);
        return 1;
      }
      const body = {
        projectId: project.id,
        redirects: redirects2,
        overwrite
      };
      if (teamId) {
        body.teamId = teamId;
      }
      if (versionName) {
        body.versionName = versionName;
      }
      result = await client.fetch(url, {
        method: "PUT",
        body
      });
    }
    output_manager_default.log(
      `${import_chalk87.default.cyan("\u2713")} Redirects uploaded ${import_chalk87.default.gray(uploadStamp())}`
    );
    output_manager_default.spinner("Fetching diff");
    const { redirects } = await getRedirects(client, project.id, {
      teamId,
      versionId: result.version.id,
      diff: "only"
    });
    const redirectCount = redirects.length;
    output_manager_default.print(`
  ${import_chalk87.default.bold("Summary:")}
`);
    output_manager_default.print(
      `    Uploaded ${redirectCount} redirect${redirectCount === 1 ? "" : "s"}
`
    );
    if (redirectCount > 0) {
      const added = redirects.filter((r) => r.action === "+");
      const deleted = redirects.filter((r) => r.action === "-");
      const edited = redirects.filter((r) => r.action === "~");
      output_manager_default.print(`
  ${import_chalk87.default.bold("Changes:")}
`);
      if (added.length > 0) {
        output_manager_default.print(`    ${import_chalk87.default.green(`Added: ${added.length}`)}
`);
      }
      if (deleted.length > 0) {
        output_manager_default.print(`    ${import_chalk87.default.red(`Deleted: ${deleted.length}`)}
`);
      }
      if (edited.length > 0) {
        output_manager_default.print(`    ${import_chalk87.default.yellow(`Modified: ${edited.length}`)}
`);
      }
      output_manager_default.print(`
  ${import_chalk87.default.bold("Redirect changes:")}
`);
      const displayRedirects = redirects.slice(0, 100);
      const rows = displayRedirects.map((redirect) => {
        const status3 = redirect.statusCode || (redirect.permanent ? 308 : 307);
        const action = redirect.action || "+";
        let colorFn;
        let actionSymbol;
        switch (action) {
          case "+":
            colorFn = import_chalk87.default.green;
            actionSymbol = "+";
            break;
          case "-":
            colorFn = import_chalk87.default.red;
            actionSymbol = "-";
            break;
          case "~":
            colorFn = import_chalk87.default.yellow;
            actionSymbol = "~";
            break;
          default:
            colorFn = (s) => s;
            actionSymbol = " ";
        }
        return [
          colorFn(`${actionSymbol} ${redirect.source}`),
          colorFn(redirect.destination),
          colorFn(status3.toString())
        ];
      });
      output_manager_default.print(
        formatTable(
          ["Source", "Destination", "Status"],
          ["l", "l", "l"],
          [{ rows }]
        )
      );
      if (redirectCount > 100) {
        output_manager_default.print(
          `
  ${import_chalk87.default.gray(`... and ${redirectCount - 100} more redirect${redirectCount - 100 === 1 ? "" : "s"}`)}
`
        );
      }
    }
    if (result.alias) {
      const testUrl = `https://${result.alias}`;
      output_manager_default.print(
        `
  ${import_chalk87.default.bold("Test your changes:")} ${import_chalk87.default.cyan(testUrl)}
`
      );
    }
    const newVersionName = result.version.name || result.version.id;
    output_manager_default.print(
      `  ${import_chalk87.default.bold("New staging version:")} ${newVersionName}

`
    );
    if (existingStagingVersion) {
      output_manager_default.warn(
        `There are other staged changes. Please review all changes with ${import_chalk87.default.cyan("vercel redirects list --staging")} before promoting to production.`
      );
    } else if (!skipPrompts) {
      const shouldPromote = await client.input.confirm(
        "This is the only staged change. Do you want to promote it to production now?",
        false
      );
      if (shouldPromote) {
        const promoteStamp = stamp_default();
        output_manager_default.spinner("Promoting to production");
        await updateRedirectVersion(
          client,
          project.id,
          result.version.id,
          "promote",
          teamId
        );
        output_manager_default.log(
          `${import_chalk87.default.cyan("\u2713")} Version promoted to production ${import_chalk87.default.gray(promoteStamp())}`
        );
      }
    }
    return 0;
  } catch (error) {
    output_manager_default.error(`Failed to upload redirects: ${error.message}`);
    return 1;
  }
}

// src/commands/redirects/remove.ts
var import_chalk88 = __toESM(require_source(), 1);

// src/util/redirects/delete-redirects.ts
async function deleteRedirects(client, projectId, sources, teamId) {
  const params = new URLSearchParams();
  params.set("projectId", projectId);
  if (teamId) {
    params.set("teamId", teamId);
  }
  const url = `/v1/bulk-redirects?${params}`;
  return await client.fetch(url, {
    method: "DELETE",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      redirects: sources
    })
  });
}

// src/commands/redirects/remove.ts
async function remove3(client, argv) {
  const parsed = await parseSubcommandArgs(argv, removeSubcommand9);
  if (typeof parsed === "number")
    return parsed;
  const error = validateRequiredArgs(parsed.args, ["source"]);
  if (error) {
    output_manager_default.error(error);
    return 1;
  }
  const link = await ensureProjectLink(client);
  if (typeof link === "number")
    return link;
  const { project, org } = link;
  const teamId = org.type === "team" ? org.id : void 0;
  const { versions } = await getRedirectVersions(client, project.id, teamId);
  const existingStagingVersion = versions.find((v) => v.isStaging);
  const [source] = parsed.args;
  output_manager_default.spinner("Fetching redirect information");
  const { redirects } = await getRedirects(client, project.id, { teamId });
  const redirectToRemove = redirects.find((r) => r.source === source);
  if (!redirectToRemove) {
    output_manager_default.error(
      `Redirect with source "${source}" not found. Run ${import_chalk88.default.cyan(
        "vercel redirects list"
      )} to see available redirects.`
    );
    return 1;
  }
  output_manager_default.print(`
  ${import_chalk88.default.bold("Removing redirect:")}
`);
  output_manager_default.print(
    `    ${import_chalk88.default.cyan(redirectToRemove.source)} \u2192 ${import_chalk88.default.cyan(redirectToRemove.destination)}
`
  );
  const status3 = redirectToRemove.statusCode || (redirectToRemove.permanent ? 308 : 307);
  output_manager_default.print(`    Status: ${status3}

`);
  const confirmed = await confirmAction(
    client,
    parsed.flags["--yes"],
    `Remove this redirect?`,
    `This will create a new staging version without this redirect.`
  );
  if (!confirmed) {
    output_manager_default.log("Canceled");
    return 0;
  }
  const removeStamp = stamp_default();
  output_manager_default.spinner(`Removing redirect for ${import_chalk88.default.bold(source)}`);
  const { alias: alias2, version } = await deleteRedirects(
    client,
    project.id,
    [source],
    teamId
  );
  output_manager_default.log(
    `${import_chalk88.default.cyan("\u2713")} Redirect removed ${import_chalk88.default.gray(removeStamp())}`
  );
  if (alias2) {
    const testUrl = source.startsWith("/") ? `https://${alias2}${source}` : `https://${alias2}`;
    output_manager_default.print(
      `
  ${import_chalk88.default.bold("Test your changes:")} ${import_chalk88.default.cyan(testUrl)}
`
    );
    output_manager_default.print(
      `  This URL should no longer redirect to the above destination.
`
    );
  }
  const versionName = version.name || version.id;
  output_manager_default.print(`  ${import_chalk88.default.bold("New staging version:")} ${versionName}

`);
  if (!existingStagingVersion) {
    const shouldPromote = await client.input.confirm(
      "This is the only staged change. Do you want to promote it to production now?",
      false
    );
    if (shouldPromote) {
      const promoteStamp = stamp_default();
      output_manager_default.spinner("Promoting to production");
      await updateRedirectVersion(
        client,
        project.id,
        version.id,
        "promote",
        teamId
      );
      output_manager_default.log(
        `${import_chalk88.default.cyan("\u2713")} Version promoted to production ${import_chalk88.default.gray(promoteStamp())}`
      );
    }
  } else {
    output_manager_default.warn(
      `There are other staged changes. Review them with ${import_chalk88.default.cyan("vercel redirects list --staging")} before promoting to production.`
    );
  }
  return 0;
}

// src/commands/redirects/promote.ts
var import_chalk89 = __toESM(require_source(), 1);
async function promote(client, argv) {
  const parsed = await parseSubcommandArgs(argv, promoteSubcommand);
  if (typeof parsed === "number")
    return parsed;
  const error = validateRequiredArgs(parsed.args, ["version-id"]);
  if (error) {
    output_manager_default.error(error);
    return 1;
  }
  const link = await ensureProjectLink(client);
  if (typeof link === "number")
    return link;
  const { project, org } = link;
  const teamId = org.type === "team" ? org.id : void 0;
  const [versionIdentifier] = parsed.args;
  output_manager_default.spinner(`Fetching redirect versions for ${import_chalk89.default.bold(project.name)}`);
  const { versions } = await getRedirectVersions(client, project.id, teamId);
  const version = versions.find(
    (v) => v.id === versionIdentifier || v.name === versionIdentifier
  );
  if (!version) {
    output_manager_default.error(
      `Version with ID or name "${versionIdentifier}" not found. Run ${import_chalk89.default.cyan(
        "vercel redirects list-versions"
      )} to see available versions.`
    );
    return 1;
  }
  if (version.isLive) {
    output_manager_default.error(
      `Version ${import_chalk89.default.bold(version.name || version.id)} is already live.`
    );
    return 1;
  }
  if (!version.isStaging) {
    output_manager_default.error(
      `Version ${import_chalk89.default.bold(
        version.name || version.id
      )} is not staged. Only staging versions can be promoted to production.
Run ${import_chalk89.default.cyan(
        "vercel redirects list-versions"
      )} to see which version is currently staged.`
    );
    return 1;
  }
  const versionName = version.name || version.id;
  output_manager_default.spinner("Fetching changes");
  const { redirects: diffRedirects } = await getRedirects(client, project.id, {
    teamId,
    versionId: version.id,
    diff: true
  });
  const changedRedirects = diffRedirects.filter(
    (r) => r.action === "+" || r.action === "-"
  );
  if (changedRedirects.length > 0) {
    output_manager_default.print(`
${import_chalk89.default.bold("Changes to be promoted:")}

`);
    const displayRedirects = changedRedirects.slice(0, 20);
    for (const redirect of displayRedirects) {
      const status3 = redirect.statusCode || (redirect.permanent ? 308 : 307);
      const symbol = redirect.action === "+" ? import_chalk89.default.green("+") : import_chalk89.default.red("-");
      output_manager_default.print(
        `  ${symbol} ${redirect.source} \u2192 ${redirect.destination} (${status3})
`
      );
    }
    if (changedRedirects.length > 20) {
      output_manager_default.print(
        import_chalk89.default.gray(`
  ... and ${changedRedirects.length - 20} more changes
`)
      );
    }
    output_manager_default.print("\n");
  } else {
    output_manager_default.print(
      `
${import_chalk89.default.gray("No changes detected from current production version.")}

`
    );
  }
  const confirmed = await confirmAction(
    client,
    parsed.flags["--yes"],
    `Promote version ${import_chalk89.default.bold(versionName)} to production?`,
    `This will make it the live version for ${import_chalk89.default.bold(project.name)}.`
  );
  if (!confirmed) {
    output_manager_default.log("Canceled");
    return 0;
  }
  const updateStamp = stamp_default();
  output_manager_default.spinner(`Promoting version ${import_chalk89.default.bold(versionName)} to production`);
  const { version: newVersion } = await updateRedirectVersion(
    client,
    project.id,
    version.id,
    "promote",
    teamId
  );
  output_manager_default.log(
    `${import_chalk89.default.cyan("\u2713")} Version ${import_chalk89.default.bold(
      newVersion.name || newVersion.id
    )} promoted to production ${import_chalk89.default.gray(updateStamp())}`
  );
  return 0;
}

// src/commands/redirects/restore.ts
var import_chalk90 = __toESM(require_source(), 1);
async function restore(client, argv) {
  const parsed = await parseSubcommandArgs(argv, restoreSubcommand);
  if (typeof parsed === "number")
    return parsed;
  const error = validateRequiredArgs(parsed.args, ["version-id"]);
  if (error) {
    output_manager_default.error(error);
    return 1;
  }
  const link = await ensureProjectLink(client);
  if (typeof link === "number")
    return link;
  const { project, org } = link;
  const teamId = org.type === "team" ? org.id : void 0;
  const [versionIdentifier] = parsed.args;
  output_manager_default.spinner(`Fetching redirect versions for ${import_chalk90.default.bold(project.name)}`);
  const { versions } = await getRedirectVersions(client, project.id, teamId);
  const version = versions.find(
    (v) => v.id === versionIdentifier || v.name === versionIdentifier
  );
  if (!version) {
    output_manager_default.error(
      `Version with ID or name "${versionIdentifier}" not found. Run ${import_chalk90.default.cyan(
        "vercel redirects list-versions"
      )} to see available versions.`
    );
    return 1;
  }
  if (version.isLive) {
    output_manager_default.error(
      `Version ${import_chalk90.default.bold(
        version.name || version.id
      )} is currently live. You cannot restore the live version.
Run ${import_chalk90.default.cyan(
        "vercel redirects list-versions"
      )} to see previous versions you can restore.`
    );
    return 1;
  }
  if (version.isStaging) {
    output_manager_default.error(
      `Version ${import_chalk90.default.bold(
        version.name || version.id
      )} is staged. You can only restore previous versions.`
    );
    return 1;
  }
  const versionName = version.name || version.id;
  output_manager_default.spinner("Fetching changes");
  const { redirects: diffRedirects } = await getRedirects(client, project.id, {
    teamId,
    versionId: version.id,
    diff: true
  });
  const changedRedirects = diffRedirects.filter(
    (r) => r.action === "+" || r.action === "-"
  );
  if (changedRedirects.length > 0) {
    output_manager_default.print(`
${import_chalk90.default.bold("Changes to be restored:")}

`);
    const displayRedirects = changedRedirects.slice(0, 20);
    for (const redirect of displayRedirects) {
      const status3 = redirect.statusCode || (redirect.permanent ? 308 : 307);
      const symbol = redirect.action === "+" ? import_chalk90.default.green("+") : import_chalk90.default.red("-");
      output_manager_default.print(
        `  ${symbol} ${redirect.source} \u2192 ${redirect.destination} (${status3})
`
      );
    }
    if (changedRedirects.length > 20) {
      output_manager_default.print(
        import_chalk90.default.gray(`
  ... and ${changedRedirects.length - 20} more changes
`)
      );
    }
    output_manager_default.print("\n");
  } else {
    output_manager_default.print(
      `
${import_chalk90.default.gray("No changes detected from current production version.")}

`
    );
  }
  const confirmed = await confirmAction(
    client,
    parsed.flags["--yes"],
    `Restore version ${import_chalk90.default.bold(versionName)}?`,
    `This will make it the live version for ${import_chalk90.default.bold(project.name)}.`
  );
  if (!confirmed) {
    output_manager_default.log("Canceled");
    return 0;
  }
  const updateStamp = stamp_default();
  output_manager_default.spinner(`Restoring version ${import_chalk90.default.bold(versionName)}`);
  const { version: newVersion } = await updateRedirectVersion(
    client,
    project.id,
    version.id,
    "restore",
    teamId
  );
  output_manager_default.log(
    `${import_chalk90.default.cyan("\u2713")} Version ${import_chalk90.default.bold(
      newVersion.name || newVersion.id
    )} restored to production ${import_chalk90.default.gray(updateStamp())}`
  );
  return 0;
}

// src/util/telemetry/commands/redirects/index.ts
var RedirectsTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandList(actual) {
    this.trackCliSubcommand({
      subcommand: "list",
      value: actual
    });
  }
  trackCliSubcommandListVersions(actual) {
    this.trackCliSubcommand({
      subcommand: "list-versions",
      value: actual
    });
  }
  trackCliSubcommandAdd(actual) {
    this.trackCliSubcommand({
      subcommand: "add",
      value: actual
    });
  }
  trackCliSubcommandUpload(actual) {
    this.trackCliSubcommand({
      subcommand: "upload",
      value: actual
    });
  }
  trackCliSubcommandRemove(actual) {
    this.trackCliSubcommand({
      subcommand: "remove",
      value: actual
    });
  }
  trackCliSubcommandPromote(actual) {
    this.trackCliSubcommand({
      subcommand: "promote",
      value: actual
    });
  }
  trackCliSubcommandRestore(actual) {
    this.trackCliSubcommand({
      subcommand: "restore",
      value: actual
    });
  }
};

// src/commands/redirects/index.ts
var COMMAND_CONFIG17 = {
  list: getCommandAliases(listSubcommand9),
  "list-versions": getCommandAliases(listVersionsSubcommand),
  add: getCommandAliases(addSubcommand7),
  upload: getCommandAliases(uploadSubcommand),
  remove: getCommandAliases(removeSubcommand9),
  promote: getCommandAliases(promoteSubcommand),
  restore: getCommandAliases(restoreSubcommand)
};
async function main14(client) {
  const telemetry2 = new RedirectsTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(redirectsCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification, {
      permissive: true
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  const subArgs = parsedArgs.args.slice(1);
  const { subcommand, args, subcommandOriginal } = getSubcommand2(
    subArgs,
    COMMAND_CONFIG17
  );
  const needHelp = parsedArgs.flags["--help"];
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp("redirects");
    output_manager_default.print(help(redirectsCommand, { columns: client.stderr.columns }));
    return 2;
  }
  function printHelp(command) {
    output_manager_default.print(
      help(command, {
        parent: redirectsCommand,
        columns: client.stderr.columns
      })
    );
  }
  switch (subcommand) {
    case "list":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("redirects", subcommandOriginal);
        printHelp(listSubcommand9);
        return 2;
      }
      telemetry2.trackCliSubcommandList(subcommandOriginal);
      return list6(client, args);
    case "list-versions":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("redirects", subcommandOriginal);
        printHelp(listVersionsSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandListVersions(subcommandOriginal);
      return listVersions(client, args);
    case "add":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("redirects", subcommandOriginal);
        printHelp(addSubcommand7);
        return 2;
      }
      telemetry2.trackCliSubcommandAdd(subcommandOriginal);
      return add7(client, args);
    case "upload":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("redirects", subcommandOriginal);
        printHelp(uploadSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandUpload(subcommandOriginal);
      return upload(client, args);
    case "remove":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("redirects", subcommandOriginal);
        printHelp(removeSubcommand9);
        return 2;
      }
      telemetry2.trackCliSubcommandRemove(subcommandOriginal);
      return remove3(client, args);
    case "promote":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("redirects", subcommandOriginal);
        printHelp(promoteSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandPromote(subcommandOriginal);
      return promote(client, args);
    case "restore":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("redirects", subcommandOriginal);
        printHelp(restoreSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandRestore(subcommandOriginal);
      return restore(client, args);
    default:
      output_manager_default.error(getInvalidSubcommand(COMMAND_CONFIG17));
      output_manager_default.print(help(redirectsCommand, { columns: client.stderr.columns }));
      return 2;
  }
}

// src/commands/remove/index.ts
var import_chalk91 = __toESM(require_source(), 1);
var import_ms22 = __toESM(require_ms(), 1);
var import_pluralize11 = __toESM(require_pluralize(), 1);

// src/util/url.ts
var normalizeURL2 = (u) => {
  if (u.slice(-1) === "/") {
    u = u.slice(0, -1);
  }
  u = u.replace(/^https:\/\//i, "");
  return u;
};

// src/util/projects/remove-project.ts
async function removeProject(client, projectNameOrId) {
  try {
    await client.fetch(`/projects/${encodeURIComponent(projectNameOrId)}`, {
      method: "DELETE"
    });
  } catch (error) {
    if (isAPIError(error) && error.status === 404) {
      return new ProjectNotFound(projectNameOrId);
    }
    throw error;
  }
}

// src/util/deploy/get-deployments-by-project-id.ts
import { URLSearchParams as URLSearchParams3 } from "url";
async function getDeploymentsByProjectId(client, projectId, options = { from: null, limit: 100, continue: false }, total = 0) {
  const limit = options.limit || 100;
  const query = new URLSearchParams3();
  query.set("projectId", projectId);
  query.set("limit", limit.toString());
  if (options.from) {
    query.set("from", options.from.toString());
  }
  const { deployments: legacyDeployments } = await client.fetch(
    `/v6/deployments?${query}`
  );
  const deployments = legacyDeployments.map((depl) => {
    return {
      aliasAssigned: depl.aliasAssigned,
      aliasError: depl.aliasError,
      buildingAt: depl.buildingAt,
      checksConclusion: depl.checksConclusion,
      checksState: depl.checksState,
      createdAt: depl.created,
      creator: {
        uid: depl.creator.uid,
        username: depl.creator.username
      },
      id: depl.uid,
      inspectorUrl: depl.inspectorUrl,
      meta: depl.meta,
      name: depl.name,
      public: true,
      ready: depl.ready,
      readyState: depl.state,
      regions: [],
      source: depl.source,
      status: depl.state,
      target: depl.target,
      type: depl.type,
      url: depl.url,
      version: 2
    };
  });
  total += deployments.length;
  if (options.max && total >= options.max) {
    return deployments;
  }
  if (options.continue && deployments.length === limit) {
    const nextFrom = deployments[deployments.length - 1].createdAt;
    const nextOptions = Object.assign({}, options, { from: nextFrom });
    deployments.push(
      ...await getDeploymentsByProjectId(
        client,
        projectId,
        nextOptions,
        total
      )
    );
  }
  return deployments;
}

// src/util/telemetry/commands/remove/index.ts
var RemoveTelemetryClient = class extends TelemetryClient {
  trackCliArgumentNameOrDeploymentId(values) {
    if (values) {
      this.trackCliArgument({
        arg: "nameOrDeploymentId",
        value: this.redactedArgumentsLength(values)
      });
    }
  }
  trackCliFlagHard(flag) {
    if (flag) {
      this.trackCliFlag("hard");
    }
  }
  trackCliFlagSafe(flag) {
    if (flag) {
      this.trackCliFlag("safe");
    }
  }
  trackCliFlagYes(flag) {
    if (flag) {
      this.trackCliFlag("yes");
    }
  }
};

// src/commands/remove/index.ts
async function remove4(client) {
  const telemetryClient = new RemoveTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs = null;
  const flagsSpecification = getFlagsSpecification(removeCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification);
  } catch (error2) {
    printError(error2);
    return 1;
  }
  if (parsedArgs.flags["--help"]) {
    telemetryClient.trackCliFlagHelp("remove");
    output_manager_default.print(help(removeCommand, { columns: client.stderr.columns }));
    return 2;
  }
  const ids = parsedArgs.args.slice(1);
  const hard = parsedArgs.flags["--hard"];
  const skipConfirmation = parsedArgs.flags["--yes"];
  const safe = parsedArgs.flags["--safe"];
  telemetryClient.trackCliArgumentNameOrDeploymentId(ids);
  telemetryClient.trackCliFlagSafe(safe);
  telemetryClient.trackCliFlagHard(hard);
  telemetryClient.trackCliFlagYes(skipConfirmation);
  const {
    config: { currentTeam }
  } = client;
  const { success, error, log } = output_manager_default;
  if (ids.length < 1) {
    error(`${getCommandName("rm")} expects at least one argument`);
    output_manager_default.print(help(removeCommand, { columns: client.stderr.columns }));
    return 1;
  }
  const invalidName = ids.find((name) => !isValidName(name));
  if (invalidName) {
    error(
      `The provided argument "${invalidName}" is not a valid deployment or project`
    );
    return 1;
  }
  const { contextName } = await getScope(client);
  output_manager_default.spinner(
    `Fetching deployment(s) ${ids.map((id) => `"${id}"`).join(" ")} in ${import_chalk91.default.bold(contextName)}`
  );
  let aliases;
  let projects;
  let deployments;
  const findStart = Date.now();
  try {
    const searchFilter = (d) => ids.some(
      (id) => d && !(d instanceof NowError) && (d.id === id || d.name === id || d.url === normalizeURL2(id))
    );
    const [deploymentList, projectList] = await Promise.all([
      Promise.all(
        ids.map(async (idOrHost) => {
          if (!contextName) {
            throw new Error("Context name is not defined");
          }
          return getDeployment(client, contextName, idOrHost).catch((err) => err);
        })
      ),
      Promise.all(
        ids.map(async (idOrName) => getProjectByNameOrId(client, idOrName))
      )
    ]);
    deployments = deploymentList.filter((d) => searchFilter(d));
    projects = projectList.filter((d) => searchFilter(d));
    if (safe) {
      const projectDeployments = await Promise.all(
        projects.map((project) => {
          return getDeploymentsByProjectId(client, project.id, {
            max: 201,
            continue: true
          });
        })
      );
      const to = Math.min(projectDeployments.length, 201);
      for (let i = 0; i < to; i++) {
        for (const pDepl of projectDeployments[i]) {
          const depl = pDepl;
          depl.aliases = [];
          deployments.push(depl);
        }
      }
      projects = [];
    } else {
      deployments = deployments.filter(
        (d) => !projects.some((p) => p.name === d.name)
      );
    }
    aliases = await Promise.all(
      deployments.map(async (depl) => {
        const { aliases: aliases2 } = await getAliases(client, depl.id);
        return aliases2;
      })
    );
  } finally {
    output_manager_default.stopSpinner();
  }
  deployments = deployments.filter((match, i) => {
    if (safe && aliases[i].length > 0) {
      return false;
    }
    match.aliases = aliases[i];
    return true;
  });
  if (deployments.length === 0 && projects.length === 0) {
    const safeUnaliased = parsedArgs.flags["--safe"] ? "unaliased" : "any";
    const stylizedIds = ids.map((id) => import_chalk91.default.bold(`"${id}"`)).join(", ");
    const commandName = getCommandName("projects ls");
    log(
      `Could not find ${safeUnaliased} deployments or projects matching ${stylizedIds}. Run ${commandName} to list.`
    );
    return 1;
  }
  log(
    `Found ${deploymentsAndProjects(deployments, projects)} for removal in ${import_chalk91.default.bold(contextName)} ${elapsed(Date.now() - findStart)}`
  );
  if (deployments.length > 200) {
    output_manager_default.warn(
      "Only 200 deployments can get deleted at once. Please continue 10 minutes after deletion to remove the rest."
    );
  }
  if (!skipConfirmation) {
    const confirmation = (await readConfirmation4(deployments, projects)).toLowerCase();
    if (confirmation !== "y" && confirmation !== "yes") {
      output_manager_default.log("Canceled");
      return 1;
    }
  }
  const now = new Now({
    client,
    currentTeam
  });
  const start = Date.now();
  await Promise.all([
    ...deployments.map((depl) => now.remove(depl.id, { hard })),
    ...projects.map((project) => removeProject(client, project.id))
  ]);
  success(
    `Removed ${deploymentsAndProjects(deployments, projects)} ${elapsed(Date.now() - start)}`
  );
  deployments.forEach((depl) => {
    output_manager_default.print(`${import_chalk91.default.gray("-")} ${import_chalk91.default.bold(depl.url)}
`);
  });
  projects.forEach((project) => {
    output_manager_default.print(`${import_chalk91.default.gray("-")} ${import_chalk91.default.bold(project.name)}
`);
  });
  return 0;
}
function readConfirmation4(deployments, projects) {
  return new Promise((resolve6) => {
    if (deployments.length > 0) {
      output_manager_default.log(
        `The following ${(0, import_pluralize11.default)(
          "deployment",
          deployments.length,
          deployments.length > 1
        )} will be permanently removed:`
      );
      const deploymentTable = table(
        deployments.map((depl) => {
          const time = import_chalk91.default.gray(`${(0, import_ms22.default)(Date.now() - depl.createdAt)} ago`);
          const url = depl.url ? import_chalk91.default.underline(`https://${depl.url}`) : "";
          return [`  ${depl.id}`, url, time];
        }),
        { align: ["l", "r", "l"], hsep: 6 }
      );
      output_manager_default.print(`${deploymentTable}
`);
    }
    for (const depl of deployments) {
      for (const { alias: alias2 } of depl.aliases) {
        output_manager_default.warn(
          `${import_chalk91.default.underline(`https://${alias2}`)} is an alias for ${import_chalk91.default.bold(depl.url)} and will be removed`
        );
      }
    }
    if (projects.length > 0) {
      output_manager_default.print(
        `The following ${(0, import_pluralize11.default)(
          "project",
          projects.length,
          projects.length > 1
        )} will be permanently removed, including all ${projects.length > 1 ? "their" : "its"} deployments and aliases:
`
      );
      for (const project of projects) {
        output_manager_default.print(`${import_chalk91.default.gray("-")} ${import_chalk91.default.bold(project.name)}
`);
      }
    }
    output_manager_default.print(
      `${import_chalk91.default.bold.red("> Are you sure?")} ${import_chalk91.default.gray("(y/N) ")}`
    );
    process.stdin.on("data", (d) => {
      process.stdin.pause();
      resolve6(d.toString().trim());
    }).resume();
  });
}
function deploymentsAndProjects(deployments, projects, conjunction = "and") {
  if (!projects || projects.length === 0) {
    return `${(0, import_pluralize11.default)("deployment", deployments.length, true)}`;
  }
  if (!deployments || deployments.length === 0) {
    return `${(0, import_pluralize11.default)("project", projects.length, true)}`;
  }
  return `${(0, import_pluralize11.default)("deployment", deployments.length, true)} ${conjunction} ${(0, import_pluralize11.default)("project", projects.length, true)}`;
}

// src/commands/rollback/index.ts
var import_error_utils12 = __toESM(require_dist(), 1);
var import_ms25 = __toESM(require_ms(), 1);

// src/commands/rollback/request-rollback.ts
var import_chalk93 = __toESM(require_source(), 1);
var import_ms24 = __toESM(require_ms(), 1);

// src/commands/rollback/status.ts
var import_chalk92 = __toESM(require_source(), 1);
var import_ms23 = __toESM(require_ms(), 1);
async function rollbackStatus({
  client,
  contextName,
  deployment,
  project,
  timeout = "3m"
}) {
  const recentThreshold = Date.now() - (0, import_ms23.default)("3m");
  const rollbackTimeout = Date.now() + (0, import_ms23.default)(timeout);
  let counter = 0;
  let spinnerMessage = deployment ? "Rollback in progress" : `Checking rollback status of ${project.name}`;
  if (!contextName) {
    ({ contextName } = await getScope(client));
  }
  try {
    output_manager_default.spinner(`${spinnerMessage}\u2026`);
    for (; ; ) {
      const projectCheck = await getProjectByNameOrId(
        client,
        project.id,
        project.accountId,
        true
      );
      if (projectCheck instanceof ProjectNotFound) {
        throw projectCheck;
      }
      const {
        jobStatus,
        requestedAt,
        toDeploymentId,
        type
      } = projectCheck.lastAliasRequest ?? {};
      if (!jobStatus || jobStatus !== "in-progress" && jobStatus !== "pending") {
        output_manager_default.stopSpinner();
        output_manager_default.log(`${spinnerMessage}\u2026`);
      }
      if (!jobStatus || !requestedAt || !toDeploymentId || requestedAt < recentThreshold) {
        output_manager_default.log("No deployment rollback in progress");
        return 0;
      }
      if (jobStatus === "skipped" && type === "rollback") {
        output_manager_default.log("Rollback was skipped");
        return 0;
      }
      if (jobStatus === "succeeded") {
        return await renderJobSucceeded2({
          client,
          contextName,
          performingRollback: !!deployment,
          requestedAt,
          project,
          toDeploymentId
        });
      }
      if (jobStatus === "failed") {
        return await renderJobFailed2({
          client,
          contextName,
          deployment,
          project,
          toDeploymentId
        });
      }
      if (jobStatus !== "pending" && jobStatus !== "in-progress") {
        output_manager_default.log(`Unknown rollback status "${jobStatus}"`);
        return 1;
      }
      if (requestedAt < recentThreshold || Date.now() >= rollbackTimeout) {
        output_manager_default.log(
          `The rollback exceeded its deadline - rerun ${import_chalk92.default.bold(
            `${packageName} rollback ${toDeploymentId}`
          )} to try again`
        );
        return 1;
      }
      if (counter++ === 0 && !deployment) {
        spinnerMessage += ` requested at ${formatDate(requestedAt)}`;
      }
      output_manager_default.spinner(`${spinnerMessage}\u2026`);
      await sleep(250);
    }
  } finally {
    output_manager_default.stopSpinner();
  }
}
async function renderJobFailed2({
  client,
  contextName,
  deployment,
  project,
  toDeploymentId
}) {
  try {
    const name = (deployment || await getDeployment(client, contextName, toDeploymentId))?.url;
    output_manager_default.error(
      `Failed to remap all aliases to the requested deployment ${name} (${toDeploymentId})`
    );
  } catch (e2) {
    output_manager_default.error(
      `Failed to remap all aliases to the requested deployment ${toDeploymentId}`
    );
  }
  let nextTimestamp;
  for (; ; ) {
    let url = `/v9/projects/${project.id}/rollback/aliases?failedOnly=true&limit=20`;
    if (nextTimestamp) {
      url += `&until=${nextTimestamp}`;
    }
    const { aliases, pagination } = await client.fetch(url);
    for (const { alias: alias2, status: status3 } of aliases) {
      output_manager_default.log(
        `  ${renderAliasStatus(status3).padEnd(11)}  ${alias2.alias} (${alias2.deploymentId})`
      );
    }
    if (pagination?.next) {
      nextTimestamp = pagination.next;
    } else {
      break;
    }
  }
  return 1;
}
async function renderJobSucceeded2({
  client,
  contextName,
  performingRollback,
  project,
  requestedAt,
  toDeploymentId
}) {
  let deploymentInfo = "";
  try {
    const deployment = await getDeployment(client, contextName, toDeploymentId);
    deploymentInfo = `${import_chalk92.default.bold(deployment.url)} (${toDeploymentId})`;
  } catch (err) {
    output_manager_default.debug(
      `Failed to get deployment url for ${toDeploymentId}: ${err?.toString() || err}`
    );
    deploymentInfo = import_chalk92.default.bold(toDeploymentId);
  }
  const duration = performingRollback ? elapsed(Date.now() - requestedAt) : "";
  output_manager_default.log(
    `Success! ${import_chalk92.default.bold(
      project.name
    )} was rolled back to ${deploymentInfo} ${duration}`
  );
  return 0;
}

// src/commands/rollback/request-rollback.ts
async function requestRollback({
  client,
  deployId,
  timeout
}) {
  const { contextName, deployment, project } = await getProjectByDeployment({
    client,
    deployId
  });
  await client.fetch(`/v9/projects/${project.id}/rollback/${deployment.id}`, {
    body: {},
    // required
    method: "POST"
  });
  if (timeout !== void 0 && (0, import_ms24.default)(timeout) === 0) {
    output_manager_default.log(
      `Successfully requested rollback of ${import_chalk93.default.bold(project.name)} to ${deployment.url} (${deployment.id})`
    );
    output_manager_default.log(`To check rollback status, run ${getCommandName("rollback")}.`);
    return 0;
  }
  return await rollbackStatus({
    client,
    contextName,
    deployment,
    project,
    timeout
  });
}

// src/util/telemetry/commands/rollback/index.ts
var RollbackTelemetryClient = class extends TelemetryClient {
  trackCliArgumentUrlOrDeploymentId(value) {
    if (value) {
      this.trackCliArgument({
        arg: "urlOrDeploymentId",
        value: this.redactedValue
      });
    }
  }
  trackCliSubcommandStatus() {
    this.trackCliSubcommand({
      subcommand: "status",
      value: "status"
    });
  }
  trackCliOptionTimeout(time) {
    if (time) {
      this.trackCliOption({
        option: "timeout",
        value: "[TIME]"
      });
    }
  }
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
};

// src/commands/rollback/index.ts
var rollback_default = async (client) => {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(rollbackCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const telemetry2 = new RollbackTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  telemetry2.trackCliOptionTimeout(parsedArgs.flags["--timeout"]);
  telemetry2.trackCliFlagYes(parsedArgs.flags["--yes"]);
  const needHelp = parsedArgs.flags["--help"];
  if (!parsedArgs.args[1] && needHelp) {
    telemetry2.trackCliFlagHelp("rollback");
    output_manager_default.print(help(rollbackCommand, { columns: client.stderr.columns }));
    return 2;
  }
  const timeout = parsedArgs.flags["--timeout"];
  if (timeout && (0, import_ms25.default)(timeout) === void 0) {
    output_manager_default.error(`Invalid timeout "${timeout}"`);
    return 1;
  }
  const actionOrDeployId = parsedArgs.args[1] || "status";
  try {
    if (actionOrDeployId === "status") {
      if (needHelp) {
        telemetry2.trackCliFlagHelp("promote", "status");
        output_manager_default.print(
          help(statusSubcommand3, {
            columns: client.stderr.columns,
            parent: rollbackCommand
          })
        );
        return 2;
      }
      telemetry2.trackCliSubcommandStatus();
      const project = await getProjectByCwdOrLink({
        autoConfirm: parsedArgs.flags["--yes"],
        client,
        commandName: "promote",
        projectNameOrId: parsedArgs.args[2]
      });
      return await rollbackStatus({
        client,
        project,
        timeout
      });
    }
    return await requestRollback({
      client,
      deployId: actionOrDeployId,
      timeout
    });
  } catch (err) {
    if ((0, import_error_utils12.isErrnoException)(err)) {
      if (err.code === "ERR_CANCELED") {
        return 0;
      }
      if (err.code === "ERR_INVALID_CWD" || err.code === "ERR_LINK_PROJECT") {
        return 1;
      }
    }
    output_manager_default.prettyError(err);
    return 1;
  }
};

// src/commands/rolling-release/start-rolling-release.ts
async function startRollingRelease({
  client,
  dpl,
  projectId,
  teamId,
  yes
}) {
  const { deployment } = await getProjectByDeployment({
    client,
    deployId: dpl
  });
  let promoteByCreation = false;
  if (deployment.target !== "production") {
    if (yes) {
      promoteByCreation = true;
    } else {
      const question = "This deployment is not a production deployment and cannot be directly promoted. A new deployment will be built using your production environment. Are you sure you want to continue?";
      promoteByCreation = await client.input.confirm(question, false);
      if (!promoteByCreation) {
        output_manager_default.error("Canceled");
        return 0;
      }
    }
  }
  if (promoteByCreation) {
    const newDeployment = await client.fetch(
      `/v13/deployments?teamId=${deployment.ownerId}`,
      {
        body: {
          deploymentId: deployment.id,
          name: projectId,
          target: "production",
          meta: {
            action: "promote"
          }
        },
        accountId: deployment.ownerId,
        method: "POST"
      }
    );
    output_manager_default.log(
      `Successfully created new deployment at ${newDeployment.inspectorUrl}`
    );
    return 0;
  }
  await client.fetch(
    `/v10/projects/${projectId}/promote/${deployment.id}?teamId=${teamId}`,
    {
      body: {},
      // required
      json: false,
      method: "POST"
    }
  );
  output_manager_default.log("Successfully started rolling release");
  return 0;
}

// src/commands/rolling-release/configure-rolling-release.ts
var import_ms26 = __toESM(require_ms(), 1);
function parseDuration(value) {
  if (!value) {
    return void 0;
  }
  if (/^\d+(s|ms)$/i.test(value)) {
    return void 0;
  }
  const milliseconds = (0, import_ms26.default)(/^\d+$/.test(value) ? `${value}m` : value);
  if (milliseconds === void 0 || milliseconds <= 0) {
    return void 0;
  }
  const minutes = Math.round(milliseconds / 6e4);
  if (minutes <= 0) {
    return void 0;
  }
  return minutes;
}
function parseStageFlags(stageFlags, advancementType) {
  const stages = [];
  for (const stageValue of stageFlags) {
    const parts = stageValue.split(",");
    const percentage = parseInt(parts[0], 10);
    if (isNaN(percentage) || percentage < 1 || percentage > 99) {
      return {
        stages: null,
        error: `Invalid stage percentage "${parts[0]}". Must be a number between 1 and 99.`
      };
    }
    if (parts.length > 1) {
      if (advancementType === "manual-approval") {
        return {
          stages: null,
          error: 'Duration must not be provided for stages when advancement type is "manual-approval".'
        };
      }
      const duration = parseDuration(parts[1]);
      if (duration === void 0) {
        return {
          stages: null,
          error: `Invalid duration "${parts[1]}". Use minutes (e.g. "5m"), hours (e.g. "1h"), or days (e.g. "1d"). Seconds are not supported.`
        };
      }
      stages.push({ targetPercentage: percentage, duration });
    } else {
      if (advancementType === "automatic") {
        return {
          stages: null,
          error: 'Duration is required for each stage when advancement type is "automatic". Use the format "PERCENTAGE,DURATION" (e.g. "10,5m").'
        };
      }
      stages.push({ targetPercentage: percentage });
    }
  }
  for (let i = 1; i < stages.length; i++) {
    if (stages[i].targetPercentage <= stages[i - 1].targetPercentage) {
      return {
        stages: null,
        error: "Stage percentages must be in ascending order."
      };
    }
  }
  return { stages, error: null };
}
async function interactiveConfigure(client) {
  const action = await client.input.select({
    message: "Would you like to enable or disable rolling releases?",
    choices: [
      { name: "Enable", value: "enable" },
      { name: "Disable", value: "disable" }
    ]
  });
  if (action === "disable") {
    return { config: void 0 };
  }
  const advancementType = await client.input.select({
    message: "How should stages advance?",
    choices: [
      {
        name: "automatic - Stages advance automatically after a set duration",
        value: "automatic"
      },
      {
        name: "manual-approval - Each stage requires manual approval to advance",
        value: "manual-approval"
      }
    ]
  });
  const stages = [];
  let stageNumber = 1;
  let addMore = true;
  while (addMore) {
    const percentageStr = await client.input.text({
      message: `Enter traffic percentage for stage ${stageNumber} (1-99):`,
      validate: (val) => {
        const num = parseInt(val, 10);
        if (isNaN(num) || num < 1 || num > 99) {
          return "Percentage must be a number between 1 and 99.";
        }
        if (stages.length > 0 && num <= stages[stages.length - 1].targetPercentage) {
          return `Percentage must be greater than the previous stage (${stages[stages.length - 1].targetPercentage}%).`;
        }
        return true;
      }
    });
    const percentage = parseInt(percentageStr, 10);
    let duration;
    if (advancementType === "automatic") {
      const durationStr = await client.input.text({
        message: `Enter duration for this stage (e.g. 5m, 1h):`,
        validate: (val) => {
          const parsed = parseDuration(val);
          if (parsed === void 0) {
            return 'Invalid duration. Use minutes (e.g. "5m"), hours (e.g. "1h"), or days (e.g. "1d"). Seconds are not supported.';
          }
          return true;
        }
      });
      duration = parseDuration(durationStr);
    }
    stages.push({ targetPercentage: percentage, duration });
    stageNumber++;
    addMore = await client.input.confirm("Add another stage?", false);
  }
  output_manager_default.log("");
  output_manager_default.log("Rolling release configuration:");
  output_manager_default.log(`  Advancement: ${advancementType}`);
  stages.forEach((stage, i) => {
    const durationText = stage.duration !== void 0 ? ` for ${stage.duration} minutes` : "";
    output_manager_default.log(`  Stage ${i + 1}: ${stage.targetPercentage}%${durationText}`);
  });
  output_manager_default.log(`  Stage ${stages.length + 1}: 100% (final)`);
  output_manager_default.log("");
  const confirmed = await client.input.confirm(
    "Apply this configuration?",
    true
  );
  if (!confirmed) {
    output_manager_default.log("Configuration cancelled.");
    return { exitCode: 0 };
  }
  return {
    config: {
      enabled: true,
      advancementType,
      stages: [...stages, { targetPercentage: 100 }]
    }
  };
}
async function buildConfigurePayload({
  client,
  cfgString,
  enableFlag,
  disableFlag,
  advancementType,
  stageFlags
}) {
  if (cfgString !== void 0) {
    if (cfgString === "disable") {
      return { config: void 0 };
    }
    try {
      const cfg = JSON.parse(cfgString);
      return { config: cfg };
    } catch {
      output_manager_default.error("Invalid JSON provided for --cfg option.");
      return { exitCode: 1 };
    }
  }
  if (disableFlag) {
    if (enableFlag) {
      output_manager_default.error("--enable and --disable are mutually exclusive.");
      return { exitCode: 1 };
    }
    return { config: void 0 };
  }
  if (enableFlag) {
    if (advancementType !== "automatic" && advancementType !== "manual-approval") {
      output_manager_default.error(
        '--advancement-type is required when using --enable. Must be "automatic" or "manual-approval".'
      );
      return { exitCode: 1 };
    }
    if (!stageFlags || stageFlags.length === 0) {
      output_manager_default.error("At least one --stage is required when using --enable.");
      return { exitCode: 1 };
    }
    const parsed = parseStageFlags(stageFlags, advancementType);
    if (parsed.error !== null) {
      output_manager_default.error(parsed.error);
      return { exitCode: 1 };
    }
    return {
      config: {
        enabled: true,
        advancementType,
        stages: [...parsed.stages, { targetPercentage: 100 }]
      }
    };
  }
  const hasAnyFlags = advancementType !== void 0 || stageFlags !== void 0 && stageFlags.length > 0;
  if (hasAnyFlags) {
    output_manager_default.error(
      "--enable or --disable is required when using --advancement-type or --stage flags."
    );
    return { exitCode: 1 };
  }
  if (client.stdin.isTTY) {
    return interactiveConfigure(client);
  }
  output_manager_default.error(
    "Missing configuration flags. Use --enable/--disable with --advancement-type and --stage, or run interactively in a terminal."
  );
  return { exitCode: 1 };
}
async function configureRollingRelease({
  client,
  projectId,
  teamId,
  rollingReleaseConfig
}) {
  const body = {
    ...rollingReleaseConfig,
    enabled: Boolean(rollingReleaseConfig)
  };
  await client.fetch(
    `/v1/projects/${projectId}/rolling-release/config?teamId=${teamId}`,
    {
      body,
      json: true,
      method: "PATCH"
    }
  );
  if (rollingReleaseConfig) {
    output_manager_default.log("Successfully configured rolling releases.");
  } else {
    output_manager_default.log("Successfully disabled rolling releases.");
  }
  return 0;
}

// src/commands/rolling-release/approve-rolling-release.ts
async function approveRollingRelease({
  client,
  projectId,
  teamId,
  activeStageIndex,
  dpl
}) {
  const { deployment } = await getProjectByDeployment({
    client,
    deployId: dpl
  });
  await client.fetch(
    `/v1/projects/${projectId}/rolling-release/approve-stage?teamId=${teamId}`,
    {
      method: "POST",
      json: true,
      body: {
        activeStageIndex,
        nextStageIndex: activeStageIndex + 1,
        canaryDeploymentId: deployment.id
      }
    }
  );
  output_manager_default.log(
    "Successfully requested approval of rolling release to next stage."
  );
  return 0;
}

// src/commands/rolling-release/abort-rolling-release.ts
async function abortRollingRelease({
  client,
  projectId,
  dpl,
  teamId
}) {
  const { deployment } = await getProjectByDeployment({
    client,
    deployId: dpl
  });
  await client.fetch(
    `/v9/projects/${projectId}/rollback/${deployment.id}?teamId=${teamId}`,
    {
      body: {},
      // required
      method: "POST"
    }
  );
  output_manager_default.log("Successfully aborted the active rolling release.");
  return 0;
}

// src/commands/rolling-release/complete-rolling-release.ts
async function completeRollingRelease({
  client,
  projectId,
  teamId,
  dpl
}) {
  const { deployment } = await getProjectByDeployment({
    client,
    deployId: dpl
  });
  await client.fetch(
    `/v1/projects/${projectId}/rolling-release/complete?teamId=${teamId}`,
    {
      body: { canaryDeploymentId: deployment.id },
      // required
      json: true,
      method: "POST"
    }
  );
  output_manager_default.log(
    "Successfully requested completion of the active rolling release."
  );
  return 0;
}

// src/util/telemetry/commands/rolling-release/index.ts
var RollingReleaseTelemetryClient = class extends TelemetryClient {
  trackCliOptionAction(value) {
    this.trackCliOption({
      option: "action",
      value: value ?? ""
    });
  }
  trackCliOptionName(name) {
    if (name) {
      this.trackCliOption({
        option: "name",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionCfg(value) {
    this.trackCliOption({
      option: "cfg",
      value: value ?? ""
    });
  }
  trackCliOptionDpl(value) {
    this.trackCliOption({
      option: "dpl",
      value: value ?? ""
    });
  }
  trackCliOptionCurrentStageIndex(value) {
    this.trackCliOption({
      option: "currentStageIndex",
      value: value ?? ""
    });
  }
  trackCliSubcommandConfigure(actual) {
    this.trackCliSubcommand({
      subcommand: "configure",
      value: actual
    });
  }
  trackCliSubcommandStart(actual) {
    this.trackCliSubcommand({
      subcommand: "start",
      value: actual
    });
  }
  trackCliSubcommandApprove(actual) {
    this.trackCliSubcommand({
      subcommand: "approve",
      value: actual
    });
  }
  trackCliSubcommandAbort(actual) {
    this.trackCliSubcommand({
      subcommand: "abort",
      value: actual
    });
  }
  trackCliSubcommandComplete(actual) {
    this.trackCliSubcommand({
      subcommand: "complete",
      value: actual
    });
  }
  trackCliSubcommandFetch(actual) {
    this.trackCliSubcommand({
      subcommand: "fetch",
      value: actual
    });
  }
  trackCliFlagEnable(value) {
    if (value) {
      this.trackCliFlag("enable");
    }
  }
  trackCliFlagDisable(value) {
    if (value) {
      this.trackCliFlag("disable");
    }
  }
  trackCliOptionAdvancementType(value) {
    if (value) {
      this.trackCliOption({
        option: "advancement-type",
        value
      });
    }
  }
  trackCliOptionStage(value) {
    if (value) {
      this.trackCliOption({
        option: "stage",
        value: value.join(",")
      });
    }
  }
};

// src/commands/rolling-release/index.ts
var COMMAND_CONFIG18 = {
  configure: getCommandAliases(configureSubcommand),
  start: getCommandAliases(startSubcommand),
  approve: getCommandAliases(approveSubcommand),
  abort: getCommandAliases(abortSubcommand),
  complete: getCommandAliases(completeSubcommand),
  fetch: getCommandAliases(fetchSubcommand)
};
async function rollingRelease(client) {
  const telemetry2 = new RollingReleaseTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const {
    subcommand,
    args: subcommandArgs,
    subcommandOriginal
  } = getSubcommand2(client.argv.slice(3), COMMAND_CONFIG18);
  const needHelp = client.argv.includes("--help") || client.argv.includes("-h");
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp("rolling-release");
    output_manager_default.print(
      help(rollingReleaseCommand, { columns: client.stderr.columns })
    );
    return 2;
  }
  function printHelp(command) {
    output_manager_default.print(
      help(command, {
        parent: rollingReleaseCommand,
        columns: client.stderr.columns
      })
    );
  }
  try {
    const link = await getLinkedProject(client);
    if (link.status === "error") {
      return link.exitCode;
    }
    if (link.status === "not_linked") {
      output_manager_default.error(
        "No project found. Please run `vc link` to link your project first."
      );
      return 1;
    }
    const { project, org } = link;
    client.config.currentTeam = org.type === "team" ? org.id : void 0;
    let subcommandFlags;
    switch (subcommand) {
      case "configure": {
        if (needHelp) {
          telemetry2.trackCliFlagHelp("rolling-release", subcommandOriginal);
          printHelp(configureSubcommand);
          return 2;
        }
        subcommandFlags = parseArguments(
          subcommandArgs,
          getFlagsSpecification(configureSubcommand.options)
        );
        const cfgString = subcommandFlags.flags["--cfg"];
        const enableFlag = subcommandFlags.flags["--enable"];
        const disableFlag = subcommandFlags.flags["--disable"];
        const advancementType = subcommandFlags.flags["--advancement-type"];
        const stageFlags = subcommandFlags.flags["--stage"];
        telemetry2.trackCliFlagEnable(enableFlag);
        telemetry2.trackCliFlagDisable(disableFlag);
        telemetry2.trackCliOptionAdvancementType(advancementType);
        telemetry2.trackCliOptionStage(stageFlags);
        const configResult = await buildConfigurePayload({
          client,
          cfgString,
          enableFlag,
          disableFlag,
          advancementType,
          stageFlags
        });
        if (configResult.exitCode !== void 0) {
          return configResult.exitCode;
        }
        await configureRollingRelease({
          client,
          projectId: project.id,
          teamId: org.id,
          rollingReleaseConfig: configResult.config
        });
        break;
      }
      case "start": {
        if (needHelp) {
          telemetry2.trackCliFlagHelp("rolling-release", subcommandOriginal);
          printHelp(startSubcommand);
          return 2;
        }
        subcommandFlags = parseArguments(
          subcommandArgs,
          getFlagsSpecification(startSubcommand.options)
        );
        const dpl = subcommandFlags.flags["--dpl"];
        if (dpl === void 0) {
          output_manager_default.error("starting a rolling release requires --dpl option.");
          break;
        }
        await startRollingRelease({
          client,
          dpl,
          projectId: project.id,
          teamId: project.accountId,
          yes: subcommandFlags.flags["--yes"] ?? false
        });
        break;
      }
      case "approve": {
        if (needHelp) {
          telemetry2.trackCliFlagHelp("rolling-release", subcommandOriginal);
          printHelp(approveSubcommand);
          return 2;
        }
        subcommandFlags = parseArguments(
          subcommandArgs,
          getFlagsSpecification(approveSubcommand.options)
        );
        const dpl = subcommandFlags.flags["--dpl"];
        const currentStageIndex = subcommandFlags.flags["--currentStageIndex"];
        const activeStageIndex = parseInt(currentStageIndex ?? "");
        if (!dpl) {
          output_manager_default.error("Missing required flag --dpl");
          return 1;
        }
        if (currentStageIndex === void 0) {
          output_manager_default.error("Missing required flag --currentStageIndex");
          return 1;
        }
        if (isNaN(activeStageIndex)) {
          output_manager_default.error("--currentStageIndex must be a valid number.");
          return 1;
        }
        await approveRollingRelease({
          client,
          projectId: project.id,
          teamId: org.id,
          activeStageIndex,
          dpl
        });
        break;
      }
      case "abort": {
        if (needHelp) {
          telemetry2.trackCliFlagHelp("rolling-release", subcommandOriginal);
          printHelp(abortSubcommand);
          return 2;
        }
        subcommandFlags = parseArguments(
          subcommandArgs,
          getFlagsSpecification(abortSubcommand.options)
        );
        const dpl = subcommandFlags.flags["--dpl"];
        if (!dpl) {
          output_manager_default.error("Missing required flag --dpl");
          return 1;
        }
        await abortRollingRelease({
          client,
          projectId: project.id,
          teamId: org.id,
          dpl
        });
        break;
      }
      case "complete": {
        if (needHelp) {
          telemetry2.trackCliFlagHelp("rolling-release", subcommandOriginal);
          printHelp(completeSubcommand);
          return 2;
        }
        subcommandFlags = parseArguments(
          subcommandArgs,
          getFlagsSpecification(completeSubcommand.options)
        );
        const dpl = subcommandFlags.flags["--dpl"];
        if (!dpl) {
          output_manager_default.error("Missing required flag --dpl");
          return 1;
        }
        await completeRollingRelease({
          client,
          projectId: project.id,
          teamId: org.id,
          dpl
        });
        break;
      }
      case "fetch": {
        if (needHelp) {
          telemetry2.trackCliFlagHelp("rolling-release", subcommandOriginal);
          printHelp(fetchSubcommand);
          return 2;
        }
        const result = await requestRollingRelease({
          client,
          projectId: project.id,
          teamId: org.id
        });
        output_manager_default.log(JSON.stringify(result, null, 2));
        break;
      }
      default: {
        output_manager_default.debug(`Invalid subcommand: ${subcommand}`);
        output_manager_default.error(getInvalidSubcommand(COMMAND_CONFIG18));
        output_manager_default.print(
          help(rollingReleaseCommand, { columns: client.stderr.columns })
        );
        return 2;
      }
    }
    return 0;
  } catch (err) {
    printError(err);
    return 1;
  }
}

// src/commands/target/list.ts
var import_ms27 = __toESM(require_ms(), 1);
var import_chalk94 = __toESM(require_source(), 1);
function formatBranchMatcher(branchMatcher) {
  if (branchMatcher?.type === "equals") {
    return branchMatcher.pattern;
  } else if (branchMatcher?.type === "startsWith") {
    return `${branchMatcher.pattern}${import_chalk94.default.dim("*")}`;
  } else if (branchMatcher?.type === "endsWith") {
    return `${import_chalk94.default.dim("*")}${branchMatcher.pattern}`;
  }
  return import_chalk94.default.dim("No branch configuration");
}
var TYPE_MAP = {
  production: "Production",
  preview: "Preview",
  development: "Development"
};
var BRANCH_TRACKING_MAP = {
  production: (project) => project.link?.productionBranch ?? "main",
  preview: (_, env) => env.slug === "preview" ? import_chalk94.default.dim("All unassigned git branches") : formatBranchMatcher(env.branchMatcher),
  development: () => import_chalk94.default.dim("Accessible via CLI")
};
async function list7(client, argv) {
  const { cwd } = client;
  const telemetry2 = new TelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(listSubcommand10.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const validationResult = validateLsArgs({
    commandName: "target ls",
    args: parsedArgs.args,
    maxArgs: 0,
    exitCode: 2
  });
  if (validationResult !== 0) {
    return validationResult;
  }
  const formatResult = validateJsonOutput(parsedArgs.flags);
  if (!formatResult.valid) {
    output_manager_default.error(formatResult.error);
    return 1;
  }
  const asJson = formatResult.jsonOutput;
  telemetry2.trackCliOptionFormat(parsedArgs.flags["--format"]);
  const link = await ensureLink(targetCommand.name, client, cwd);
  if (typeof link === "number") {
    return link;
  }
  const start = Date.now();
  const projectSlugLink = formatProject(link.org.slug, link.project.name);
  output_manager_default.spinner(`Fetching custom environments for ${projectSlugLink}`);
  const url = `/projects/${encodeURIComponent(
    link.project.id
  )}/custom-environments`;
  let { environments: result } = await client.fetch(url, {
    method: "GET",
    accountId: link.org.id
  });
  output_manager_default.stopSpinner();
  const elapsed2 = (0, import_ms27.default)(Date.now() - start);
  result = withDefaultEnvironmentsIncluded(result);
  if (asJson) {
    const jsonOutput = {
      targets: result.map((target) => ({
        id: target.id,
        slug: target.slug,
        type: target.type,
        description: target.description,
        branchMatcher: target.branchMatcher,
        createdAt: target.createdAt,
        updatedAt: target.updatedAt
      }))
    };
    client.stdout.write(`${JSON.stringify(jsonOutput, null, 2)}
`);
  } else {
    output_manager_default.log(
      `${result.length} Environment${result.length === 1 ? "" : "s"} found under ${projectSlugLink} ${import_chalk94.default.gray(`[${elapsed2}]`)}`
    );
    const tablePrint = table(
      [
        ["Target Name", "Branch Tracking", "Type", "Updated"].map(
          (header) => import_chalk94.default.bold(import_chalk94.default.cyan(header))
        ),
        ...result.flatMap((target) => {
          return [
            [
              formatEnvironment(link.org.slug, link.project.name, target),
              BRANCH_TRACKING_MAP[target.type](link.project, target),
              TYPE_MAP[target.type],
              import_chalk94.default.gray(
                target.updatedAt > 0 ? (0, import_ms27.default)(Date.now() - target.updatedAt) : "-"
              )
            ]
          ];
        })
      ],
      { hsep: 3 }
    ).replace(/^/gm, "  ");
    output_manager_default.print(`
${tablePrint}

`);
  }
  return 0;
}
function withDefaultEnvironmentsIncluded(environments) {
  return [
    {
      id: "production",
      slug: "production",
      createdAt: 0,
      updatedAt: 0,
      type: "production",
      description: "",
      domains: []
    },
    {
      id: "preview",
      slug: "preview",
      createdAt: 0,
      updatedAt: 0,
      type: "preview",
      description: "",
      domains: []
    },
    {
      id: "development",
      slug: "development",
      createdAt: 0,
      updatedAt: 0,
      type: "development",
      description: "",
      domains: []
    },
    ...environments.slice().sort((a, b) => a.slug.localeCompare(b.slug))
  ];
}

// src/util/telemetry/commands/target/index.ts
var TargetTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandList(subcommandActual) {
    this.trackCliSubcommand({
      subcommand: "list",
      value: subcommandActual
    });
  }
};

// src/commands/target/index.ts
var COMMAND_CONFIG19 = {
  ls: getCommandAliases(listSubcommand10)
};
async function main15(client) {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(targetCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification, {
      permissive: true
    });
  } catch (error) {
    printError(error);
    return 1;
  }
  const { telemetryEventStore } = client;
  const telemetry2 = new TargetTelemetryClient({
    opts: {
      store: telemetryEventStore
    }
  });
  parsedArgs.args = parsedArgs.args.slice(1);
  const subcommand = parsedArgs.args[0];
  const args = parsedArgs.args.slice(1);
  const needHelp = parsedArgs.flags["--help"];
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp("target");
    output_manager_default.print(help(targetCommand, { columns: client.stderr.columns }));
    return 2;
  }
  function printHelp(command) {
    output_manager_default.print(
      help(command, { parent: targetCommand, columns: client.stderr.columns })
    );
  }
  switch (subcommand) {
    case "ls":
    case "list":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("target", "list");
        printHelp(listSubcommand10);
        return 2;
      }
      telemetry2.trackCliSubcommandList(subcommand);
      return await list7(client, args);
    default:
      output_manager_default.error(getInvalidSubcommand(COMMAND_CONFIG19));
      output_manager_default.print(help(targetCommand, { columns: client.stderr.columns }));
      return 2;
  }
}

// src/commands/teams/list.ts
var import_chalk95 = __toESM(require_source(), 1);

// src/util/telemetry/commands/teams/list.ts
var TeamsListTelemetryClient = class extends TelemetryClient {
  trackCliOptionNext(value) {
    if (value && value > 0) {
      this.trackCliOption({
        option: "next",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionUntil(value) {
    if (value) {
      this.trackCliOption({
        option: "until",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionSince(value) {
    if (value) {
      this.trackCliOption({
        option: "since",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionCount(value) {
    if (value && value > 0) {
      this.trackCliOption({
        option: "count",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/teams/list.ts
async function list8(client, argv) {
  const { config, telemetryEventStore } = client;
  const telemetry2 = new TeamsListTelemetryClient({
    opts: {
      store: telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(listSubcommand11.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const validationResult = validateLsArgs({
    commandName: "teams ls",
    args: parsedArgs.args,
    maxArgs: 0,
    exitCode: 2
  });
  if (validationResult !== 0) {
    return validationResult;
  }
  const next = parsedArgs.flags["--next"];
  const formatResult = validateJsonOutput(parsedArgs.flags);
  if (!formatResult.valid) {
    output_manager_default.error(formatResult.error);
    return 1;
  }
  const asJson = formatResult.jsonOutput;
  telemetry2.trackCliOptionNext(next);
  telemetry2.trackCliOptionFormat(parsedArgs.flags["--format"]);
  telemetry2.trackCliOptionCount(parsedArgs.flags["--count"]);
  telemetry2.trackCliOptionUntil(parsedArgs.flags["--until"]);
  telemetry2.trackCliOptionSince(parsedArgs.flags["--since"]);
  if (typeof next !== "undefined" && !Number.isInteger(next)) {
    output_manager_default.error("Please provide a number for flag `--next`");
    return 1;
  }
  output_manager_default.spinner("Fetching teams");
  const { teams: teams2, pagination } = await getTeams(client, {
    next,
    apiVersion: 2
  });
  let { currentTeam } = config;
  output_manager_default.spinner("Fetching user information");
  const user = await getUser(client);
  const accountIsCurrent = !currentTeam && user.version !== "northstar";
  if (accountIsCurrent) {
    currentTeam = user.id;
  }
  const teamList = teams2.map(({ id, slug, name }) => ({
    id,
    name,
    value: slug,
    isCurrent: id === currentTeam
  }));
  if (user.version !== "northstar") {
    teamList.unshift({
      id: user.id,
      name: user.email,
      value: user.username || user.email,
      isCurrent: accountIsCurrent
    });
  }
  if (!accountIsCurrent) {
    const index = teamList.findIndex((choice2) => choice2.id === currentTeam);
    const choice = teamList.splice(index, 1)[0];
    teamList.unshift(choice);
  }
  output_manager_default.stopSpinner();
  if (asJson) {
    const jsonOutput = {
      teams: teamList.map((team) => ({
        id: team.id,
        slug: team.value,
        name: team.name,
        current: team.isCurrent
      })),
      pagination
    };
    client.stdout.write(`${JSON.stringify(jsonOutput, null, 2)}
`);
  } else {
    client.stdout.write("\n");
    const teamTable = table(
      [
        ["id", "Team name"].map((str) => (0, import_chalk95.gray)(str)),
        ...teamList.map((team) => [team.value, team.name])
      ],
      { hsep: 5 }
    );
    client.stderr.write(
      currentTeam ? teamTable.split("\n").map((line, i) => {
        const prefix = i > 0 ? teamList[i - 1].isCurrent ? chars_default.tick : " " : " ";
        return `${prefix} ${line}`;
      }).join("\n") : teamTable
    );
    client.stderr.write("\n");
    if (pagination?.count === 20) {
      const flags = getCommandFlags(parsedArgs.flags, [
        "--next",
        "-N",
        "-d",
        "--format"
      ]);
      const nextCmd = `${packageName} teams ls${flags} --next ${pagination.next}`;
      client.stdout.write("\n");
      output_manager_default.log(`To display the next page run ${cmd(nextCmd)}`);
    }
  }
  return 0;
}

// src/commands/teams/add.ts
var import_chalk97 = __toESM(require_source(), 1);

// src/commands/teams/invite.ts
var import_chalk96 = __toESM(require_source(), 1);

// src/util/input/regexes.ts
var email = /.+@.+\..+$/;

// src/util/teams/invite-user-to-team.ts
async function inviteUserToTeam(client, teamId, email2) {
  const body = await client.fetch(
    `/teams/${encodeURIComponent(teamId)}/members`,
    {
      method: "POST",
      body: { email: email2 }
    }
  );
  return body;
}

// src/commands/teams/invite.ts
var import_error_utils13 = __toESM(require_dist(), 1);

// src/util/telemetry/commands/teams/invite.ts
var TeamsInviteTelemetryClient = class extends TelemetryClient {
  trackCliArgumentEmail(values) {
    if (values) {
      this.trackCliArgument({
        arg: "email",
        value: this.redactedArgumentsLength(values)
      });
    }
  }
};

// src/commands/teams/invite.ts
var validateEmail = (data) => email.test(data.trim()) || data.length === 0;
var domains = Array.from(
  /* @__PURE__ */ new Set([
    "aol.com",
    "gmail.com",
    "google.com",
    "yahoo.com",
    "ymail.com",
    "hotmail.com",
    "live.com",
    "outlook.com",
    "inbox.com",
    "mail.com",
    "gmx.com",
    "icloud.com"
  ])
);
async function invite(client, argv, { introMsg = "", noopMsg = "No changes made" } = {}) {
  const { config, telemetryEventStore } = client;
  const { currentTeam: currentTeamId } = config;
  const telemetry2 = new TeamsInviteTelemetryClient({
    opts: {
      store: telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(inviteSubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args: emails } = parsedArgs;
  output_manager_default.spinner("Fetching teams");
  const teams2 = await getTeams(client);
  const currentTeam = teams2.find((team) => team.id === currentTeamId);
  output_manager_default.spinner("Fetching user information");
  const user = await getUser(client);
  domains.push(user.email.split("@")[1]);
  if (!currentTeam) {
    const err = `You can't run this command under ${param(
      user.username || user.email
    )}.
Please select a team scope using ${getCommandName(
      `switch`
    )} or use ${cmd("--scope")}`;
    output_manager_default.error(err);
    return 1;
  }
  output_manager_default.log(
    introMsg || `Inviting team members to ${import_chalk96.default.bold(currentTeam.name)}`
  );
  telemetry2.trackCliArgumentEmail(emails);
  if (emails.length > 0) {
    for (const email3 of emails) {
      if (email.test(email3)) {
        output_manager_default.spinner(email3);
        const elapsed2 = stamp_default();
        let userInfo = null;
        try {
          const res = await inviteUserToTeam(client, currentTeam.id, email3);
          userInfo = res.username;
        } catch (err) {
          if (isAPIError(err) && err.code === "user_not_found") {
            output_manager_default.error(`No user exists with the email address "${email3}".`);
            return 1;
          }
          throw err;
        }
        output_manager_default.log(
          `${import_chalk96.default.cyan(chars_default.tick)} ${email3}${userInfo ? ` (${userInfo})` : ""} ${elapsed2()}`
        );
      } else {
        output_manager_default.log(`${import_chalk96.default.red(`\u2716 ${email3}`)} ${import_chalk96.default.gray("[invalid]")}`);
      }
    }
    return 0;
  }
  const inviteUserPrefix = "Invite User".padEnd(14);
  const sentEmailPrefix = "Sent Email".padEnd(14);
  let hasError = false;
  let email2;
  do {
    email2 = "";
    try {
      email2 = await client.input.text({
        message: `- ${inviteUserPrefix}`,
        validate: validateEmail
      });
    } catch (err) {
      if (!(0, import_error_utils13.isError)(err) || err.message !== "USER_ABORT") {
        throw err;
      }
    }
    let elapsed2;
    if (email2) {
      elapsed2 = stamp_default();
      output_manager_default.spinner(inviteUserPrefix + email2);
      try {
        const { username } = await inviteUserToTeam(
          client,
          currentTeam.id,
          email2
        );
        email2 = `${email2}${username ? ` (${username})` : ""} ${elapsed2()}`;
        emails.push(email2);
        output_manager_default.log(`${import_chalk96.default.cyan(chars_default.tick)} ${sentEmailPrefix}${email2}`);
        if (hasError) {
          hasError = false;
          process.stderr.write(eraseLines(emails.length + 2));
          output_manager_default.log(
            introMsg || `Inviting team members to ${import_chalk96.default.bold(currentTeam.name)}`
          );
          for (const email3 of emails) {
            output_manager_default.log(`${import_chalk96.default.cyan(chars_default.tick)} ${inviteUserPrefix}${email3}`);
          }
        }
      } catch (err) {
        output_manager_default.stopSpinner();
        process.stderr.write(eraseLines(emails.length + 2));
        output_manager_default.error((0, import_error_utils13.errorToString)(err));
        hasError = true;
        for (const email3 of emails) {
          output_manager_default.log(`${import_chalk96.default.cyan(chars_default.tick)} ${sentEmailPrefix}${email3}`);
        }
      }
    }
  } while (email2 !== "");
  output_manager_default.stopSpinner();
  process.stderr.write(eraseLines(emails.length + 2));
  const n = emails.length;
  if (emails.length === 0) {
    output_manager_default.log(noopMsg);
  } else {
    output_manager_default.success(`Invited ${n} teammate${n > 1 ? "s" : ""}`);
    for (const email3 of emails) {
      output_manager_default.log(`${import_chalk96.default.cyan(chars_default.tick)} ${inviteUserPrefix}${email3}`);
    }
  }
  return 0;
}

// src/util/teams/create-team.ts
async function createTeam(client, { slug }) {
  const body = await client.fetch(`/teams`, {
    method: "POST",
    body: { slug }
  });
  return body;
}

// src/util/teams/patch-team.ts
async function patchTeam(client, teamId, payload) {
  const body = await client.fetch(
    `/teams/${encodeURIComponent(teamId)}`,
    {
      method: "PATCH",
      body: payload
    }
  );
  return body;
}

// src/commands/teams/add.ts
var import_error_utils14 = __toESM(require_dist(), 1);
var validateSlug = (value) => /^[a-z]+[a-z0-9_-]*$/.test(value);
var validateName = (value) => /^[ a-zA-Z0-9_-]+$/.test(value);
var teamUrlPrefix = "Team URL".padEnd(14) + import_chalk97.default.gray("vercel.com/");
var teamNamePrefix = "Team Name".padEnd(14);
async function add8(client) {
  let slug;
  let team;
  let elapsed2;
  output_manager_default.log(
    `Pick a team identifier for its URL (e.g.: ${import_chalk97.default.cyan(
      "`vercel.com/acme`"
    )})`
  );
  do {
    try {
      slug = await client.input.text({
        message: `- ${teamUrlPrefix}`,
        validate: validateSlug,
        default: slug
      });
    } catch (err) {
      if ((0, import_error_utils14.isError)(err) && err.message === "USER_ABORT") {
        output_manager_default.log("Canceled");
        return 0;
      }
      throw err;
    }
    elapsed2 = stamp_default();
    output_manager_default.spinner(teamUrlPrefix + slug);
    try {
      team = await createTeam(client, { slug });
    } catch (err) {
      output_manager_default.stopSpinner();
      output_manager_default.print(eraseLines(2));
      output_manager_default.error((0, import_error_utils14.errorToString)(err));
    }
  } while (!team);
  output_manager_default.stopSpinner();
  process.stdout.write(eraseLines(2));
  output_manager_default.success(`Team created ${elapsed2()}`);
  output_manager_default.log(`${import_chalk97.default.cyan(`${chars_default.tick} `) + teamUrlPrefix + slug}
`);
  output_manager_default.log("Pick a display name for your team");
  let name;
  try {
    name = await client.input.text({
      message: `- ${teamNamePrefix}`,
      validate: validateName
    });
  } catch (err) {
    if ((0, import_error_utils14.isError)(err) && err.message === "USER_ABORT") {
      output_manager_default.log("No name specified");
      return 2;
    }
    throw err;
  }
  elapsed2 = stamp_default();
  output_manager_default.spinner(teamNamePrefix + name);
  const res = await patchTeam(client, team.id, { name });
  output_manager_default.stopSpinner();
  process.stdout.write(eraseLines(2));
  team = Object.assign(team, res);
  output_manager_default.success(`Team name saved ${elapsed2()}`);
  output_manager_default.log(`${import_chalk97.default.cyan(`${chars_default.tick} `) + teamNamePrefix + team.name}
`);
  output_manager_default.spinner("Saving");
  client.config.currentTeam = team.id;
  writeToConfigFile(client.config);
  output_manager_default.stopSpinner();
  await invite(client, [], {
    introMsg: "Invite your teammates! When done, press enter on an empty field",
    noopMsg: `You can invite teammates later by running ${getCommandName(
      `teams invite`
    )}`
  });
  return 0;
}

// src/commands/teams/switch.ts
var import_chalk98 = __toESM(require_source(), 1);

// src/util/telemetry/commands/teams/switch.ts
var TeamsSwitchTelemetryClient = class extends TelemetryClient {
  trackCliArgumentName(slug) {
    if (slug) {
      this.trackCliArgument({
        arg: "slug",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/teams/switch.ts
var updateCurrentTeam = (config, team) => {
  if (team) {
    config.currentTeam = team.id;
  } else {
    delete config.currentTeam;
  }
  writeToConfigFile(config);
};
async function change(client, argv) {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(switchSubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  let {
    args: [desiredSlug]
  } = parsedArgs;
  const { config, telemetryEventStore } = client;
  const telemetry2 = new TeamsSwitchTelemetryClient({
    opts: {
      store: telemetryEventStore
    }
  });
  telemetry2.trackCliArgumentName(desiredSlug);
  const personalScopeSelected = !config.currentTeam;
  output_manager_default.spinner("Fetching teams information");
  const [user, teams2] = await Promise.all([getUser(client), getTeams(client)]);
  const currentTeam = personalScopeSelected ? void 0 : teams2.find((team) => team.id === config.currentTeam);
  if (!personalScopeSelected && !currentTeam) {
    output_manager_default.error(`You are not a member of the current team anymore.`);
    return 1;
  }
  if (!desiredSlug) {
    const teamChoices = teams2.slice(0).sort((a, b) => {
      return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
    }).map((team) => {
      let title3 = `${team.name} (${team.slug})`;
      const selected = team.id === currentTeam?.id;
      if (selected) {
        title3 += ` ${import_chalk98.default.bold("(current)")}`;
      }
      if (team.limited) {
        title3 += ` ${emoji("locked")}`;
      }
      return {
        name: title3,
        value: team.slug,
        short: team.slug,
        selected
      };
    });
    let suffix = personalScopeSelected ? ` ${import_chalk98.default.bold("(current)")}` : "";
    if (user.limited) {
      suffix += ` ${emoji("locked")}`;
    }
    const personalAccountChoice = user.version === "northstar" ? [] : [
      { separator: "Personal Account" },
      {
        name: `${user.name || user.email} (${user.username})${suffix}`,
        value: user.username,
        short: user.username,
        selected: personalScopeSelected
      }
    ];
    const choices = [
      ...personalAccountChoice,
      { separator: "Teams" },
      ...teamChoices
    ];
    output_manager_default.stopSpinner();
    desiredSlug = await list(client, {
      message: "Switch to:",
      choices,
      eraseFinalAnswer: true
    });
  }
  if (!desiredSlug) {
    output_manager_default.log("No changes made.");
    return 0;
  }
  if (desiredSlug === user.username || desiredSlug === user.email) {
    if (user.version === "northstar") {
      output_manager_default.error("You cannot set your Personal Account as the scope.");
      return 1;
    }
    if (personalScopeSelected) {
      output_manager_default.log("No changes made");
      return 0;
    }
    if (user.limited) {
      await client.reauthenticate({
        scope: user.username,
        teamId: null
      });
    }
    updateCurrentTeam(config);
    output_manager_default.success(
      `Your account (${import_chalk98.default.bold(user.username)}) is now active!`
    );
    return 0;
  }
  const newTeam = teams2.find((team) => team.slug === desiredSlug);
  if (!newTeam) {
    output_manager_default.error(
      `You do not have permission to access scope ${import_chalk98.default.bold(desiredSlug)}.`
    );
    return 1;
  }
  if (newTeam.slug === currentTeam?.slug) {
    output_manager_default.log("No changes made");
    return 0;
  }
  if (newTeam.limited) {
    const samlEnabled = newTeam.saml?.connection?.state === "active";
    await client.reauthenticate({
      teamId: samlEnabled ? newTeam.id : null,
      scope: newTeam.slug,
      enforced: samlEnabled && newTeam.saml?.enforced === true
    });
  }
  updateCurrentTeam(config, newTeam);
  output_manager_default.success(
    `The team ${import_chalk98.default.bold(newTeam.name)} (${newTeam.slug}) is now active!`
  );
  return 0;
}

// src/util/telemetry/commands/teams/index.ts
var TeamsTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandInvite(actual) {
    if (actual) {
      this.trackCliSubcommand({
        subcommand: "invite",
        value: actual
      });
    }
  }
  trackCliSubcommandAdd(actual) {
    if (actual) {
      this.trackCliSubcommand({
        subcommand: "add",
        value: actual
      });
    }
  }
  trackCliSubcommandSwitch(actual) {
    if (actual) {
      this.trackCliSubcommand({
        subcommand: "switch",
        value: actual
      });
    }
  }
  trackCliSubcommandList(actual) {
    if (actual) {
      this.trackCliSubcommand({
        subcommand: "list",
        value: actual
      });
    }
  }
};

// src/commands/teams/index.ts
var COMMAND_CONFIG20 = {
  list: ["ls", "list"],
  switch: ["switch", "change"],
  add: ["create", "add"],
  invite: ["invite"]
};
async function teams(client) {
  const telemetry2 = new TeamsTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(teamsCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification, {
      permissive: true
    });
  } catch (error) {
    printError(error);
    return 1;
  }
  if (parsedArgs.args[0] === "switch") {
    parsedArgs.args.unshift("teams");
  }
  const { subcommand, args, subcommandOriginal } = getSubcommand2(
    parsedArgs.args.slice(1),
    COMMAND_CONFIG20
  );
  const needHelp = parsedArgs.flags["--help"];
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp("teams", subcommand);
    output_manager_default.print(help(teamsCommand, { columns: client.stderr.columns }));
    return 2;
  }
  function printHelp(command) {
    output_manager_default.print(
      help(command, { parent: teamsCommand, columns: client.stderr.columns })
    );
  }
  switch (subcommand) {
    case "list": {
      if (needHelp) {
        telemetry2.trackCliFlagHelp("teams", subcommandOriginal);
        printHelp(listSubcommand11);
        return 2;
      }
      telemetry2.trackCliSubcommandList(subcommandOriginal);
      return list8(client, args);
    }
    case "switch": {
      if (needHelp) {
        telemetry2.trackCliFlagHelp("teams", subcommandOriginal);
        printHelp(switchSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandSwitch(subcommandOriginal);
      return change(client, args);
    }
    case "add": {
      if (needHelp) {
        telemetry2.trackCliFlagHelp("teams", subcommandOriginal);
        printHelp(addSubcommand8);
        return 2;
      }
      telemetry2.trackCliSubcommandAdd(subcommandOriginal);
      return add8(client);
    }
    case "invite": {
      if (needHelp) {
        telemetry2.trackCliFlagHelp("teams", subcommandOriginal);
        printHelp(inviteSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandInvite(subcommandOriginal);
      return invite(client, args);
    }
    default: {
      output_manager_default.error(
        "Please specify a valid subcommand: add | ls | switch | invite"
      );
      output_manager_default.print(help(teamsCommand, { columns: client.stderr.columns }));
      return 2;
    }
  }
}

// src/commands/telemetry/status.ts
var import_chalk99 = __toESM(require_source(), 1);
async function status2(client) {
  const enabled = client.config.telemetry?.enabled !== false;
  const status3 = enabled ? import_chalk99.default.green("Enabled") : import_chalk99.default.red("Disabled");
  output_manager_default.print("\n");
  output_manager_default.log(`${import_chalk99.default.bold("Telemetry status")}: ${status3}
`);
  const learnMoreMessage = `

Learn more: ${import_chalk99.default.cyan("https://vercel.com/docs/cli/about-telemetry")}`;
  if (enabled) {
    output_manager_default.log(`You have opted in to Vercel CLI telemetry${learnMoreMessage}`);
  } else {
    output_manager_default.log("You have opted out of Vercel CLI telemetry");
    output_manager_default.log(
      `No data will be collected from your machine${learnMoreMessage}`
    );
  }
  return 0;
}

// src/commands/telemetry/enable.ts
async function enable3(client) {
  client.config = {
    ...client.config,
    telemetry: {
      ...client.config.telemetry,
      enabled: true
    }
  };
  writeToConfigFile(client.config);
  await status2(client);
  return 0;
}

// src/commands/telemetry/disable.ts
async function disable3(client) {
  client.config = {
    ...client.config,
    telemetry: {
      ...client.config.telemetry,
      enabled: false
    }
  };
  writeToConfigFile(client.config);
  await status2(client);
  return 0;
}

// src/commands/telemetry/flush.ts
var import_node_fetch = __toESM(require_lib3(), 1);
async function flush(_client, args) {
  const url = process.env.VERCEL_TELEMETRY_BRIDGE_URL || "https://telemetry.vercel.com/api/vercel-cli/v1/events";
  const { headers, body } = JSON.parse(args[0]);
  try {
    const res = await (0, import_node_fetch.default)(url, {
      method: "POST",
      headers,
      body: JSON.stringify(body)
    });
    const status3 = res.status;
    const cliTracked = res.headers.get("x-vercel-cli-tracked") || "";
    const wasRecorded = cliTracked === "1";
    if (status3 === 204) {
      if (wasRecorded) {
        process.stderr.write("Telemetry event tracked");
      } else {
        process.stderr.write("Telemetry event ignored");
      }
    } else {
      process.stderr.write(
        `Failed to send telemetry events. Unexpected response from telemetry server: ${status3}`
      );
    }
    return 0;
  } catch (error) {
    if (error instanceof Error) {
      process.stderr.write(`Failed to send telemetry events. ${error.message}`);
    }
    return 1;
  }
}

// src/util/telemetry/commands/telemetry/index.ts
var TelemetryTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandStatus(actual) {
    this.trackCliSubcommand({
      subcommand: "status",
      value: actual
    });
  }
  trackCliSubcommandEnable(actual) {
    this.trackCliSubcommand({
      subcommand: "enable",
      value: actual
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  trackCliSubcommandDisable(_) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  trackCliSubcommandFlush(_) {
  }
};

// src/commands/telemetry/index.ts
var import_chalk100 = __toESM(require_source(), 1);
var COMMAND_CONFIG21 = {
  status: getCommandAliases(statusSubcommand4),
  enable: getCommandAliases(enableSubcommand3),
  disable: getCommandAliases(disableSubcommand3),
  flush: getCommandAliases(flushSubcommand)
};
async function telemetry(client) {
  const telemetryClient = new TelemetryTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArguments;
  const flagsSpecification = getFlagsSpecification(telemetryCommand.options);
  try {
    parsedArguments = parseArguments(client.argv.slice(2), flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { subcommand, args, subcommandOriginal } = getSubcommand2(
    parsedArguments.args.slice(1),
    COMMAND_CONFIG21
  );
  const needHelp = parsedArguments.flags["--help"];
  function printHelp(command) {
    output_manager_default.print(
      help(command, {
        columns: client.stderr.columns,
        parent: telemetryCommand
      })
    );
  }
  if (!subcommand && needHelp) {
    telemetryClient.trackCliFlagHelp("telemetry", subcommand);
    output_manager_default.print(help(telemetryCommand, { columns: client.stderr.columns }));
    return 2;
  }
  switch (subcommand) {
    case "status":
      if (needHelp) {
        telemetryClient.trackCliFlagHelp("telemetry", subcommandOriginal);
        printHelp(statusSubcommand4);
        return 2;
      }
      telemetryClient.trackCliSubcommandStatus(subcommandOriginal);
      return status2(client);
    case "flush":
      return flush(client, args);
    case "enable":
      if (needHelp) {
        telemetryClient.trackCliFlagHelp("telemetry", subcommandOriginal);
        printHelp(enableSubcommand3);
        return 2;
      }
      telemetryClient.trackCliSubcommandEnable(subcommandOriginal);
      return enable3(client);
    case "disable":
      if (needHelp) {
        telemetryClient.trackCliFlagHelp("telemetry", subcommandOriginal);
        printHelp(disableSubcommand3);
        return 2;
      }
      return disable3(client);
    default: {
      const errorMessage = parsedArguments.args.length !== 2 ? "Invalid number of arguments" : "Invalid subcommand";
      output_manager_default.print(
        `${import_chalk100.default.red("Error")}: ${errorMessage}. See help instructions for usage:
`
      );
      output_manager_default.print(help(telemetryCommand, { columns: client.stderr.columns }));
      return 2;
    }
  }
}

// src/commands/upgrade/index.ts
init_pkg();

// src/util/telemetry/commands/upgrade/index.ts
var UpgradeTelemetryClient = class extends TelemetryClient {
  trackCliFlagDryRun(dryRun) {
    if (dryRun) {
      this.trackCliFlag("dry-run");
    }
  }
  trackCliFlagJson(json) {
    if (json) {
      this.trackCliFlag("json");
    }
  }
};

// src/commands/upgrade/index.ts
async function upgrade(client) {
  let parsedArgs = null;
  const flagsSpecification = getFlagsSpecification(upgradeCommand.options);
  const telemetry2 = new UpgradeTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  if (parsedArgs.flags["--help"]) {
    telemetry2.trackCliFlagHelp("upgrade");
    output_manager_default.print(help(upgradeCommand, { columns: client.stderr.columns }));
    return 0;
  }
  const dryRun = parsedArgs.flags["--dry-run"];
  const formatResult = validateJsonOutput(parsedArgs.flags);
  if (!formatResult.valid) {
    output_manager_default.error(formatResult.error);
    return 1;
  }
  const asJson = formatResult.jsonOutput;
  telemetry2.trackCliFlagDryRun(dryRun);
  telemetry2.trackCliOptionFormat(parsedArgs.flags["--format"]);
  telemetry2.trackCliFlagJson(parsedArgs.flags["--json"]);
  if (dryRun || asJson) {
    const updateCommand = await getUpdateCommand();
    const global = await isGlobal();
    if (asJson) {
      const jsonOutput = {
        currentVersion: pkg_default.version,
        installationType: global ? "global" : "local",
        upgradeCommand: updateCommand
      };
      client.stdout.write(`${JSON.stringify(jsonOutput, null, 2)}
`);
    } else {
      output_manager_default.print(`Current version: ${pkg_default.version}
`);
      output_manager_default.print(`Installation type: ${global ? "global" : "local"}
`);
      output_manager_default.print(`Upgrade command: ${updateCommand}
`);
    }
    return 0;
  }
  return executeUpgrade();
}

// src/commands/webhooks/ls.ts
var import_ms28 = __toESM(require_ms(), 1);
var import_chalk101 = __toESM(require_source(), 1);
var import_pluralize12 = __toESM(require_pluralize(), 1);

// src/util/webhooks/get-webhooks.ts
async function getWebhooks(client) {
  const response = await client.fetch("/v1/webhooks");
  if (Array.isArray(response)) {
    return { webhooks: response };
  }
  return response;
}

// src/util/telemetry/commands/webhooks/ls.ts
var WebhooksLsTelemetryClient = class extends TelemetryClient {
  trackCliOptionFormat(format4) {
    if (format4) {
      this.trackCliOption({
        option: "format",
        value: format4
      });
    }
  }
};

// src/commands/webhooks/ls.ts
async function ls6(client, argv) {
  const telemetry2 = new WebhooksLsTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(listSubcommand13.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  const validationResult = validateLsArgs({
    commandName: "webhooks ls",
    args,
    maxArgs: 0,
    exitCode: 2
  });
  if (validationResult !== 0) {
    return validationResult;
  }
  telemetry2.trackCliOptionFormat(opts["--format"]);
  const formatResult = validateJsonOutput(opts);
  if (!formatResult.valid) {
    output_manager_default.error(formatResult.error);
    return 1;
  }
  const asJson = formatResult.jsonOutput;
  const { contextName } = await getScope(client);
  const lsStamp = stamp_default();
  output_manager_default.spinner(`Fetching Webhooks under ${import_chalk101.default.bold(contextName)}`);
  const { webhooks } = await getWebhooks(client);
  if (asJson) {
    output_manager_default.stopSpinner();
    const jsonOutput = {
      webhooks: webhooks.map((webhook) => ({
        id: webhook.id,
        url: webhook.url,
        events: webhook.events,
        projectIds: webhook.projectIds,
        createdAt: webhook.createdAt,
        updatedAt: webhook.updatedAt
      }))
    };
    client.stdout.write(`${JSON.stringify(jsonOutput, null, 2)}
`);
  } else {
    output_manager_default.log(
      `${(0, import_pluralize12.default)("Webhook", webhooks.length, true)} found under ${import_chalk101.default.bold(
        contextName
      )} ${import_chalk101.default.gray(lsStamp())}`
    );
    if (webhooks.length > 0) {
      output_manager_default.print(
        formatWebhooksTable(webhooks).replace(/^(.*)/gm, `${" ".repeat(1)}$1`)
      );
      output_manager_default.print("\n\n");
    }
  }
  return 0;
}
function formatWebhooksTable(webhooks) {
  const current = Date.now();
  const rows = webhooks.map((webhook) => {
    const age = webhook.createdAt ? (0, import_ms28.default)(current - webhook.createdAt) : "-";
    const eventsDisplay = webhook.events.length > 2 ? `${webhook.events.slice(0, 2).join(", ")} +${webhook.events.length - 2}` : webhook.events.join(", ");
    return [webhook.id, webhook.url, eventsDisplay, import_chalk101.default.gray(age)];
  });
  return formatTable(
    ["ID", "URL", "Events", "Age"],
    ["l", "l", "l", "l"],
    [{ rows }]
  );
}

// src/commands/webhooks/get.ts
var import_chalk102 = __toESM(require_source(), 1);

// src/util/webhooks/get-webhook.ts
async function getWebhook(client, webhookId) {
  return await client.fetch(
    `/v1/webhooks/${encodeURIComponent(webhookId)}`
  );
}

// src/util/telemetry/commands/webhooks/get.ts
var WebhooksGetTelemetryClient = class extends TelemetryClient {
  trackCliArgumentId(id) {
    if (id) {
      this.trackCliArgument({
        arg: "id",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionFormat(format4) {
    if (format4) {
      this.trackCliOption({
        option: "format",
        value: format4
      });
    }
  }
};

// src/commands/webhooks/get.ts
async function get(client, argv) {
  const telemetry2 = new WebhooksGetTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(getSubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  const [webhookId] = args;
  const getStamp = stamp_default();
  if (!webhookId) {
    output_manager_default.error(`${getCommandName(`webhooks get <id>`)} expects one argument`);
    return 1;
  }
  telemetry2.trackCliArgumentId(webhookId);
  telemetry2.trackCliOptionFormat(opts["--format"]);
  const formatResult = validateJsonOutput(opts);
  if (!formatResult.valid) {
    output_manager_default.error(formatResult.error);
    return 1;
  }
  const asJson = formatResult.jsonOutput;
  if (args.length !== 1) {
    output_manager_default.error(
      `Invalid number of arguments. Usage: ${import_chalk102.default.cyan(
        `${getCommandName("webhooks get <id>")}`
      )}`
    );
    return 1;
  }
  output_manager_default.debug(`Fetching webhook info`);
  const { contextName } = await getScope(client);
  output_manager_default.spinner(
    `Fetching Webhook ${webhookId} under ${import_chalk102.default.bold(contextName)}`
  );
  let webhook;
  try {
    webhook = await getWebhook(client, webhookId);
  } catch (err) {
    if (isAPIError(err) && err.status === 404) {
      output_manager_default.error(`Webhook not found: ${webhookId}`);
      output_manager_default.log(`Run ${getCommandName(`webhooks ls`)} to see your webhooks.`);
      return 1;
    }
    throw err;
  }
  if (asJson) {
    output_manager_default.stopSpinner();
    client.stdout.write(`${JSON.stringify(webhook, null, 2)}
`);
  } else {
    output_manager_default.log(
      `Webhook ${webhookId} found under ${import_chalk102.default.bold(contextName)} ${import_chalk102.default.gray(
        getStamp()
      )}`
    );
    output_manager_default.print("\n");
    output_manager_default.print(import_chalk102.default.bold("  General\n\n"));
    output_manager_default.print(`    ${import_chalk102.default.cyan("ID")}			${webhook.id}
`);
    output_manager_default.print(`    ${import_chalk102.default.cyan("URL")}			${webhook.url}
`);
    output_manager_default.print(
      `    ${import_chalk102.default.cyan("Created At")}		${formatDate(webhook.createdAt)}
`
    );
    output_manager_default.print(
      `    ${import_chalk102.default.cyan("Updated At")}		${formatDate(webhook.updatedAt)}
`
    );
    output_manager_default.print("\n");
    output_manager_default.print(import_chalk102.default.bold("  Events\n\n"));
    for (const event of webhook.events) {
      output_manager_default.print(`    - ${event}
`);
    }
    if (webhook.projectIds && webhook.projectIds.length > 0) {
      output_manager_default.print("\n");
      output_manager_default.print(import_chalk102.default.bold("  Projects\n\n"));
      if (webhook.projectsMetadata && webhook.projectsMetadata.length > 0) {
        for (const project of webhook.projectsMetadata) {
          output_manager_default.print(`    - ${project.name} (${project.id})
`);
        }
      } else {
        for (const projectId of webhook.projectIds) {
          output_manager_default.print(`    - ${projectId}
`);
        }
      }
    }
    output_manager_default.print("\n");
  }
  return 0;
}

// src/commands/webhooks/create.ts
var import_chalk103 = __toESM(require_source(), 1);

// src/util/webhooks/create-webhook.ts
async function createWebhook(client, payload) {
  return await client.fetch("/v1/webhooks", {
    method: "POST",
    body: payload
  });
}

// src/util/telemetry/commands/webhooks/create.ts
var WebhooksCreateTelemetryClient = class extends TelemetryClient {
  trackCliArgumentUrl(url) {
    if (url) {
      this.trackCliArgument({
        arg: "url",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionEvent(events) {
    if (events && events.length > 0) {
      this.trackCliOption({
        option: "event",
        value: String(events.length)
      });
    }
  }
  trackCliOptionProject(projects) {
    if (projects && projects.length > 0) {
      this.trackCliOption({
        option: "project",
        value: String(projects.length)
      });
    }
  }
};

// src/util/webhooks/get-webhook-events.ts
var cachedEvents = null;
async function getWebhookEvents() {
  if (cachedEvents) {
    return cachedEvents;
  }
  const cache = new OpenApiCache();
  const loaded = await cache.load();
  if (!loaded) {
    output_manager_default.debug("Failed to load OpenAPI spec for webhook events");
    return [];
  }
  const endpoints = cache.getEndpoints();
  const createWebhookEndpoint = endpoints.find(
    (e2) => e2.path === "/v1/webhooks" && e2.method === "POST"
  );
  if (!createWebhookEndpoint) {
    output_manager_default.debug("Could not find POST /v1/webhooks endpoint in OpenAPI spec");
    return [];
  }
  const bodyFields = cache.getBodyFields(createWebhookEndpoint);
  const eventsField = bodyFields.find((f) => f.name === "events");
  if (!eventsField?.enumValues) {
    output_manager_default.debug("Could not find events enum in webhook endpoint");
    return [];
  }
  cachedEvents = eventsField.enumValues.filter(
    (v) => typeof v === "string"
  );
  return cachedEvents;
}
async function validateWebhookEvents(events) {
  const validEvents = await getWebhookEvents();
  if (validEvents.length === 0) {
    return [];
  }
  const validSet = new Set(validEvents);
  return events.filter((e2) => !validSet.has(e2));
}

// src/commands/webhooks/create.ts
async function create(client, argv) {
  const telemetry2 = new WebhooksCreateTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(createSubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  const [url] = args;
  telemetry2.trackCliArgumentUrl(url);
  if (!url) {
    output_manager_default.error(
      `${getCommandName(`webhooks create <url>`)} expects one argument`
    );
    return 1;
  }
  try {
    const urlObj = new URL(url);
    if (!["http:", "https:"].includes(urlObj.protocol)) {
      output_manager_default.error("Webhook URL must use http or https protocol");
      return 1;
    }
  } catch {
    output_manager_default.error(`Invalid URL: ${url}`);
    return 1;
  }
  const events = opts["--event"];
  const projectIds = opts["--project"];
  if (!events || events.length === 0) {
    output_manager_default.error(
      `At least one event is required. Use ${import_chalk103.default.cyan("--event <event>")} to specify events.`
    );
    output_manager_default.log(
      `Example: ${getCommandName(
        "webhooks create https://example.com/webhook --event deployment.created"
      )}`
    );
    return 1;
  }
  const invalidEvents = await validateWebhookEvents(events);
  if (invalidEvents.length > 0) {
    output_manager_default.error(
      `Invalid event type${invalidEvents.length > 1 ? "s" : ""}: ${invalidEvents.join(", ")}`
    );
    return 1;
  }
  telemetry2.trackCliOptionEvent(events);
  telemetry2.trackCliOptionProject(projectIds);
  const { contextName } = await getScope(client);
  const createStamp = stamp_default();
  output_manager_default.spinner(`Creating webhook under ${import_chalk103.default.bold(contextName)}`);
  try {
    const webhook = await createWebhook(client, {
      url,
      events,
      projectIds
    });
    output_manager_default.success(
      `Webhook created: ${import_chalk103.default.bold(webhook.id)} ${createStamp()}`
    );
    output_manager_default.print("\n");
    output_manager_default.print(import_chalk103.default.bold("  Webhook Details\n\n"));
    output_manager_default.print(`    ${import_chalk103.default.cyan("ID")}		${webhook.id}
`);
    output_manager_default.print(`    ${import_chalk103.default.cyan("URL")}		${webhook.url}
`);
    output_manager_default.print(
      `    ${import_chalk103.default.cyan("Events")}		${webhook.events.join(", ")}
`
    );
    if (webhook.projectIds && webhook.projectIds.length > 0) {
      output_manager_default.print(
        `    ${import_chalk103.default.cyan("Projects")}	${webhook.projectIds.join(", ")}
`
      );
    }
    output_manager_default.print("\n");
    output_manager_default.warn(
      `Save this secret - it will not be shown again: ${import_chalk103.default.bold(webhook.secret)}`
    );
    output_manager_default.print("\n");
    return 0;
  } catch (err) {
    if (isAPIError(err)) {
      if (err.code === "invalid_url") {
        output_manager_default.error(`Invalid webhook URL: ${url}`);
        return 1;
      }
      if (err.code === "invalid_event") {
        output_manager_default.error(`Invalid event type. Please check the event names.`);
        return 1;
      }
      output_manager_default.error(err.message);
      return 1;
    }
    throw err;
  }
}

// src/commands/webhooks/rm.ts
var import_chalk104 = __toESM(require_source(), 1);

// src/util/webhooks/delete-webhook.ts
async function deleteWebhook(client, webhookId) {
  await client.fetch(`/v1/webhooks/${encodeURIComponent(webhookId)}`, {
    method: "DELETE"
  });
}

// src/util/telemetry/commands/webhooks/rm.ts
var WebhooksRmTelemetryClient = class extends TelemetryClient {
  trackCliArgumentId(id) {
    if (id) {
      this.trackCliArgument({
        arg: "id",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
};

// src/commands/webhooks/rm.ts
async function rm7(client, argv) {
  const telemetry2 = new WebhooksRmTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(removeSubcommand10.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  const [webhookId] = args;
  telemetry2.trackCliArgumentId(webhookId);
  telemetry2.trackCliFlagYes(opts["--yes"]);
  if (!webhookId) {
    output_manager_default.error(`${getCommandName(`webhooks rm <id>`)} expects one argument`);
    return 1;
  }
  const { contextName } = await getScope(client);
  if (args.length !== 1) {
    output_manager_default.error(
      `Invalid number of arguments. Usage: ${import_chalk104.default.cyan(
        `${getCommandName("webhooks rm <id>")}`
      )}`
    );
    return 1;
  }
  output_manager_default.spinner(`Fetching webhook ${webhookId}`);
  let webhook;
  try {
    webhook = await getWebhook(client, webhookId);
  } catch (err) {
    if (isAPIError(err) && err.status === 404) {
      output_manager_default.error(`Webhook not found: ${webhookId}`);
      output_manager_default.log(`Run ${getCommandName(`webhooks ls`)} to see your webhooks.`);
      return 1;
    }
    throw err;
  }
  output_manager_default.stopSpinner();
  const skipConfirmation = opts["--yes"] || false;
  if (!skipConfirmation && !await client.input.confirm(
    `Are you sure you want to remove webhook ${param(webhookId)} (${webhook.url})?`,
    false
  )) {
    output_manager_default.log("Canceled");
    return 0;
  }
  const removeStamp = stamp_default();
  output_manager_default.spinner(`Removing webhook under ${import_chalk104.default.bold(contextName)}`);
  try {
    await deleteWebhook(client, webhookId);
    output_manager_default.success(`Webhook ${import_chalk104.default.bold(webhookId)} removed ${removeStamp()}`);
    return 0;
  } catch (err) {
    if (isAPIError(err) && err.status === 404) {
      output_manager_default.error(`Webhook not found: ${webhookId}`);
      return 1;
    }
    throw err;
  }
}

// src/util/telemetry/commands/webhooks/index.ts
var WebhooksTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandCreate(actual) {
    this.trackCliSubcommand({
      subcommand: "create",
      value: actual
    });
  }
  trackCliSubcommandGet(actual) {
    this.trackCliSubcommand({
      subcommand: "get",
      value: actual
    });
  }
  trackCliSubcommandRemove(actual) {
    this.trackCliSubcommand({
      subcommand: "remove",
      value: actual
    });
  }
  trackCliSubcommandList(actual) {
    this.trackCliSubcommand({
      subcommand: "list",
      value: actual
    });
  }
};

// src/commands/webhooks/index.ts
var COMMAND_CONFIG22 = {
  create: ["create", "add"],
  get: ["get", "inspect"],
  ls: ["ls", "list"],
  rm: ["rm", "remove", "delete"]
};
async function main16(client) {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(webhooksCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification, {
      permissive: true
    });
  } catch (error) {
    printError(error);
    return 1;
  }
  const telemetry2 = new WebhooksTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const { subcommand, args, subcommandOriginal } = getSubcommand2(
    parsedArgs.args.slice(1),
    COMMAND_CONFIG22
  );
  const needHelp = parsedArgs.flags["--help"];
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp("webhooks");
    output_manager_default.print(help(webhooksCommand, { columns: client.stderr.columns }));
    return 2;
  }
  function printHelp(command) {
    output_manager_default.print(
      help(command, { parent: webhooksCommand, columns: client.stderr.columns })
    );
    return 2;
  }
  switch (subcommand) {
    case "create":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("webhooks", subcommandOriginal);
        return printHelp(createSubcommand);
      }
      telemetry2.trackCliSubcommandCreate(subcommandOriginal);
      return create(client, args);
    case "get":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("webhooks", subcommandOriginal);
        return printHelp(getSubcommand);
      }
      telemetry2.trackCliSubcommandGet(subcommandOriginal);
      return get(client, args);
    case "rm":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("webhooks", subcommandOriginal);
        return printHelp(removeSubcommand10);
      }
      telemetry2.trackCliSubcommandRemove(subcommandOriginal);
      return rm7(client, args);
    default:
      if (needHelp) {
        telemetry2.trackCliFlagHelp("webhooks", subcommandOriginal);
        return printHelp(listSubcommand13);
      }
      telemetry2.trackCliSubcommandList(subcommandOriginal);
      return ls6(client, args);
  }
}

// src/util/telemetry/commands/whoami/index.ts
var WhoamiTelemetryClient = class extends TelemetryClient {
};

// src/commands/whoami/index.ts
async function whoami(client) {
  let parsedArgs = null;
  const flagsSpecification = getFlagsSpecification(whoamiCommand.options);
  const telemetry2 = new WhoamiTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  if (parsedArgs.flags["--help"]) {
    telemetry2.trackCliFlagHelp("whoami");
    output_manager_default.print(help(whoamiCommand, { columns: client.stderr.columns }));
    return 0;
  }
  const formatResult = validateJsonOutput(parsedArgs.flags);
  if (!formatResult.valid) {
    output_manager_default.error(formatResult.error);
    return 1;
  }
  const asJson = formatResult.jsonOutput;
  telemetry2.trackCliOptionFormat(parsedArgs.flags["--format"]);
  const { contextName, user } = await getScope(client, { getTeam: false });
  if (asJson) {
    const jsonOutput = {
      username: user.username,
      email: user.email,
      name: user.name
    };
    client.stdout.write(`${JSON.stringify(jsonOutput, null, 2)}
`);
  } else if (client.stdout.isTTY) {
    output_manager_default.log(contextName);
  } else {
    client.stdout.write(`${contextName}
`);
  }
  return 0;
}
export {
  alias,
  api,
  bisect,
  main2 as blob,
  main3 as cache,
  main4 as certs,
  curl,
  dns,
  main5 as domains,
  main6 as flags,
  main7 as git,
  guidance,
  httpstat,
  main8 as init,
  inspect3 as inspect,
  install,
  main9 as integration,
  main10 as integrationResource,
  login,
  logout2 as logout,
  logs,
  main11 as mcp,
  main12 as microfrontends,
  openCommandHandler as open,
  main13 as project,
  promote_default as promote,
  main as pull,
  redeploy,
  main14 as redirects,
  remove4 as remove,
  rollback_default as rollback,
  rollingRelease,
  main15 as target,
  teams,
  telemetry,
  upgrade,
  main16 as webhooks,
  whoami
};

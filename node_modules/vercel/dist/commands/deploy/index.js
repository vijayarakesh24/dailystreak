import { createRequire as __createRequire } from 'node:module';
import { fileURLToPath as __fileURLToPath } from 'node:url';
import { dirname as __dirname_ } from 'node:path';
const require = __createRequire(import.meta.url);
const __filename = __fileURLToPath(import.meta.url);
const __dirname = __dirname_(__filename);
import {
  Now,
  UploadErrorMissingArchive,
  createCertForCns,
  displayBuildLogsUntilFinalError,
  printDeploymentStatus,
  purchaseDomainIfAvailable,
  require_cjs,
  setupDomain
} from "../../chunks/chunk-JFI4KZ6I.js";
import {
  readLocalConfig
} from "../../chunks/chunk-NHDFW4ZT.js";
import {
  highlight
} from "../../chunks/chunk-2XDWQZS5.js";
import "../../chunks/chunk-NSDOFVJX.js";
import {
  parseMeta
} from "../../chunks/chunk-EKPSCRJZ.js";
import {
  getDeployment,
  mapCertError
} from "../../chunks/chunk-KPWGRSMM.js";
import "../../chunks/chunk-G5PIH4IE.js";
import {
  deployCommand,
  deprecatedArchiveSplitTgz
} from "../../chunks/chunk-S367OLQP.js";
import {
  pickOverrides
} from "../../chunks/chunk-4LIW5I5B.js";
import {
  require_dist as require_dist2
} from "../../chunks/chunk-PFKNXAIG.js";
import "../../chunks/chunk-7OCX2CUX.js";
import "../../chunks/chunk-HEYUAUQE.js";
import {
  ensureLink
} from "../../chunks/chunk-I3CS55DR.js";
import {
  validatePaths,
  validateRootDirectory
} from "../../chunks/chunk-RPXSHEGV.js";
import "../../chunks/chunk-7AN5BKPP.js";
import {
  compileVercelConfig
} from "../../chunks/chunk-I4USAAOX.js";
import {
  help
} from "../../chunks/chunk-YO3WHMKT.js";
import {
  AliasDomainConfigured,
  BuildError,
  BuildsRateLimited,
  ConflictingConfigFiles,
  ConflictingFilePath,
  ConflictingPathSegment,
  DeploymentNotFound,
  DeploymentsRateLimited,
  DomainNotFound,
  DomainNotVerified,
  DomainPermissionDenied,
  DomainVerificationFailed,
  InvalidDomain,
  MissingBuildScript,
  NotDomainOwner,
  NowError,
  SchemaValidationFailed,
  TelemetryClient,
  TooManyRequests,
  UserAborted,
  code,
  createGitMeta,
  getCommandName,
  getFlagsSpecification,
  isAPIError,
  param,
  parseArguments,
  parseEnv,
  parseTarget,
  printError,
  require_bytes,
  require_lib,
  require_ms,
  stamp_default
} from "../../chunks/chunk-62EDLXXJ.js";
import {
  emoji,
  output_manager_default,
  prependEmoji,
  require_dist
} from "../../chunks/chunk-6TPHDHH6.js";
import {
  require_source
} from "../../chunks/chunk-6H7E5JAU.js";
import {
  __toESM
} from "../../chunks/chunk-LCYENQ63.js";

// src/commands/deploy/index.ts
var import_client3 = __toESM(require_dist2(), 1);
var import_error_utils = __toESM(require_dist(), 1);
var import_bytes = __toESM(require_bytes(), 1);
var import_chalk = __toESM(require_source(), 1);
var import_fs_extra2 = __toESM(require_lib(), 1);
var import_ms = __toESM(require_ms(), 1);
import {
  getPrettyError,
  getSupportedNodeVersion,
  scanParentDirs
} from "@vercel/build-utils";
import { join as join2, resolve } from "path";

// src/util/deploy/generate-cert-for-deploy.ts
var import_tldts = __toESM(require_cjs(), 1);
async function generateCertForDeploy(client, contextName, deployURL) {
  const parsedDomain = (0, import_tldts.parse)(deployURL);
  const { domain } = parsedDomain;
  if (!domain) {
    return new InvalidDomain(deployURL);
  }
  output_manager_default.spinner(`Setting custom suffix domain ${domain}`);
  const result = await setupDomain(client, domain, contextName);
  output_manager_default.stopSpinner();
  if (result instanceof NowError) {
    return result;
  }
  output_manager_default.spinner(`Generating a wildcard certificate for ${domain}`);
  const cert = await createCertForCns(
    client,
    [domain, `*.${domain}`],
    contextName
  );
  output_manager_default.stopSpinner();
  if (cert instanceof NowError) {
    return cert;
  }
}

// src/util/deploy/create-deploy.ts
async function createDeploy(client, now, contextName, path, createArgs, org, isSettingUpProject, archive) {
  try {
    return await now.create(path, createArgs, org, isSettingUpProject, archive);
  } catch (err) {
    if (isAPIError(err)) {
      if (err.code === "rate_limited") {
        throw new DeploymentsRateLimited(err.message);
      }
      if (err.code === "domain_missing") {
        throw new DomainNotFound(err.value);
      }
      if (err.code === "domain_not_found" && err.domain) {
        throw new DomainNotFound(err.domain);
      }
      if (err.code === "domain_not_verified" && err.domain) {
        throw new DomainNotVerified(err.domain);
      }
      if (err.code === "domain_not_verified" && err.value) {
        throw new DomainVerificationFailed(err.value);
      }
      if (err.code === "not_domain_owner") {
        throw new NotDomainOwner(err.message);
      }
      if (err.code === "builds_rate_limited") {
        throw new BuildsRateLimited(err.message);
      }
      if (err.code === "forbidden") {
        throw new DomainPermissionDenied(err.value, contextName);
      }
      if (err.code === "bad_request" && err.keyword) {
        throw new SchemaValidationFailed(
          err.message,
          err.keyword,
          err.dataPath,
          err.params
        );
      }
      if (err.code === "domain_configured") {
        throw new AliasDomainConfigured(err);
      }
      if (err.code === "missing_build_script") {
        throw new MissingBuildScript(err);
      }
      if (err.code === "conflicting_file_path") {
        throw new ConflictingFilePath(err);
      }
      if (err.code === "conflicting_path_segment") {
        throw new ConflictingPathSegment(err);
      }
      if (err.code === "cert_missing") {
        const result = await generateCertForDeploy(
          client,
          contextName,
          err.value
        );
        if (result instanceof NowError) {
          return result;
        }
        return createDeploy(
          client,
          now,
          contextName,
          path,
          createArgs,
          org,
          isSettingUpProject
        );
      }
      if (err.code === "not_found") {
        throw new DeploymentNotFound({ context: contextName });
      }
      const certError = mapCertError(err);
      if (certError) {
        return certError;
      }
    }
    throw err;
  }
}

// src/util/deploy/get-deployment-checks.ts
async function getDeploymentChecks(client, deploymentId) {
  const checksResponse = await client.fetch(
    `/v1/deployments/${encodeURIComponent(deploymentId)}/checks`
  );
  return checksResponse;
}

// src/util/deploy/get-prebuilt-json.ts
var import_fs_extra = __toESM(require_lib(), 1);
import { join } from "path";
async function getPrebuiltJson(directory) {
  try {
    return await import_fs_extra.default.readJSON(join(directory, "builds.json"));
  } catch (error) {
  }
  return null;
}

// src/util/deploy/validate-archive-format.ts
var import_client = __toESM(require_dist2(), 1);
var validArchiveFormats = new Set(import_client.VALID_ARCHIVE_FORMATS);
function isValidArchive(archive) {
  return validArchiveFormats.has(archive);
}

// src/util/get-project-name.ts
import { basename } from "path";
function getProjectName({
  nameParam,
  nowConfig = {},
  paths = []
}) {
  if (nameParam) {
    return nameParam;
  }
  if (nowConfig.name) {
    return nowConfig.name;
  }
  return basename(paths[0] || "");
}

// src/util/telemetry/commands/deploy/index.ts
var import_client2 = __toESM(require_dist2(), 1);
var DeployTelemetryClient = class extends TelemetryClient {
  trackCliArgumentProjectPath(projectPaths) {
    if (projectPaths) {
      this.trackCliArgument({
        arg: "project-path",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionArchive(format) {
    if (format) {
      const allowedFormat = [
        ...import_client2.VALID_ARCHIVE_FORMATS,
        deprecatedArchiveSplitTgz
      ].includes(format) ? format : this.redactedValue;
      this.trackCliOption({
        option: "archive",
        value: allowedFormat
      });
    }
  }
  trackCliOptionBuildEnv(buildEnv) {
    if (buildEnv && buildEnv.length > 0) {
      this.trackCliOption({
        option: "build-env",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionEnv(env) {
    if (env && env.length > 0) {
      this.trackCliOption({
        option: "env",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionMeta(meta) {
    if (meta && meta.length > 0) {
      this.trackCliOption({
        option: "meta",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionName(name) {
    if (name) {
      this.trackCliOption({
        option: "name",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionRegions(regions) {
    if (regions) {
      this.trackCliOption({
        option: "regions",
        // consider revisiting once we come up with a way to query the list of regions
        value: this.redactedValue
      });
    }
  }
  trackCliOptionTarget(target) {
    if (target) {
      this.trackCliOption({
        option: "target",
        value: this.redactedTargetName(target)
      });
    }
  }
  trackCliFlagConfirm(flag) {
    if (flag) {
      this.trackCliFlag("confirm");
    }
  }
  trackCliFlagForce(flag) {
    if (flag) {
      this.trackCliFlag("force");
    }
  }
  trackCliFlagLogs(flag) {
    if (flag) {
      this.trackCliFlag("logs");
    }
  }
  trackCliFlagNoLogs(flag) {
    if (flag) {
      this.trackCliFlag("no-logs");
    }
  }
  trackCliFlagGuidance(flag) {
    if (flag) {
      this.trackCliFlag("guidance");
    }
  }
  trackCliFlagNoClipboard(flag) {
    if (flag) {
      this.trackCliFlag("no-clipboard");
    }
  }
  trackCliFlagNoWait(flag) {
    if (flag) {
      this.trackCliFlag("no-wait");
    }
  }
  trackCliFlagPrebuilt(flag) {
    if (flag) {
      this.trackCliFlag("prebuilt");
    }
  }
  trackCliFlagProd(flag) {
    if (flag) {
      this.trackCliFlag("prod");
    }
  }
  trackCliFlagPublic(flag) {
    if (flag) {
      this.trackCliFlag("public");
    }
  }
  trackCliFlagSkipDomain(flag) {
    if (flag) {
      this.trackCliFlag("skip-domain");
    }
  }
  trackCliFlagWithCache(flag) {
    if (flag) {
      this.trackCliFlag("with-cache");
    }
  }
  trackCliFlagYes(flag) {
    if (flag) {
      this.trackCliFlag("yes");
    }
  }
  trackDeploymentId(id) {
    if (id) {
      this.trackCommandOutput({
        key: "deployment-id",
        value: id
      });
    }
  }
};

// src/commands/deploy/index.ts
import { determineAgent } from "@vercel/detect-agent";
var deploy_default = async (client) => {
  const telemetryClient = new DeployTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArguments = null;
  const flagsSpecification = getFlagsSpecification(deployCommand.options);
  try {
    parsedArguments = parseArguments(client.argv.slice(2), flagsSpecification);
    telemetryClient.trackCliOptionArchive(parsedArguments.flags["--archive"]);
    telemetryClient.trackCliOptionEnv(parsedArguments.flags["--env"]);
    telemetryClient.trackCliOptionBuildEnv(
      parsedArguments.flags["--build-env"]
    );
    telemetryClient.trackCliOptionMeta(parsedArguments.flags["--meta"]);
    telemetryClient.trackCliFlagPrebuilt(parsedArguments.flags["--prebuilt"]);
    telemetryClient.trackCliOptionRegions(parsedArguments.flags["--regions"]);
    telemetryClient.trackCliFlagNoWait(parsedArguments.flags["--no-wait"]);
    telemetryClient.trackCliFlagYes(parsedArguments.flags["--yes"]);
    telemetryClient.trackCliOptionTarget(parsedArguments.flags["--target"]);
    telemetryClient.trackCliFlagProd(parsedArguments.flags["--prod"]);
    telemetryClient.trackCliFlagSkipDomain(
      parsedArguments.flags["--skip-domain"]
    );
    telemetryClient.trackCliFlagPublic(parsedArguments.flags["--public"]);
    telemetryClient.trackCliFlagLogs(parsedArguments.flags["--logs"]);
    telemetryClient.trackCliFlagNoLogs(parsedArguments.flags["--no-logs"]);
    telemetryClient.trackCliFlagGuidance(parsedArguments.flags["--guidance"]);
    telemetryClient.trackCliFlagForce(parsedArguments.flags["--force"]);
    telemetryClient.trackCliFlagWithCache(
      parsedArguments.flags["--with-cache"]
    );
    if ("--confirm" in parsedArguments.flags) {
      telemetryClient.trackCliFlagConfirm(parsedArguments.flags["--confirm"]);
      output_manager_default.warn("`--confirm` is deprecated, please use `--yes` instead");
      parsedArguments.flags["--yes"] = parsedArguments.flags["--confirm"];
    }
    if ("--no-logs" in parsedArguments.flags) {
      output_manager_default.warn("`--no-logs` is deprecated and now the default behavior.");
    }
  } catch (error2) {
    printError(error2);
    return 1;
  }
  if (parsedArguments.flags["--help"]) {
    telemetryClient.trackCliFlagHelp("deploy");
    output_manager_default.print(help(deployCommand, { columns: client.stderr.columns }));
    return 2;
  }
  if (parsedArguments.args[0] === deployCommand.name) {
    parsedArguments.args.shift();
  }
  let paths;
  if (parsedArguments.args.length > 0) {
    paths = parsedArguments.args.map((item) => resolve(client.cwd, item));
    telemetryClient.trackCliArgumentProjectPath(paths[0]);
  } else {
    paths = [client.cwd];
  }
  const pathValidation = await validatePaths(client, paths);
  if (!pathValidation.valid) {
    return pathValidation.exitCode;
  }
  await compileVercelConfig(paths[0]);
  let localConfig = client.localConfig || readLocalConfig(paths[0]);
  if (localConfig) {
    client.localConfig = localConfig;
    const { version } = localConfig;
    const file = highlight(localConfig[import_client3.fileNameSymbol]);
    const prop = code("version");
    if (version) {
      if (typeof version === "number") {
        if (version !== 2) {
          const two = code(String(2));
          output_manager_default.error(
            `The value of the ${prop} property within ${file} can only be ${two}.`
          );
          return 1;
        }
      } else {
        output_manager_default.error(
          `The ${prop} property inside your ${file} file must be a number.`
        );
        return 1;
      }
    }
  }
  const { log, debug, error, prettyError } = output_manager_default;
  const quiet = !client.stdout.isTTY;
  let { path: cwd } = pathValidation;
  const autoConfirm = parsedArguments.flags["--yes"];
  if (parsedArguments.flags["--name"]) {
    output_manager_default.print(
      `${prependEmoji(
        `The ${param(
          "--name"
        )} option is deprecated (https://vercel.link/name-flag)`,
        emoji("warning")
      )}
`
    );
    telemetryClient.trackCliOptionName(parsedArguments.flags["--name"]);
  }
  if (parsedArguments.flags["--no-clipboard"]) {
    output_manager_default.print(
      `${prependEmoji(
        `The ${param(
          "--no-clipboard"
        )} option was ignored because it is the default behavior. Please remove it.`,
        emoji("warning")
      )}
`
    );
    telemetryClient.trackCliFlagNoClipboard(true);
  }
  const target = parseTarget({
    flagName: "target",
    flags: parsedArguments.flags
  });
  const parsedArchive = parsedArguments.flags["--archive"];
  if (typeof parsedArchive === "string" && !(isValidArchive(parsedArchive) || parsedArchive === deprecatedArchiveSplitTgz)) {
    output_manager_default.error(`Format must be one of: ${import_client3.VALID_ARCHIVE_FORMATS.join(", ")}`);
    return 1;
  }
  if (parsedArchive === deprecatedArchiveSplitTgz) {
    output_manager_default.print(
      `${prependEmoji(
        `${param("--archive=tgz")} now has the same behavior as ${param(
          "--archive=split-tgz"
        )}. Please use ${param("--archive=tgz")} instead.`,
        emoji("warning")
      )}
`
    );
  }
  const link = await ensureLink("deploy", client, cwd, {
    autoConfirm,
    setupMsg: "Set up and deploy",
    projectName: getProjectName({
      nameParam: parsedArguments.flags["--name"],
      nowConfig: localConfig,
      paths
    })
  });
  if (typeof link === "number") {
    return link;
  }
  const { org, project } = link;
  const rootDirectory = project.rootDirectory;
  const sourceFilesOutsideRootDirectory = project.sourceFilesOutsideRootDirectory ?? true;
  if (link.repoRoot) {
    cwd = link.repoRoot;
  }
  let vercelOutputDir;
  if (parsedArguments.flags["--prebuilt"]) {
    vercelOutputDir = join2(cwd, ".vercel/output");
    if (link.repoRoot && link.project.rootDirectory) {
      vercelOutputDir = join2(cwd, link.project.rootDirectory, ".vercel/output");
    }
    const prebuiltExists = await import_fs_extra2.default.pathExists(vercelOutputDir);
    if (!prebuiltExists) {
      error(
        `The ${param(
          "--prebuilt"
        )} option was used, but no prebuilt output found in ".vercel/output". Run ${getCommandName(
          "build"
        )} to generate a local build.`
      );
      return 1;
    }
    const prebuiltBuild = await getPrebuiltJson(vercelOutputDir);
    const prebuiltError = prebuiltBuild?.error || prebuiltBuild?.builds?.find((build) => "error" in build)?.error;
    if (prebuiltError) {
      output_manager_default.log(
        `Prebuilt deployment cannot be created because ${getCommandName(
          "build"
        )} failed with error:
`
      );
      prettyError(prebuiltError);
      return 1;
    }
    const assumedTarget = target || "preview";
    if (prebuiltBuild?.target && prebuiltBuild.target !== assumedTarget) {
      let specifyTarget = "";
      if (prebuiltBuild.target === "production") {
        specifyTarget = ` --prod`;
      }
      prettyError({
        message: `The ${param(
          "--prebuilt"
        )} option was used with the target environment "${assumedTarget}", but the prebuilt output found in ".vercel/output" was built with target environment "${prebuiltBuild.target}". Please run ${getCommandName(`--prebuilt${specifyTarget}`)}.`,
        link: "https://vercel.link/prebuilt-environment-mismatch"
      });
      return 1;
    }
  }
  const contextName = org.slug;
  client.config.currentTeam = org.type === "team" ? org.id : void 0;
  if (rootDirectory && await validateRootDirectory(
    cwd,
    join2(cwd, rootDirectory),
    project ? `To change your Project Settings, go to https://vercel.com/${org?.slug}/${project.name}/settings` : ""
  ) === false) {
    return 1;
  }
  if (rootDirectory) {
    const rootDirectoryPath = join2(cwd, rootDirectory);
    await compileVercelConfig(rootDirectoryPath);
    const rootDirectoryConfig = readLocalConfig(rootDirectoryPath);
    if (rootDirectoryConfig) {
      debug(`Read local config from root directory (${rootDirectory})`);
      localConfig = rootDirectoryConfig;
    } else if (localConfig) {
      output_manager_default.print(
        `${prependEmoji(
          `The ${highlight(
            localConfig[import_client3.fileNameSymbol]
          )} file should be inside of the provided root directory.`,
          emoji("warning")
        )}
`
      );
    }
  }
  localConfig = localConfig || {};
  if (localConfig.name) {
    output_manager_default.print(
      `${prependEmoji(
        `The ${code("name")} property in ${highlight(
          localConfig[import_client3.fileNameSymbol]
        )} is deprecated (https://vercel.link/name-prop)`,
        emoji("warning")
      )}
`
    );
  }
  const isObject = (item) => Object.prototype.toString.call(item) === "[object Object]";
  if (typeof localConfig.env !== "undefined" && !isObject(localConfig.env)) {
    error(
      `The ${code("env")} property in ${highlight(
        localConfig[import_client3.fileNameSymbol]
      )} needs to be an object`
    );
    return 1;
  }
  if (typeof localConfig.build !== "undefined") {
    if (!isObject(localConfig.build)) {
      error(
        `The ${code("build")} property in ${highlight(
          localConfig[import_client3.fileNameSymbol]
        )} needs to be an object`
      );
      return 1;
    }
    if (typeof localConfig.build.env !== "undefined" && !isObject(localConfig.build.env)) {
      error(
        `The ${code("build.env")} property in ${highlight(
          localConfig[import_client3.fileNameSymbol]
        )} needs to be an object`
      );
      return 1;
    }
  }
  const meta = Object.assign(
    {},
    parseMeta(localConfig.meta),
    parseMeta(parsedArguments.flags["--meta"])
  );
  const gitMetadata = await createGitMeta(cwd, project);
  const deploymentEnv = Object.assign(
    {},
    parseEnv(localConfig.env),
    parseEnv(parsedArguments.flags["--env"])
  );
  const deploymentBuildEnv = Object.assign(
    {},
    parseEnv(localConfig.build && localConfig.build.env),
    parseEnv(parsedArguments.flags["--build-env"])
  );
  try {
    await addProcessEnv(log, deploymentEnv);
    await addProcessEnv(log, deploymentBuildEnv);
  } catch (err) {
    error((0, import_error_utils.errorToString)(err));
    return 1;
  }
  const regionFlag = (parsedArguments.flags["--regions"] || "").split(",").map((s) => s.trim()).filter(Boolean);
  const regions = regionFlag.length > 0 ? regionFlag : localConfig.regions;
  const currentTeam = org.type === "team" ? org.id : void 0;
  const now = new Now({
    client,
    currentTeam
  });
  const deployStamp = stamp_default();
  let deployment = null;
  const noWait = !!parsedArguments.flags["--no-wait"];
  const withFullLogs = parsedArguments.flags["--logs"] ? true : false;
  const localConfigurationOverrides = pickOverrides(localConfig);
  const name = project.name;
  if (!name) {
    throw new Error(
      "`name` not found on project or provided by existing project"
    );
  }
  try {
    const autoAssignCustomDomains = parsedArguments.flags["--skip-domain"] ? false : void 0;
    const createArgs = {
      name,
      env: deploymentEnv,
      build: { env: deploymentBuildEnv },
      forceNew: parsedArguments.flags["--force"],
      withCache: parsedArguments.flags["--with-cache"],
      prebuilt: parsedArguments.flags["--prebuilt"],
      vercelOutputDir,
      rootDirectory,
      quiet,
      wantsPublic: Boolean(
        parsedArguments.flags["--public"] || localConfig.public
      ),
      nowConfig: {
        ...localConfig,
        // `images` is allowed in "vercel.json" and processed
        // by `vc build`, but don't send it to the API endpoint
        images: void 0
      },
      regions,
      meta,
      gitMetadata,
      deployStamp,
      target,
      skipAutoDetectionConfirmation: autoConfirm,
      noWait,
      withFullLogs,
      autoAssignCustomDomains,
      agentName: client.agentName
    };
    if (!localConfig.builds || localConfig.builds.length === 0) {
      createArgs.projectSettings = {
        sourceFilesOutsideRootDirectory,
        rootDirectory,
        ...localConfigurationOverrides
      };
    }
    const { packageJson } = await scanParentDirs(
      join2(cwd, project?.rootDirectory ?? ""),
      true,
      cwd
    );
    let nodeVersion;
    if (packageJson?.engines?.node) {
      try {
        const { range } = await getSupportedNodeVersion(
          packageJson.engines.node
        );
        nodeVersion = range;
      } catch (error2) {
        if (error2 instanceof Error) {
          output_manager_default.warn(error2.message);
        }
      }
    }
    if (!createArgs.projectSettings)
      createArgs.projectSettings = {};
    createArgs.projectSettings.nodeVersion = nodeVersion;
    deployment = await createDeploy(
      client,
      now,
      contextName,
      cwd,
      createArgs,
      org,
      !project,
      parsedArchive ? "tgz" : void 0
    );
    if (deployment && !(deployment instanceof Error)) {
      telemetryClient.trackDeploymentId(deployment.id);
    }
    if (deployment instanceof NotDomainOwner) {
      output_manager_default.error(deployment.message);
      return 1;
    }
    if (deployment instanceof Error) {
      output_manager_default.error(
        deployment.message || "An unexpected error occurred while deploying your project",
        void 0,
        "https://vercel.link/help",
        "Contact Support"
      );
      return 1;
    }
    if (deployment.readyState === "CANCELED") {
      output_manager_default.print("The deployment has been canceled.\n");
      return 1;
    }
    if (deployment.checksConclusion === "failed") {
      const { checks } = await getDeploymentChecks(client, deployment.id);
      const counters = /* @__PURE__ */ new Map();
      checks.forEach((c) => {
        counters.set(c.conclusion, (counters.get(c.conclusion) ?? 0) + 1);
      });
      const counterList = Array.from(counters).map(([name2, no]) => `${no} ${name2}`).join(", ");
      output_manager_default.error(`Running Checks: ${counterList}`);
      return 1;
    }
    if (!noWait) {
      await getDeployment(client, contextName, deployment.id);
    }
    if (deployment === null) {
      error("Uploading failed. Please try again.");
      return 1;
    }
  } catch (err) {
    if ((0, import_error_utils.isError)(err)) {
      debug(`Error: ${err}
${err.stack}`);
    }
    if (err instanceof UploadErrorMissingArchive) {
      output_manager_default.prettyError(err);
      return 1;
    }
    if (err instanceof NotDomainOwner) {
      output_manager_default.error(err.message);
      return 1;
    }
    if (err instanceof DomainNotFound && err.meta && err.meta.domain) {
      output_manager_default.debug(
        `The domain ${err.meta.domain} was not found, trying to purchase it`
      );
      const purchase = await purchaseDomainIfAvailable(
        client,
        err.meta.domain,
        contextName
      );
      if (purchase === true) {
        output_manager_default.success(`Successfully purchased the domain ${err.meta.domain}!`);
        return 0;
      }
      if (purchase === false || purchase instanceof UserAborted) {
        handleCreateDeployError(deployment, localConfig);
        return 1;
      }
      handleCreateDeployError(purchase, localConfig);
      return 1;
    }
    if (err instanceof DomainNotFound || err instanceof DomainNotVerified || err instanceof NotDomainOwner || err instanceof DomainPermissionDenied || err instanceof DomainVerificationFailed || err instanceof SchemaValidationFailed || err instanceof InvalidDomain || err instanceof DeploymentNotFound || err instanceof BuildsRateLimited || err instanceof DeploymentsRateLimited || err instanceof AliasDomainConfigured || err instanceof MissingBuildScript || err instanceof ConflictingFilePath || err instanceof ConflictingPathSegment || err instanceof ConflictingConfigFiles) {
      handleCreateDeployError(err, localConfig);
      return 1;
    }
    if (err instanceof BuildError) {
      if (withFullLogs === false) {
        try {
          if (now.url) {
            const failedDeployment = await getDeployment(
              client,
              contextName,
              now.url
            );
            await displayBuildLogsUntilFinalError(
              client,
              failedDeployment,
              err.message
            );
          }
        } catch (_) {
          output_manager_default.log(
            `To check build logs run: ${getCommandName(
              `inspect ${now.url} --logs`
            )}`
          );
          output_manager_default.log(
            `Or inspect them in your browser at https://${now.url}/_logs`
          );
        }
      }
      return 1;
    }
    if (isAPIError(err) && err.code === "size_limit_exceeded") {
      const { sizeLimit = 0 } = err;
      const message = `File size limit exceeded (${(0, import_bytes.default)(sizeLimit)})`;
      error(message);
      return 1;
    }
    printError(err);
    return 1;
  }
  const { isAgent } = await determineAgent();
  const guidanceMode = parsedArguments.flags["--guidance"] ?? isAgent;
  return printDeploymentStatus(deployment, deployStamp, noWait, guidanceMode);
};
function handleCreateDeployError(error, localConfig) {
  if (error instanceof InvalidDomain) {
    output_manager_default.error(`The domain ${error.meta.domain} is not valid`);
    return 1;
  }
  if (error instanceof DomainVerificationFailed) {
    output_manager_default.error(
      `The domain used as a suffix ${import_chalk.default.underline(
        error.meta.domain
      )} is not verified and can't be used as custom suffix.`
    );
    return 1;
  }
  if (error instanceof DomainPermissionDenied) {
    output_manager_default.error(
      `You don't have permissions to access the domain used as a suffix ${import_chalk.default.underline(
        error.meta.domain
      )}.`
    );
    return 1;
  }
  if (error instanceof SchemaValidationFailed) {
    const niceError = getPrettyError(error.meta);
    const fileName = localConfig[import_client3.fileNameSymbol] || "vercel.json";
    niceError.message = `Invalid ${fileName} - ${niceError.message}`;
    output_manager_default.prettyError(niceError);
    return 1;
  }
  if (error instanceof TooManyRequests) {
    output_manager_default.error(
      `Too many requests detected for ${error.meta.api} API. Try again in ${(0, import_ms.default)(
        error.meta.retryAfterMs,
        {
          long: true
        }
      )}.`
    );
    return 1;
  }
  if (error instanceof DomainNotVerified) {
    output_manager_default.error(
      `The domain used as an alias ${import_chalk.default.underline(
        error.meta.domain
      )} is not verified yet. Please verify it.`
    );
    return 1;
  }
  if (error instanceof BuildsRateLimited) {
    output_manager_default.error(error.message);
    output_manager_default.note(
      `Run ${getCommandName("upgrade")} to increase your builds limit.`
    );
    return 1;
  }
  if (error instanceof DeploymentNotFound || error instanceof NotDomainOwner || error instanceof DeploymentsRateLimited || error instanceof AliasDomainConfigured || error instanceof MissingBuildScript || error instanceof ConflictingFilePath || error instanceof ConflictingPathSegment || error instanceof ConflictingConfigFiles) {
    output_manager_default.error(error.message);
    return 1;
  }
  return error;
}
var addProcessEnv = async (log, env) => {
  let val;
  for (const key of Object.keys(env)) {
    if (typeof env[key] !== "undefined") {
      continue;
    }
    val = process.env[key];
    if (typeof val === "string") {
      log(
        `Reading ${import_chalk.default.bold(
          `"${import_chalk.default.bold(key)}"`
        )} from your env (as no value was specified)`
      );
      env[key] = val.replace(/^@/, "\\@");
    } else {
      throw new Error(
        `No value specified for env variable ${import_chalk.default.bold(
          `"${import_chalk.default.bold(key)}"`
        )} and it was not found in your env. If you meant to specify an environment to deploy to, use ${param("--target")}`
      );
    }
  }
};
export {
  deploy_default as default
};
